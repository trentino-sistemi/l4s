#
# Generated Fri Jun 27 12:33:54 2014 by generateDS.py version 2.12e.
#
# Command line options:
#   ('-o', 'sdmx_message.py')
#   ('-s', 'sdmxMessageSub.py')
#
# Command line arguments:
#   SDMXMessage.xsd
#
# Command line:
#   /home/pietro/lod4statenv/bin/generateDS.py -o "sdmx_message.py" SDMXMessage.xsd
#
# Current working directory (os.getcwd()):
#   test-sdmx
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class MessageType(GeneratedsSuper):
    """The Message is an abstract type which is used by all of the
    messages, to allow inheritance of common features. It also
    provides uniqueness constraints for the header fields."""
    subclass = None
    superclass = None
    def __init__(self, Header=None, extensiontype_=None):
        self.original_tagname_ = None
        self.Header = Header
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if MessageType.subclass:
            return MessageType.subclass(*args_, **kwargs_)
        else:
            return MessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Header(self): return self.Header
    def set_Header(self, Header): self.Header = Header
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.Header is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MessageType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MessageType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Header is not None:
            self.Header.export(outfile, level, namespace_, name_='Header', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MessageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Header is not None:
            showIndent(outfile, level)
            outfile.write('Header=model_.HeaderType(\n')
            self.Header.exportLiteral(outfile, level, name_='Header')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Header':
            obj_ = HeaderType.factory()
            obj_.build(child_)
            self.Header = obj_
            obj_.original_tagname_ = 'Header'
# end class MessageType


class StructureType(MessageType):
    """StructureType defines the contents of a structure message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, OrganisationSchemes=None, Dataflows=None, Metadataflows=None, CategorySchemes=None, CodeLists=None, HierarchicalCodelists=None, Concepts=None, MetadataStructureDefinitions=None, KeyFamilies=None, StructureSets=None, ReportingTaxonomies=None, Processes=None):
        self.original_tagname_ = None
        super(StructureType, self).__init__(Header, )
        self.OrganisationSchemes = OrganisationSchemes
        self.Dataflows = Dataflows
        self.Metadataflows = Metadataflows
        self.CategorySchemes = CategorySchemes
        self.CodeLists = CodeLists
        self.HierarchicalCodelists = HierarchicalCodelists
        self.Concepts = Concepts
        self.MetadataStructureDefinitions = MetadataStructureDefinitions
        self.KeyFamilies = KeyFamilies
        self.StructureSets = StructureSets
        self.ReportingTaxonomies = ReportingTaxonomies
        self.Processes = Processes
    def factory(*args_, **kwargs_):
        if StructureType.subclass:
            return StructureType.subclass(*args_, **kwargs_)
        else:
            return StructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrganisationSchemes(self): return self.OrganisationSchemes
    def set_OrganisationSchemes(self, OrganisationSchemes): self.OrganisationSchemes = OrganisationSchemes
    def get_Dataflows(self): return self.Dataflows
    def set_Dataflows(self, Dataflows): self.Dataflows = Dataflows
    def get_Metadataflows(self): return self.Metadataflows
    def set_Metadataflows(self, Metadataflows): self.Metadataflows = Metadataflows
    def get_CategorySchemes(self): return self.CategorySchemes
    def set_CategorySchemes(self, CategorySchemes): self.CategorySchemes = CategorySchemes
    def get_CodeLists(self): return self.CodeLists
    def set_CodeLists(self, CodeLists): self.CodeLists = CodeLists
    def get_HierarchicalCodelists(self): return self.HierarchicalCodelists
    def set_HierarchicalCodelists(self, HierarchicalCodelists): self.HierarchicalCodelists = HierarchicalCodelists
    def get_Concepts(self): return self.Concepts
    def set_Concepts(self, Concepts): self.Concepts = Concepts
    def get_MetadataStructureDefinitions(self): return self.MetadataStructureDefinitions
    def set_MetadataStructureDefinitions(self, MetadataStructureDefinitions): self.MetadataStructureDefinitions = MetadataStructureDefinitions
    def get_KeyFamilies(self): return self.KeyFamilies
    def set_KeyFamilies(self, KeyFamilies): self.KeyFamilies = KeyFamilies
    def get_StructureSets(self): return self.StructureSets
    def set_StructureSets(self, StructureSets): self.StructureSets = StructureSets
    def get_ReportingTaxonomies(self): return self.ReportingTaxonomies
    def set_ReportingTaxonomies(self, ReportingTaxonomies): self.ReportingTaxonomies = ReportingTaxonomies
    def get_Processes(self): return self.Processes
    def set_Processes(self, Processes): self.Processes = Processes
    def hasContent_(self):
        if (
            self.OrganisationSchemes is not None or
            self.Dataflows is not None or
            self.Metadataflows is not None or
            self.CategorySchemes is not None or
            self.CodeLists is not None or
            self.HierarchicalCodelists is not None or
            self.Concepts is not None or
            self.MetadataStructureDefinitions is not None or
            self.KeyFamilies is not None or
            self.StructureSets is not None or
            self.ReportingTaxonomies is not None or
            self.Processes is not None or
            super(StructureType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:structure="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/structure" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureType'):
        super(StructureType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='StructureType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureType', fromsubclass_=False, pretty_print=True):
        super(StructureType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganisationSchemes is not None:
            self.OrganisationSchemes.export(outfile, level, namespace_, name_='OrganisationSchemes', pretty_print=pretty_print)
        if self.Dataflows is not None:
            self.Dataflows.export(outfile, level, namespace_, name_='Dataflows', pretty_print=pretty_print)
        if self.Metadataflows is not None:
            self.Metadataflows.export(outfile, level, namespace_, name_='Metadataflows', pretty_print=pretty_print)
        if self.CategorySchemes is not None:
            self.CategorySchemes.export(outfile, level, namespace_, name_='CategorySchemes', pretty_print=pretty_print)
        if self.CodeLists is not None:
            self.CodeLists.export(outfile, level, namespace_, name_='CodeLists', pretty_print=pretty_print)
        if self.HierarchicalCodelists is not None:
            self.HierarchicalCodelists.export(outfile, level, namespace_, name_='HierarchicalCodelists', pretty_print=pretty_print)
        if self.Concepts is not None:
            self.Concepts.export(outfile, level, namespace_, name_='Concepts', pretty_print=pretty_print)
        if self.MetadataStructureDefinitions is not None:
            self.MetadataStructureDefinitions.export(outfile, level, namespace_, name_='MetadataStructureDefinitions', pretty_print=pretty_print)
        if self.KeyFamilies is not None:
            self.KeyFamilies.export(outfile, level, namespace_, name_='KeyFamilies', pretty_print=pretty_print)
        if self.StructureSets is not None:
            self.StructureSets.export(outfile, level, namespace_, name_='StructureSets', pretty_print=pretty_print)
        if self.ReportingTaxonomies is not None:
            self.ReportingTaxonomies.export(outfile, level, namespace_, name_='ReportingTaxonomies', pretty_print=pretty_print)
        if self.Processes is not None:
            self.Processes.export(outfile, level, namespace_, name_='Processes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StructureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(StructureType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(StructureType, self).exportLiteralChildren(outfile, level, name_)
        if self.OrganisationSchemes is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemes=model_.OrganisationSchemesType(\n')
            self.OrganisationSchemes.exportLiteral(outfile, level, name_='OrganisationSchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dataflows is not None:
            showIndent(outfile, level)
            outfile.write('Dataflows=model_.DataflowsType(\n')
            self.Dataflows.exportLiteral(outfile, level, name_='Dataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Metadataflows is not None:
            showIndent(outfile, level)
            outfile.write('Metadataflows=model_.MetadataflowsType(\n')
            self.Metadataflows.exportLiteral(outfile, level, name_='Metadataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CategorySchemes is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemes=model_.CategorySchemesType(\n')
            self.CategorySchemes.exportLiteral(outfile, level, name_='CategorySchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CodeLists is not None:
            showIndent(outfile, level)
            outfile.write('CodeLists=model_.CodeListsType(\n')
            self.CodeLists.exportLiteral(outfile, level, name_='CodeLists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HierarchicalCodelists is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelists=model_.HierarchicalCodelistsType(\n')
            self.HierarchicalCodelists.exportLiteral(outfile, level, name_='HierarchicalCodelists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concepts is not None:
            showIndent(outfile, level)
            outfile.write('Concepts=model_.ConceptsType(\n')
            self.Concepts.exportLiteral(outfile, level, name_='Concepts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataStructureDefinitions is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureDefinitions=model_.MetadataStructureDefinitionsType(\n')
            self.MetadataStructureDefinitions.exportLiteral(outfile, level, name_='MetadataStructureDefinitions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KeyFamilies is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilies=model_.KeyFamiliesType(\n')
            self.KeyFamilies.exportLiteral(outfile, level, name_='KeyFamilies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureSets is not None:
            showIndent(outfile, level)
            outfile.write('StructureSets=model_.StructureSetsType(\n')
            self.StructureSets.exportLiteral(outfile, level, name_='StructureSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReportingTaxonomies is not None:
            showIndent(outfile, level)
            outfile.write('ReportingTaxonomies=model_.ReportingTaxonomiesType(\n')
            self.ReportingTaxonomies.exportLiteral(outfile, level, name_='ReportingTaxonomies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Processes is not None:
            showIndent(outfile, level)
            outfile.write('Processes=model_.ProcessesType(\n')
            self.Processes.exportLiteral(outfile, level, name_='Processes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(StructureType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrganisationSchemes':
            obj_ = OrganisationSchemesType.factory()
            obj_.build(child_)
            self.OrganisationSchemes = obj_
            obj_.original_tagname_ = 'OrganisationSchemes'
        elif nodeName_ == 'Dataflows':
            obj_ = DataflowsType.factory()
            obj_.build(child_)
            self.Dataflows = obj_
            obj_.original_tagname_ = 'Dataflows'
        elif nodeName_ == 'Metadataflows':
            obj_ = MetadataflowsType.factory()
            obj_.build(child_)
            self.Metadataflows = obj_
            obj_.original_tagname_ = 'Metadataflows'
        elif nodeName_ == 'CategorySchemes':
            obj_ = CategorySchemesType.factory()
            obj_.build(child_)
            self.CategorySchemes = obj_
            obj_.original_tagname_ = 'CategorySchemes'
        elif nodeName_ == 'CodeLists':
            obj_ = CodeListsType.factory()
            obj_.build(child_)
            self.CodeLists = obj_
            obj_.original_tagname_ = 'CodeLists'
        elif nodeName_ == 'HierarchicalCodelists':
            obj_ = HierarchicalCodelistsType.factory()
            obj_.build(child_)
            self.HierarchicalCodelists = obj_
            obj_.original_tagname_ = 'HierarchicalCodelists'
        elif nodeName_ == 'Concepts':
            obj_ = ConceptsType.factory()
            obj_.build(child_)
            self.Concepts = obj_
            obj_.original_tagname_ = 'Concepts'
        elif nodeName_ == 'MetadataStructureDefinitions':
            obj_ = MetadataStructureDefinitionsType.factory()
            obj_.build(child_)
            self.MetadataStructureDefinitions = obj_
            obj_.original_tagname_ = 'MetadataStructureDefinitions'
        elif nodeName_ == 'KeyFamilies':
            obj_ = KeyFamiliesType.factory()
            obj_.build(child_)
            self.KeyFamilies = obj_
            obj_.original_tagname_ = 'KeyFamilies'
        elif nodeName_ == 'StructureSets':
            obj_ = StructureSetsType.factory()
            obj_.build(child_)
            self.StructureSets = obj_
            obj_.original_tagname_ = 'StructureSets'
        elif nodeName_ == 'ReportingTaxonomies':
            obj_ = ReportingTaxonomiesType.factory()
            obj_.build(child_)
            self.ReportingTaxonomies = obj_
            obj_.original_tagname_ = 'ReportingTaxonomies'
        elif nodeName_ == 'Processes':
            obj_ = ProcessesType.factory()
            obj_.build(child_)
            self.Processes = obj_
            obj_.original_tagname_ = 'Processes'
        super(StructureType, self).buildChildren(child_, node, nodeName_, True)
# end class StructureType


class GenericDataType(MessageType):
    """GenericDataType defines the contents of a GenericData message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, DataSet=None):
        self.original_tagname_ = None
        super(GenericDataType, self).__init__(Header, )
        self.DataSet = DataSet
    def factory(*args_, **kwargs_):
        if GenericDataType.subclass:
            return GenericDataType.subclass(*args_, **kwargs_)
        else:
            return GenericDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def hasContent_(self):
        if (
            self.DataSet is not None or
            super(GenericDataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='GenericDataType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:generic="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/generic" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='GenericDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='GenericDataType'):
        super(GenericDataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericDataType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='GenericDataType', fromsubclass_=False, pretty_print=True):
        super(GenericDataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataSet is not None:
            self.DataSet.export(outfile, level, namespace_, name_='DataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GenericDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericDataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericDataType, self).exportLiteralChildren(outfile, level, name_)
        if self.DataSetType is not None:
            showIndent(outfile, level)
            outfile.write('DataSetType=model_.DataSetType(\n')
            self.DataSetType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <DataSet> element')
            self.DataSet = obj_
            obj_.original_tagname_ = 'DataSet'
        super(GenericDataType, self).buildChildren(child_, node, nodeName_, True)
# end class GenericDataType


class UtilityDataType(MessageType):
    """UtilityDataType defines the contents of a UtilityData message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, DataSet=None):
        self.original_tagname_ = None
        super(UtilityDataType, self).__init__(Header, )
        self.DataSet = DataSet
    def factory(*args_, **kwargs_):
        if UtilityDataType.subclass:
            return UtilityDataType.subclass(*args_, **kwargs_)
        else:
            return UtilityDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def hasContent_(self):
        if (
            self.DataSet is not None or
            super(UtilityDataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='UtilityDataType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:utility="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/utility" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='UtilityDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='UtilityDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='UtilityDataType'):
        super(UtilityDataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='UtilityDataType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='UtilityDataType', fromsubclass_=False, pretty_print=True):
        super(UtilityDataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataSet is not None:
            self.DataSet.export(outfile, level, namespace_='utility:', name_='DataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='UtilityDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(UtilityDataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(UtilityDataType, self).exportLiteralChildren(outfile, level, name_)
        if self.DataSet is not None:
            showIndent(outfile, level)
            outfile.write('DataSet=model_.DataSet(\n')
            self.DataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(UtilityDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet = obj_
            obj_.original_tagname_ = 'DataSet'
        super(UtilityDataType, self).buildChildren(child_, node, nodeName_, True)
# end class UtilityDataType


class CompactDataType(MessageType):
    """CompactDataType defines the contents of a CompactData message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, DataSet=None):
        self.original_tagname_ = None
        super(CompactDataType, self).__init__(Header, )
        self.DataSet = DataSet
    def factory(*args_, **kwargs_):
        if CompactDataType.subclass:
            return CompactDataType.subclass(*args_, **kwargs_)
        else:
            return CompactDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def hasContent_(self):
        if (
            self.DataSet is not None or
            super(CompactDataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CompactDataType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:compact="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/compact" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CompactDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CompactDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CompactDataType'):
        super(CompactDataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CompactDataType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='CompactDataType', fromsubclass_=False, pretty_print=True):
        super(CompactDataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataSet is not None:
            self.DataSet.export(outfile, level, namespace_='compact:', name_='DataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CompactDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CompactDataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CompactDataType, self).exportLiteralChildren(outfile, level, name_)
        if self.DataSet is not None:
            showIndent(outfile, level)
            outfile.write('DataSet=model_.DataSet(\n')
            self.DataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CompactDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet = obj_
            obj_.original_tagname_ = 'DataSet'
        super(CompactDataType, self).buildChildren(child_, node, nodeName_, True)
# end class CompactDataType


class CrossSectionalDataType(MessageType):
    """CrossSectionalDataType defines the contents of a CrossSectionalData
    message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, DataSet=None):
        self.original_tagname_ = None
        super(CrossSectionalDataType, self).__init__(Header, )
        self.DataSet = DataSet
    def factory(*args_, **kwargs_):
        if CrossSectionalDataType.subclass:
            return CrossSectionalDataType.subclass(*args_, **kwargs_)
        else:
            return CrossSectionalDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def hasContent_(self):
        if (
            self.DataSet is not None or
            super(CrossSectionalDataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CrossSectionalDataType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:cross="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/cross" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CrossSectionalDataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CrossSectionalDataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CrossSectionalDataType'):
        super(CrossSectionalDataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='CrossSectionalDataType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='CrossSectionalDataType', fromsubclass_=False, pretty_print=True):
        super(CrossSectionalDataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataSet is not None:
            self.DataSet.export(outfile, level, namespace_='cross:', name_='DataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CrossSectionalDataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(CrossSectionalDataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(CrossSectionalDataType, self).exportLiteralChildren(outfile, level, name_)
        if self.DataSet is not None:
            showIndent(outfile, level)
            outfile.write('DataSet=model_.DataSet(\n')
            self.DataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(CrossSectionalDataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet = obj_
            obj_.original_tagname_ = 'DataSet'
        super(CrossSectionalDataType, self).buildChildren(child_, node, nodeName_, True)
# end class CrossSectionalDataType


class GenericMetadataType(MessageType):
    """GenericMetadataType defines the contents of a Generic Metadata
    message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, MetadataSet=None):
        self.original_tagname_ = None
        super(GenericMetadataType, self).__init__(Header, )
        self.MetadataSet = MetadataSet
    def factory(*args_, **kwargs_):
        if GenericMetadataType.subclass:
            return GenericMetadataType.subclass(*args_, **kwargs_)
        else:
            return GenericMetadataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def hasContent_(self):
        if (
            self.MetadataSet is not None or
            super(GenericMetadataType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='GenericMetadataType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:genericmetadata="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/genericmetadata" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMetadataType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='GenericMetadataType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='GenericMetadataType'):
        super(GenericMetadataType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GenericMetadataType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='GenericMetadataType', fromsubclass_=False, pretty_print=True):
        super(GenericMetadataType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MetadataSet is not None:
            self.MetadataSet.export(outfile, level, namespace_='genericmetadata:', name_='MetadataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GenericMetadataType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GenericMetadataType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GenericMetadataType, self).exportLiteralChildren(outfile, level, name_)
        if self.MetadataSet is not None:
            showIndent(outfile, level)
            outfile.write('MetadataSet=model_.MetadataSet(\n')
            self.MetadataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(GenericMetadataType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataSet':
            obj_ = MetadataSetType.factory()
            obj_.build(child_)
            self.MetadataSet = obj_
            obj_.original_tagname_ = 'MetadataSet'
        super(GenericMetadataType, self).buildChildren(child_, node, nodeName_, True)
# end class GenericMetadataType


class MetadataReportType(MessageType):
    """MetadataReportType defines the contents of a metadata structure
    definition-specific Metadata Report message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, MetadataSet=None):
        self.original_tagname_ = None
        super(MetadataReportType, self).__init__(Header, )
        self.MetadataSet = MetadataSet
    def factory(*args_, **kwargs_):
        if MetadataReportType.subclass:
            return MetadataReportType.subclass(*args_, **kwargs_)
        else:
            return MetadataReportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def hasContent_(self):
        if (
            self.MetadataSet is not None or
            super(MetadataReportType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataReportType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:metadatareport="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/metadatareport" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataReportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataReportType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataReportType'):
        super(MetadataReportType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataReportType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataReportType', fromsubclass_=False, pretty_print=True):
        super(MetadataReportType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MetadataSet is not None:
            self.MetadataSet.export(outfile, level, namespace_='metadatareport:', name_='MetadataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataReportType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(MetadataReportType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MetadataReportType, self).exportLiteralChildren(outfile, level, name_)
        if self.MetadataSet is not None:
            showIndent(outfile, level)
            outfile.write('MetadataSet=model_.MetadataSet(\n')
            self.MetadataSet.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(MetadataReportType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataSet':
            obj_ = MetadataSetType.factory()
            obj_.build(child_)
            self.MetadataSet = obj_
            obj_.original_tagname_ = 'MetadataSet'
        super(MetadataReportType, self).buildChildren(child_, node, nodeName_, True)
# end class MetadataReportType


class QueryMessageType(MessageType):
    """QueryMessageType defines the contents of a QueryMessage."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, Query=None):
        self.original_tagname_ = None
        super(QueryMessageType, self).__init__(Header, )
        self.Query = Query
    def factory(*args_, **kwargs_):
        if QueryMessageType.subclass:
            return QueryMessageType.subclass(*args_, **kwargs_)
        else:
            return QueryMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Query(self): return self.Query
    def set_Query(self, Query): self.Query = Query
    def hasContent_(self):
        if (
            self.Query is not None or
            super(QueryMessageType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryMessageType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:query="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/query" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryMessageType'):
        super(QueryMessageType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QueryMessageType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryMessageType', fromsubclass_=False, pretty_print=True):
        super(QueryMessageType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Query is not None:
            self.Query.export(outfile, level, namespace_, name_='Query', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryMessageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(QueryMessageType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QueryMessageType, self).exportLiteralChildren(outfile, level, name_)
        if self.Query is not None:
            showIndent(outfile, level)
            outfile.write('Query=model_.QueryType(\n')
            self.Query.exportLiteral(outfile, level, name_='Query')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(QueryMessageType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Query':
            obj_ = QueryType.factory()
            obj_.build(child_)
            self.Query = obj_
            obj_.original_tagname_ = 'Query'
        super(QueryMessageType, self).buildChildren(child_, node, nodeName_, True)
# end class QueryMessageType


class RegistryInterfaceType(MessageType):
    """This is a type which describes a structure for holding all of the
    various dedicated registry interface message types."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, SubmitSubscriptionRequest=None, SubmitSubscriptionResponse=None, NotifyRegistryEvent=None, SubmitRegistrationRequest=None, SubmitRegistrationResponse=None, QueryRegistrationRequest=None, QueryRegistrationResponse=None, SubmitStructureRequest=None, SubmitStructureResponse=None, QueryStructureRequest=None, QueryStructureResponse=None, SubmitProvisioningRequest=None, SubmitProvisioningResponse=None, QueryProvisioningRequest=None, QueryProvisioningResponse=None):
        self.original_tagname_ = None
        super(RegistryInterfaceType, self).__init__(Header, )
        self.SubmitSubscriptionRequest = SubmitSubscriptionRequest
        self.SubmitSubscriptionResponse = SubmitSubscriptionResponse
        self.NotifyRegistryEvent = NotifyRegistryEvent
        self.SubmitRegistrationRequest = SubmitRegistrationRequest
        self.SubmitRegistrationResponse = SubmitRegistrationResponse
        self.QueryRegistrationRequest = QueryRegistrationRequest
        self.QueryRegistrationResponse = QueryRegistrationResponse
        self.SubmitStructureRequest = SubmitStructureRequest
        self.SubmitStructureResponse = SubmitStructureResponse
        self.QueryStructureRequest = QueryStructureRequest
        self.QueryStructureResponse = QueryStructureResponse
        self.SubmitProvisioningRequest = SubmitProvisioningRequest
        self.SubmitProvisioningResponse = SubmitProvisioningResponse
        self.QueryProvisioningRequest = QueryProvisioningRequest
        self.QueryProvisioningResponse = QueryProvisioningResponse
    def factory(*args_, **kwargs_):
        if RegistryInterfaceType.subclass:
            return RegistryInterfaceType.subclass(*args_, **kwargs_)
        else:
            return RegistryInterfaceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubmitSubscriptionRequest(self): return self.SubmitSubscriptionRequest
    def set_SubmitSubscriptionRequest(self, SubmitSubscriptionRequest): self.SubmitSubscriptionRequest = SubmitSubscriptionRequest
    def get_SubmitSubscriptionResponse(self): return self.SubmitSubscriptionResponse
    def set_SubmitSubscriptionResponse(self, SubmitSubscriptionResponse): self.SubmitSubscriptionResponse = SubmitSubscriptionResponse
    def get_NotifyRegistryEvent(self): return self.NotifyRegistryEvent
    def set_NotifyRegistryEvent(self, NotifyRegistryEvent): self.NotifyRegistryEvent = NotifyRegistryEvent
    def get_SubmitRegistrationRequest(self): return self.SubmitRegistrationRequest
    def set_SubmitRegistrationRequest(self, SubmitRegistrationRequest): self.SubmitRegistrationRequest = SubmitRegistrationRequest
    def get_SubmitRegistrationResponse(self): return self.SubmitRegistrationResponse
    def set_SubmitRegistrationResponse(self, SubmitRegistrationResponse): self.SubmitRegistrationResponse = SubmitRegistrationResponse
    def get_QueryRegistrationRequest(self): return self.QueryRegistrationRequest
    def set_QueryRegistrationRequest(self, QueryRegistrationRequest): self.QueryRegistrationRequest = QueryRegistrationRequest
    def get_QueryRegistrationResponse(self): return self.QueryRegistrationResponse
    def set_QueryRegistrationResponse(self, QueryRegistrationResponse): self.QueryRegistrationResponse = QueryRegistrationResponse
    def get_SubmitStructureRequest(self): return self.SubmitStructureRequest
    def set_SubmitStructureRequest(self, SubmitStructureRequest): self.SubmitStructureRequest = SubmitStructureRequest
    def get_SubmitStructureResponse(self): return self.SubmitStructureResponse
    def set_SubmitStructureResponse(self, SubmitStructureResponse): self.SubmitStructureResponse = SubmitStructureResponse
    def get_QueryStructureRequest(self): return self.QueryStructureRequest
    def set_QueryStructureRequest(self, QueryStructureRequest): self.QueryStructureRequest = QueryStructureRequest
    def get_QueryStructureResponse(self): return self.QueryStructureResponse
    def set_QueryStructureResponse(self, QueryStructureResponse): self.QueryStructureResponse = QueryStructureResponse
    def get_SubmitProvisioningRequest(self): return self.SubmitProvisioningRequest
    def set_SubmitProvisioningRequest(self, SubmitProvisioningRequest): self.SubmitProvisioningRequest = SubmitProvisioningRequest
    def get_SubmitProvisioningResponse(self): return self.SubmitProvisioningResponse
    def set_SubmitProvisioningResponse(self, SubmitProvisioningResponse): self.SubmitProvisioningResponse = SubmitProvisioningResponse
    def get_QueryProvisioningRequest(self): return self.QueryProvisioningRequest
    def set_QueryProvisioningRequest(self, QueryProvisioningRequest): self.QueryProvisioningRequest = QueryProvisioningRequest
    def get_QueryProvisioningResponse(self): return self.QueryProvisioningResponse
    def set_QueryProvisioningResponse(self, QueryProvisioningResponse): self.QueryProvisioningResponse = QueryProvisioningResponse
    def hasContent_(self):
        if (
            self.SubmitSubscriptionRequest is not None or
            self.SubmitSubscriptionResponse is not None or
            self.NotifyRegistryEvent is not None or
            self.SubmitRegistrationRequest is not None or
            self.SubmitRegistrationResponse is not None or
            self.QueryRegistrationRequest is not None or
            self.QueryRegistrationResponse is not None or
            self.SubmitStructureRequest is not None or
            self.SubmitStructureResponse is not None or
            self.QueryStructureRequest is not None or
            self.QueryStructureResponse is not None or
            self.SubmitProvisioningRequest is not None or
            self.SubmitProvisioningResponse is not None or
            self.QueryProvisioningRequest is not None or
            self.QueryProvisioningResponse is not None or
            super(RegistryInterfaceType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RegistryInterfaceType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:registry="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/registry" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistryInterfaceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RegistryInterfaceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RegistryInterfaceType'):
        super(RegistryInterfaceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RegistryInterfaceType')
    def exportChildren(self, outfile, level, namespace_='message:', name_='RegistryInterfaceType', fromsubclass_=False, pretty_print=True):
        super(RegistryInterfaceType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubmitSubscriptionRequest is not None:
            self.SubmitSubscriptionRequest.export(outfile, level, namespace_, name_='SubmitSubscriptionRequest', pretty_print=pretty_print)
        if self.SubmitSubscriptionResponse is not None:
            self.SubmitSubscriptionResponse.export(outfile, level, namespace_, name_='SubmitSubscriptionResponse', pretty_print=pretty_print)
        if self.NotifyRegistryEvent is not None:
            self.NotifyRegistryEvent.export(outfile, level, namespace_, name_='NotifyRegistryEvent', pretty_print=pretty_print)
        if self.SubmitRegistrationRequest is not None:
            self.SubmitRegistrationRequest.export(outfile, level, namespace_, name_='SubmitRegistrationRequest', pretty_print=pretty_print)
        if self.SubmitRegistrationResponse is not None:
            self.SubmitRegistrationResponse.export(outfile, level, namespace_, name_='SubmitRegistrationResponse', pretty_print=pretty_print)
        if self.QueryRegistrationRequest is not None:
            self.QueryRegistrationRequest.export(outfile, level, namespace_, name_='QueryRegistrationRequest', pretty_print=pretty_print)
        if self.QueryRegistrationResponse is not None:
            self.QueryRegistrationResponse.export(outfile, level, namespace_, name_='QueryRegistrationResponse', pretty_print=pretty_print)
        if self.SubmitStructureRequest is not None:
            self.SubmitStructureRequest.export(outfile, level, namespace_, name_='SubmitStructureRequest', pretty_print=pretty_print)
        if self.SubmitStructureResponse is not None:
            self.SubmitStructureResponse.export(outfile, level, namespace_, name_='SubmitStructureResponse', pretty_print=pretty_print)
        if self.QueryStructureRequest is not None:
            self.QueryStructureRequest.export(outfile, level, namespace_, name_='QueryStructureRequest', pretty_print=pretty_print)
        if self.QueryStructureResponse is not None:
            self.QueryStructureResponse.export(outfile, level, namespace_, name_='QueryStructureResponse', pretty_print=pretty_print)
        if self.SubmitProvisioningRequest is not None:
            self.SubmitProvisioningRequest.export(outfile, level, namespace_, name_='SubmitProvisioningRequest', pretty_print=pretty_print)
        if self.SubmitProvisioningResponse is not None:
            self.SubmitProvisioningResponse.export(outfile, level, namespace_, name_='SubmitProvisioningResponse', pretty_print=pretty_print)
        if self.QueryProvisioningRequest is not None:
            self.QueryProvisioningRequest.export(outfile, level, namespace_, name_='QueryProvisioningRequest', pretty_print=pretty_print)
        if self.QueryProvisioningResponse is not None:
            self.QueryProvisioningResponse.export(outfile, level, namespace_, name_='QueryProvisioningResponse', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegistryInterfaceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(RegistryInterfaceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RegistryInterfaceType, self).exportLiteralChildren(outfile, level, name_)
        if self.SubmitSubscriptionRequest is not None:
            showIndent(outfile, level)
            outfile.write('SubmitSubscriptionRequest=model_.SubmitSubscriptionRequestType(\n')
            self.SubmitSubscriptionRequest.exportLiteral(outfile, level, name_='SubmitSubscriptionRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitSubscriptionResponse is not None:
            showIndent(outfile, level)
            outfile.write('SubmitSubscriptionResponse=model_.SubmitSubscriptionResponseType(\n')
            self.SubmitSubscriptionResponse.exportLiteral(outfile, level, name_='SubmitSubscriptionResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.NotifyRegistryEvent is not None:
            showIndent(outfile, level)
            outfile.write('NotifyRegistryEvent=model_.NotifyRegistryEventType(\n')
            self.NotifyRegistryEvent.exportLiteral(outfile, level, name_='NotifyRegistryEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitRegistrationRequest is not None:
            showIndent(outfile, level)
            outfile.write('SubmitRegistrationRequest=model_.SubmitRegistrationRequestType(\n')
            self.SubmitRegistrationRequest.exportLiteral(outfile, level, name_='SubmitRegistrationRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitRegistrationResponse is not None:
            showIndent(outfile, level)
            outfile.write('SubmitRegistrationResponse=model_.SubmitRegistrationResponseType(\n')
            self.SubmitRegistrationResponse.exportLiteral(outfile, level, name_='SubmitRegistrationResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryRegistrationRequest is not None:
            showIndent(outfile, level)
            outfile.write('QueryRegistrationRequest=model_.QueryRegistrationRequestType(\n')
            self.QueryRegistrationRequest.exportLiteral(outfile, level, name_='QueryRegistrationRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryRegistrationResponse is not None:
            showIndent(outfile, level)
            outfile.write('QueryRegistrationResponse=model_.QueryRegistrationResponseType(\n')
            self.QueryRegistrationResponse.exportLiteral(outfile, level, name_='QueryRegistrationResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitStructureRequest is not None:
            showIndent(outfile, level)
            outfile.write('SubmitStructureRequest=model_.SubmitStructureRequestType(\n')
            self.SubmitStructureRequest.exportLiteral(outfile, level, name_='SubmitStructureRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitStructureResponse is not None:
            showIndent(outfile, level)
            outfile.write('SubmitStructureResponse=model_.SubmitStructureResponseType(\n')
            self.SubmitStructureResponse.exportLiteral(outfile, level, name_='SubmitStructureResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryStructureRequest is not None:
            showIndent(outfile, level)
            outfile.write('QueryStructureRequest=model_.QueryStructureRequestType(\n')
            self.QueryStructureRequest.exportLiteral(outfile, level, name_='QueryStructureRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryStructureResponse is not None:
            showIndent(outfile, level)
            outfile.write('QueryStructureResponse=model_.QueryStructureResponseType(\n')
            self.QueryStructureResponse.exportLiteral(outfile, level, name_='QueryStructureResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitProvisioningRequest is not None:
            showIndent(outfile, level)
            outfile.write('SubmitProvisioningRequest=model_.SubmitProvisioningRequestType(\n')
            self.SubmitProvisioningRequest.exportLiteral(outfile, level, name_='SubmitProvisioningRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SubmitProvisioningResponse is not None:
            showIndent(outfile, level)
            outfile.write('SubmitProvisioningResponse=model_.SubmitProvisioningResponseType(\n')
            self.SubmitProvisioningResponse.exportLiteral(outfile, level, name_='SubmitProvisioningResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryProvisioningRequest is not None:
            showIndent(outfile, level)
            outfile.write('QueryProvisioningRequest=model_.QueryProvisioningRequestType(\n')
            self.QueryProvisioningRequest.exportLiteral(outfile, level, name_='QueryProvisioningRequest')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.QueryProvisioningResponse is not None:
            showIndent(outfile, level)
            outfile.write('QueryProvisioningResponse=model_.QueryProvisioningResponseType(\n')
            self.QueryProvisioningResponse.exportLiteral(outfile, level, name_='QueryProvisioningResponse')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(RegistryInterfaceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubmitSubscriptionRequest':
            obj_ = SubmitSubscriptionRequestType.factory()
            obj_.build(child_)
            self.SubmitSubscriptionRequest = obj_
            obj_.original_tagname_ = 'SubmitSubscriptionRequest'
        elif nodeName_ == 'SubmitSubscriptionResponse':
            obj_ = SubmitSubscriptionResponseType.factory()
            obj_.build(child_)
            self.SubmitSubscriptionResponse = obj_
            obj_.original_tagname_ = 'SubmitSubscriptionResponse'
        elif nodeName_ == 'NotifyRegistryEvent':
            obj_ = NotifyRegistryEventType.factory()
            obj_.build(child_)
            self.NotifyRegistryEvent = obj_
            obj_.original_tagname_ = 'NotifyRegistryEvent'
        elif nodeName_ == 'SubmitRegistrationRequest':
            obj_ = SubmitRegistrationRequestType.factory()
            obj_.build(child_)
            self.SubmitRegistrationRequest = obj_
            obj_.original_tagname_ = 'SubmitRegistrationRequest'
        elif nodeName_ == 'SubmitRegistrationResponse':
            obj_ = SubmitRegistrationResponseType.factory()
            obj_.build(child_)
            self.SubmitRegistrationResponse = obj_
            obj_.original_tagname_ = 'SubmitRegistrationResponse'
        elif nodeName_ == 'QueryRegistrationRequest':
            obj_ = QueryRegistrationRequestType.factory()
            obj_.build(child_)
            self.QueryRegistrationRequest = obj_
            obj_.original_tagname_ = 'QueryRegistrationRequest'
        elif nodeName_ == 'QueryRegistrationResponse':
            obj_ = QueryRegistrationResponseType.factory()
            obj_.build(child_)
            self.QueryRegistrationResponse = obj_
            obj_.original_tagname_ = 'QueryRegistrationResponse'
        elif nodeName_ == 'SubmitStructureRequest':
            obj_ = SubmitStructureRequestType.factory()
            obj_.build(child_)
            self.SubmitStructureRequest = obj_
            obj_.original_tagname_ = 'SubmitStructureRequest'
        elif nodeName_ == 'SubmitStructureResponse':
            obj_ = SubmitStructureResponseType.factory()
            obj_.build(child_)
            self.SubmitStructureResponse = obj_
            obj_.original_tagname_ = 'SubmitStructureResponse'
        elif nodeName_ == 'QueryStructureRequest':
            obj_ = QueryStructureRequestType.factory()
            obj_.build(child_)
            self.QueryStructureRequest = obj_
            obj_.original_tagname_ = 'QueryStructureRequest'
        elif nodeName_ == 'QueryStructureResponse':
            obj_ = QueryStructureResponseType.factory()
            obj_.build(child_)
            self.QueryStructureResponse = obj_
            obj_.original_tagname_ = 'QueryStructureResponse'
        elif nodeName_ == 'SubmitProvisioningRequest':
            obj_ = SubmitProvisioningRequestType.factory()
            obj_.build(child_)
            self.SubmitProvisioningRequest = obj_
            obj_.original_tagname_ = 'SubmitProvisioningRequest'
        elif nodeName_ == 'SubmitProvisioningResponse':
            obj_ = SubmitProvisioningResponseType.factory()
            obj_.build(child_)
            self.SubmitProvisioningResponse = obj_
            obj_.original_tagname_ = 'SubmitProvisioningResponse'
        elif nodeName_ == 'QueryProvisioningRequest':
            obj_ = QueryProvisioningRequestType.factory()
            obj_.build(child_)
            self.QueryProvisioningRequest = obj_
            obj_.original_tagname_ = 'QueryProvisioningRequest'
        elif nodeName_ == 'QueryProvisioningResponse':
            obj_ = QueryProvisioningResponseType.factory()
            obj_.build(child_)
            self.QueryProvisioningResponse = obj_
            obj_.original_tagname_ = 'QueryProvisioningResponse'
        super(RegistryInterfaceType, self).buildChildren(child_, node, nodeName_, True)
# end class RegistryInterfaceType


class MessageGroupType(MessageType):
    """MessageGroupType defines the contents of a MessageGroup message."""
    subclass = None
    superclass = MessageType
    def __init__(self, Header=None, id=None, DataSet=None, MetadataSet=None):
        self.original_tagname_ = None
        super(MessageGroupType, self).__init__(Header, )
        self.id = _cast(None, id)
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if MetadataSet is None:
            self.MetadataSet = []
        else:
            self.MetadataSet = MetadataSet
        if MetadataSet is None:
            self.MetadataSet = []
        else:
            self.MetadataSet = MetadataSet
    def factory(*args_, **kwargs_):
        if MessageGroupType.subclass:
            return MessageGroupType.subclass(*args_, **kwargs_)
        else:
            return MessageGroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def add_MetadataSet(self, value): self.MetadataSet.append(value)
    def insert_MetadataSet_at(self, index, value): self.MetadataSet.insert(index, value)
    def replace_MetadataSet_at(self, index, value): self.MetadataSet[index] = value
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def add_MetadataSet(self, value): self.MetadataSet.append(value)
    def insert_MetadataSet_at(self, index, value): self.MetadataSet.insert(index, value)
    def replace_MetadataSet_at(self, index, value): self.MetadataSet[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.DataSet or
            self.DataSet or
            self.DataSet or
            self.DataSet or
            self.MetadataSet or
            self.MetadataSet or
            super(MessageGroupType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MessageGroupType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:generic="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/generic"  xmlns:utility="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/utility"  xmlns:compact="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/compact"  xmlns:cross="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/cross"  xmlns:genericmetadata="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/genericmetadata"  xmlns:metadatareport="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/metadatareport" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MessageGroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MessageGroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MessageGroupType'):
        super(MessageGroupType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MessageGroupType')
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MessageGroupType', fromsubclass_=False, pretty_print=True):
        super(MessageGroupType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_='generic:', name_='DataSet', pretty_print=pretty_print)
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_='utility:', name_='DataSet', pretty_print=pretty_print)
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_='compact:', name_='DataSet', pretty_print=pretty_print)
        for DataSet_ in self.DataSet:
            DataSet_.export(outfile, level, namespace_='cross:', name_='DataSet', pretty_print=pretty_print)
        for MetadataSet_ in self.MetadataSet:
            MetadataSet_.export(outfile, level, namespace_='genericmetadata:', name_='MetadataSet', pretty_print=pretty_print)
        for MetadataSet_ in self.MetadataSet:
            MetadataSet_.export(outfile, level, namespace_='metadatareport:', name_='MetadataSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MessageGroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
        super(MessageGroupType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MessageGroupType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSet(\n')
            DataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSet(\n')
            DataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSet(\n')
            DataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('model_.DataSet(\n')
            DataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataSet=[\n')
        level += 1
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level)
            outfile.write('model_.MetadataSet(\n')
            MetadataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataSet=[\n')
        level += 1
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level)
            outfile.write('model_.MetadataSet(\n')
            MetadataSet_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        super(MessageGroupType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'DataSet':
            obj_ = DataSetType.factory()
            obj_.build(child_)
            self.DataSet.append(obj_)
            obj_.original_tagname_ = 'DataSet'
        elif nodeName_ == 'MetadataSet':
            obj_ = MetadataSetType.factory()
            obj_.build(child_)
            self.MetadataSet.append(obj_)
            obj_.original_tagname_ = 'MetadataSet'
        elif nodeName_ == 'MetadataSet':
            obj_ = MetadataSetType.factory()
            obj_.build(child_)
            self.MetadataSet.append(obj_)
            obj_.original_tagname_ = 'MetadataSet'
        super(MessageGroupType, self).buildChildren(child_, node, nodeName_, True)
# end class MessageGroupType


class HeaderType(GeneratedsSuper):
    """HeaderType defines the header fields used for all messages. ID
    identifies a data flow definition, which, when combined with
    time, uniquely identifies the data set. Test indicates whather
    the message is for test purposes or not. Truncated is used in
    data messages which are responding to Query messages, and is set
    to true only if the response has been truncated to meet size
    limits suggested by the defaultLimit attribute in the Query
    mesage. Name provides a name for the transmission. Prepared is
    the date prepared. Sender is information about the sender, and
    Receiver is information about the receiver. Agency provides the
    code identifier/abbreviation for the maintenance agency of a
    data set. Data set id provides an identifier for a contained
    data set. Action code provides a code for determining whether
    the enclosed message is an Update or Delete message (not to be
    used with the UtilityData message). KeyFamilyRef is used to
    reference a key family for a contained data set, using its id.
    (This information is required at the DataSet level for some
    messages, but is provided here as a convenience for those
    messages which do not require it.) KeyFamilyAgency specifies the
    agency of the key family using its coded id. Fields which refer
    to a contained data set need not be used if the message contains
    a query or structural information - these messages provide
    specific fields for holding this information. The ones here are
    not to be used as defaults. Extracted is a time-stamp from the
    system rendering the data; ReportingBegin and ReportingEnd
    provide the time period covered by the message (in the case of
    data). Source provides human-readable information about the
    source of the data."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, Test=False, Truncated=None, Name=None, Prepared=None, Sender=None, Receiver=None, KeyFamilyRef=None, KeyFamilyAgency=None, DataSetAgency=None, DataSetID=None, DataSetAction=None, Extracted=None, ReportingBegin=None, ReportingEnd=None, Source=None):
        self.original_tagname_ = None
        self.ID = ID
        self.Test = Test
        self.Truncated = Truncated
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.Prepared = Prepared
        if Sender is None:
            self.Sender = []
        else:
            self.Sender = Sender
        if Receiver is None:
            self.Receiver = []
        else:
            self.Receiver = Receiver
        self.KeyFamilyRef = KeyFamilyRef
        self.KeyFamilyAgency = KeyFamilyAgency
        self.DataSetAgency = DataSetAgency
        self.DataSetID = DataSetID
        self.DataSetAction = DataSetAction
        if isinstance(Extracted, basestring):
            initvalue_ = datetime_.datetime.strptime(Extracted, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = Extracted
        self.Extracted = initvalue_
        self.ReportingBegin = ReportingBegin
        self.ReportingEnd = ReportingEnd
        if Source is None:
            self.Source = []
        else:
            self.Source = Source
    def factory(*args_, **kwargs_):
        if HeaderType.subclass:
            return HeaderType.subclass(*args_, **kwargs_)
        else:
            return HeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Test(self): return self.Test
    def set_Test(self, Test): self.Test = Test
    def get_Truncated(self): return self.Truncated
    def set_Truncated(self, Truncated): self.Truncated = Truncated
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Prepared(self): return self.Prepared
    def set_Prepared(self, Prepared): self.Prepared = Prepared
    def get_Sender(self): return self.Sender
    def set_Sender(self, Sender): self.Sender = Sender
    def add_Sender(self, value): self.Sender.append(value)
    def insert_Sender_at(self, index, value): self.Sender.insert(index, value)
    def replace_Sender_at(self, index, value): self.Sender[index] = value
    def get_Receiver(self): return self.Receiver
    def set_Receiver(self, Receiver): self.Receiver = Receiver
    def add_Receiver(self, value): self.Receiver.append(value)
    def insert_Receiver_at(self, index, value): self.Receiver.insert(index, value)
    def replace_Receiver_at(self, index, value): self.Receiver[index] = value
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def get_KeyFamilyAgency(self): return self.KeyFamilyAgency
    def set_KeyFamilyAgency(self, KeyFamilyAgency): self.KeyFamilyAgency = KeyFamilyAgency
    def get_DataSetAgency(self): return self.DataSetAgency
    def set_DataSetAgency(self, DataSetAgency): self.DataSetAgency = DataSetAgency
    def get_DataSetID(self): return self.DataSetID
    def set_DataSetID(self, DataSetID): self.DataSetID = DataSetID
    def get_DataSetAction(self): return self.DataSetAction
    def set_DataSetAction(self, DataSetAction): self.DataSetAction = DataSetAction
    def get_Extracted(self): return self.Extracted
    def set_Extracted(self, Extracted): self.Extracted = Extracted
    def get_ReportingBegin(self): return self.ReportingBegin
    def set_ReportingBegin(self, ReportingBegin): self.ReportingBegin = ReportingBegin
    def get_ReportingEnd(self): return self.ReportingEnd
    def set_ReportingEnd(self, ReportingEnd): self.ReportingEnd = ReportingEnd
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def add_Source(self, value): self.Source.append(value)
    def insert_Source_at(self, index, value): self.Source.insert(index, value)
    def replace_Source_at(self, index, value): self.Source[index] = value
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_HeaderTimeType(self, value):
        # Validate type HeaderTimeType, a restriction on None.
        pass
    def validate_ActionType(self, value):
        # Validate type ActionType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.ID is not None or
            self.Test is not None or
            self.Truncated is not None or
            self.Name or
            self.Prepared is not None or
            self.Sender or
            self.Receiver or
            self.KeyFamilyRef is not None or
            self.KeyFamilyAgency is not None or
            self.DataSetAgency is not None or
            self.DataSetID is not None or
            self.DataSetAction is not None or
            self.Extracted is not None or
            self.ReportingBegin is not None or
            self.ReportingEnd is not None or
            self.Source
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HeaderType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HeaderType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='HeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Test is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTest>%s</%sTest>%s' % (namespace_, self.gds_format_boolean(self.Test, input_name='Test'), namespace_, eol_))
        if self.Truncated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTruncated>%s</%sTruncated>%s' % (namespace_, self.gds_format_boolean(self.Truncated, input_name='Truncated'), namespace_, eol_))
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.Prepared is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPrepared>%s</%sPrepared>%s' % (namespace_, self.gds_format_string(quote_xml(self.Prepared).encode(ExternalEncoding), input_name='Prepared'), namespace_, eol_))
        for Sender_ in self.Sender:
            Sender_.export(outfile, level, namespace_, name_='Sender', pretty_print=pretty_print)
        for Receiver_ in self.Receiver:
            Receiver_.export(outfile, level, namespace_, name_='Receiver', pretty_print=pretty_print)
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyRef>%s</%sKeyFamilyRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamilyRef).encode(ExternalEncoding), input_name='KeyFamilyRef'), namespace_, eol_))
        if self.KeyFamilyAgency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyAgency>%s</%sKeyFamilyAgency>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamilyAgency).encode(ExternalEncoding), input_name='KeyFamilyAgency'), namespace_, eol_))
        if self.DataSetAgency is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSetAgency>%s</%sDataSetAgency>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataSetAgency).encode(ExternalEncoding), input_name='DataSetAgency'), namespace_, eol_))
        if self.DataSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSetID>%s</%sDataSetID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataSetID).encode(ExternalEncoding), input_name='DataSetID'), namespace_, eol_))
        if self.DataSetAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSetAction>%s</%sDataSetAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataSetAction).encode(ExternalEncoding), input_name='DataSetAction'), namespace_, eol_))
        if self.Extracted is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sExtracted>%s</%sExtracted>%s' % (namespace_, self.gds_format_datetime(self.Extracted, input_name='Extracted'), namespace_, eol_))
        if self.ReportingBegin is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportingBegin>%s</%sReportingBegin>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReportingBegin).encode(ExternalEncoding), input_name='ReportingBegin'), namespace_, eol_))
        if self.ReportingEnd is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportingEnd>%s</%sReportingEnd>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReportingEnd).encode(ExternalEncoding), input_name='ReportingEnd'), namespace_, eol_))
        for Source_ in self.Source:
            Source_.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Test is not None:
            showIndent(outfile, level)
            outfile.write('Test=%s,\n' % self.Test)
        if self.Truncated is not None:
            showIndent(outfile, level)
            outfile.write('Truncated=%s,\n' % self.Truncated)
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Prepared is not None:
            showIndent(outfile, level)
            outfile.write('Prepared=%s,\n' % quote_python(self.Prepared).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Sender=[\n')
        level += 1
        for Sender_ in self.Sender:
            showIndent(outfile, level)
            outfile.write('model_.PartyType(\n')
            Sender_.exportLiteral(outfile, level, name_='PartyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Receiver=[\n')
        level += 1
        for Receiver_ in self.Receiver:
            showIndent(outfile, level)
            outfile.write('model_.PartyType(\n')
            Receiver_.exportLiteral(outfile, level, name_='PartyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyRef=%s,\n' % quote_python(self.KeyFamilyRef).encode(ExternalEncoding))
        if self.KeyFamilyAgency is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyAgency=%s,\n' % quote_python(self.KeyFamilyAgency).encode(ExternalEncoding))
        if self.DataSetAgency is not None:
            showIndent(outfile, level)
            outfile.write('DataSetAgency=%s,\n' % quote_python(self.DataSetAgency).encode(ExternalEncoding))
        if self.DataSetID is not None:
            showIndent(outfile, level)
            outfile.write('DataSetID=%s,\n' % quote_python(self.DataSetID).encode(ExternalEncoding))
        if self.DataSetAction is not None:
            showIndent(outfile, level)
            outfile.write('DataSetAction=%s,\n' % quote_python(self.DataSetAction).encode(ExternalEncoding))
        if self.Extracted is not None:
            showIndent(outfile, level)
            outfile.write('Extracted=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.Extracted, input_name='Extracted'))
        if self.ReportingBegin is not None:
            showIndent(outfile, level)
            outfile.write('ReportingBegin=%s,\n' % quote_python(self.ReportingBegin).encode(ExternalEncoding))
        if self.ReportingEnd is not None:
            showIndent(outfile, level)
            outfile.write('ReportingEnd=%s,\n' % quote_python(self.ReportingEnd).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Source=[\n')
        level += 1
        for Source_ in self.Source:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Source_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IDType(self.ID)    # validate type IDType
        elif nodeName_ == 'Test':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Test')
            self.Test = ival_
        elif nodeName_ == 'Truncated':
            sval_ = child_.text
            if sval_ in ('true', '1'):
                ival_ = True
            elif sval_ in ('false', '0'):
                ival_ = False
            else:
                raise_parse_error(child_, 'requires boolean')
            ival_ = self.gds_validate_boolean(ival_, node, 'Truncated')
            self.Truncated = ival_
        elif nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Prepared':
            Prepared_ = child_.text
            Prepared_ = self.gds_validate_string(Prepared_, node, 'Prepared')
            self.Prepared = Prepared_
            self.validate_HeaderTimeType(self.Prepared)    # validate type HeaderTimeType
        elif nodeName_ == 'Sender':
            obj_ = PartyType.factory()
            obj_.build(child_)
            self.Sender.append(obj_)
            obj_.original_tagname_ = 'Sender'
        elif nodeName_ == 'Receiver':
            obj_ = PartyType.factory()
            obj_.build(child_)
            self.Receiver.append(obj_)
            obj_.original_tagname_ = 'Receiver'
        elif nodeName_ == 'KeyFamilyRef':
            KeyFamilyRef_ = child_.text
            KeyFamilyRef_ = self.gds_validate_string(KeyFamilyRef_, node, 'KeyFamilyRef')
            self.KeyFamilyRef = KeyFamilyRef_
        elif nodeName_ == 'KeyFamilyAgency':
            KeyFamilyAgency_ = child_.text
            KeyFamilyAgency_ = self.gds_validate_string(KeyFamilyAgency_, node, 'KeyFamilyAgency')
            self.KeyFamilyAgency = KeyFamilyAgency_
        elif nodeName_ == 'DataSetAgency':
            DataSetAgency_ = child_.text
            DataSetAgency_ = self.gds_validate_string(DataSetAgency_, node, 'DataSetAgency')
            self.DataSetAgency = DataSetAgency_
        elif nodeName_ == 'DataSetID':
            DataSetID_ = child_.text
            DataSetID_ = self.gds_validate_string(DataSetID_, node, 'DataSetID')
            self.DataSetID = DataSetID_
        elif nodeName_ == 'DataSetAction':
            DataSetAction_ = child_.text
            DataSetAction_ = self.gds_validate_string(DataSetAction_, node, 'DataSetAction')
            self.DataSetAction = DataSetAction_
            self.validate_ActionType(self.DataSetAction)    # validate type ActionType
        elif nodeName_ == 'Extracted':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.Extracted = dval_
        elif nodeName_ == 'ReportingBegin':
            ReportingBegin_ = child_.text
            ReportingBegin_ = self.gds_validate_string(ReportingBegin_, node, 'ReportingBegin')
            self.ReportingBegin = ReportingBegin_
            self.validate_HeaderTimeType(self.ReportingBegin)    # validate type HeaderTimeType
        elif nodeName_ == 'ReportingEnd':
            ReportingEnd_ = child_.text
            ReportingEnd_ = self.gds_validate_string(ReportingEnd_, node, 'ReportingEnd')
            self.ReportingEnd = ReportingEnd_
            self.validate_HeaderTimeType(self.ReportingEnd)    # validate type HeaderTimeType
        elif nodeName_ == 'Source':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Source.append(obj_)
            obj_.original_tagname_ = 'Source'
# end class HeaderType


class PartyType(GeneratedsSuper):
    """PartyType defines the information which is sent about various
    parties such as senders and receivers of messages. The Name is
    the ID of the party, and Contact provides contact details."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Contact=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Contact is None:
            self.Contact = []
        else:
            self.Contact = Contact
    def factory(*args_, **kwargs_):
        if PartyType.subclass:
            return PartyType.subclass(*args_, **kwargs_)
        else:
            return PartyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Contact(self): return self.Contact
    def set_Contact(self, Contact): self.Contact = Contact
    def add_Contact(self, value): self.Contact.append(value)
    def insert_Contact_at(self, index, value): self.Contact.insert(index, value)
    def replace_Contact_at(self, index, value): self.Contact[index] = value
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Contact
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='PartyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='PartyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='PartyType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='PartyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Contact_ in self.Contact:
            Contact_.export(outfile, level, namespace_, name_='Contact', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PartyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Contact=[\n')
        level += 1
        for Contact_ in self.Contact:
            showIndent(outfile, level)
            outfile.write('model_.ContactType(\n')
            Contact_.exportLiteral(outfile, level, name_='ContactType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Contact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.Contact.append(obj_)
            obj_.original_tagname_ = 'Contact'
# end class PartyType


class ContactType(GeneratedsSuper):
    """ContactType provides defines the contact information about a party.
    The Name provides a human-readable name."""
    subclass = None
    superclass = None
    def __init__(self, Name=None, Department=None, Role=None, Telephone=None, Fax=None, X400=None, URI=None, Email=None):
        self.original_tagname_ = None
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Department is None:
            self.Department = []
        else:
            self.Department = Department
        if Role is None:
            self.Role = []
        else:
            self.Role = Role
        if Telephone is None:
            self.Telephone = []
        else:
            self.Telephone = Telephone
        if Fax is None:
            self.Fax = []
        else:
            self.Fax = Fax
        if X400 is None:
            self.X400 = []
        else:
            self.X400 = X400
        if URI is None:
            self.URI = []
        else:
            self.URI = URI
        if Email is None:
            self.Email = []
        else:
            self.Email = Email
    def factory(*args_, **kwargs_):
        if ContactType.subclass:
            return ContactType.subclass(*args_, **kwargs_)
        else:
            return ContactType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Department(self): return self.Department
    def set_Department(self, Department): self.Department = Department
    def add_Department(self, value): self.Department.append(value)
    def insert_Department_at(self, index, value): self.Department.insert(index, value)
    def replace_Department_at(self, index, value): self.Department[index] = value
    def get_Role(self): return self.Role
    def set_Role(self, Role): self.Role = Role
    def add_Role(self, value): self.Role.append(value)
    def insert_Role_at(self, index, value): self.Role.insert(index, value)
    def replace_Role_at(self, index, value): self.Role[index] = value
    def get_Telephone(self): return self.Telephone
    def set_Telephone(self, Telephone): self.Telephone = Telephone
    def add_Telephone(self, value): self.Telephone.append(value)
    def insert_Telephone_at(self, index, value): self.Telephone.insert(index, value)
    def replace_Telephone_at(self, index, value): self.Telephone[index] = value
    def get_Fax(self): return self.Fax
    def set_Fax(self, Fax): self.Fax = Fax
    def add_Fax(self, value): self.Fax.append(value)
    def insert_Fax_at(self, index, value): self.Fax.insert(index, value)
    def replace_Fax_at(self, index, value): self.Fax[index] = value
    def get_X400(self): return self.X400
    def set_X400(self, X400): self.X400 = X400
    def add_X400(self, value): self.X400.append(value)
    def insert_X400_at(self, index, value): self.X400.insert(index, value)
    def replace_X400_at(self, index, value): self.X400[index] = value
    def get_URI(self): return self.URI
    def set_URI(self, URI): self.URI = URI
    def add_URI(self, value): self.URI.append(value)
    def insert_URI_at(self, index, value): self.URI.insert(index, value)
    def replace_URI_at(self, index, value): self.URI[index] = value
    def get_Email(self): return self.Email
    def set_Email(self, Email): self.Email = Email
    def add_Email(self, value): self.Email.append(value)
    def insert_Email_at(self, index, value): self.Email.insert(index, value)
    def replace_Email_at(self, index, value): self.Email[index] = value
    def hasContent_(self):
        if (
            self.Name or
            self.Department or
            self.Role or
            self.Telephone or
            self.Fax or
            self.X400 or
            self.URI or
            self.Email
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ContactType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ContactType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ContactType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ContactType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ContactType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Department_ in self.Department:
            Department_.export(outfile, level, namespace_, name_='Department', pretty_print=pretty_print)
        for Role_ in self.Role:
            Role_.export(outfile, level, namespace_, name_='Role', pretty_print=pretty_print)
        for Telephone_ in self.Telephone:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTelephone>%s</%sTelephone>%s' % (namespace_, self.gds_format_string(quote_xml(Telephone_).encode(ExternalEncoding), input_name='Telephone'), namespace_, eol_))
        for Fax_ in self.Fax:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFax>%s</%sFax>%s' % (namespace_, self.gds_format_string(quote_xml(Fax_).encode(ExternalEncoding), input_name='Fax'), namespace_, eol_))
        for X400_ in self.X400:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sX400>%s</%sX400>%s' % (namespace_, self.gds_format_string(quote_xml(X400_).encode(ExternalEncoding), input_name='X400'), namespace_, eol_))
        for URI_ in self.URI:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURI>%s</%sURI>%s' % (namespace_, self.gds_format_string(quote_xml(URI_).encode(ExternalEncoding), input_name='URI'), namespace_, eol_))
        for Email_ in self.Email:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEmail>%s</%sEmail>%s' % (namespace_, self.gds_format_string(quote_xml(Email_).encode(ExternalEncoding), input_name='Email'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ContactType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Department=[\n')
        level += 1
        for Department_ in self.Department:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Department_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Role=[\n')
        level += 1
        for Role_ in self.Role:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Role_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Telephone=[\n')
        level += 1
        for Telephone_ in self.Telephone:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Telephone_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Fax=[\n')
        level += 1
        for Fax_ in self.Fax:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Fax_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('X400=[\n')
        level += 1
        for X400_ in self.X400:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(X400_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('URI=[\n')
        level += 1
        for URI_ in self.URI:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(URI_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Email=[\n')
        level += 1
        for Email_ in self.Email:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Email_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Department':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Department.append(obj_)
            obj_.original_tagname_ = 'Department'
        elif nodeName_ == 'Role':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Role.append(obj_)
            obj_.original_tagname_ = 'Role'
        elif nodeName_ == 'Telephone':
            Telephone_ = child_.text
            Telephone_ = self.gds_validate_string(Telephone_, node, 'Telephone')
            self.Telephone.append(Telephone_)
        elif nodeName_ == 'Fax':
            Fax_ = child_.text
            Fax_ = self.gds_validate_string(Fax_, node, 'Fax')
            self.Fax.append(Fax_)
        elif nodeName_ == 'X400':
            X400_ = child_.text
            X400_ = self.gds_validate_string(X400_, node, 'X400')
            self.X400.append(X400_)
        elif nodeName_ == 'URI':
            URI_ = child_.text
            URI_ = self.gds_validate_string(URI_, node, 'URI')
            self.URI.append(URI_)
        elif nodeName_ == 'Email':
            Email_ = child_.text
            Email_ = self.gds_validate_string(Email_, node, 'Email')
            self.Email.append(Email_)
# end class ContactType


class OrganisationSchemesType(GeneratedsSuper):
    """OrganisationSchemesType contains one or more OrganisationSchemes."""
    subclass = None
    superclass = None
    def __init__(self, OrganisationScheme=None):
        self.original_tagname_ = None
        if OrganisationScheme is None:
            self.OrganisationScheme = []
        else:
            self.OrganisationScheme = OrganisationScheme
    def factory(*args_, **kwargs_):
        if OrganisationSchemesType.subclass:
            return OrganisationSchemesType.subclass(*args_, **kwargs_)
        else:
            return OrganisationSchemesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrganisationScheme(self): return self.OrganisationScheme
    def set_OrganisationScheme(self, OrganisationScheme): self.OrganisationScheme = OrganisationScheme
    def add_OrganisationScheme(self, value): self.OrganisationScheme.append(value)
    def insert_OrganisationScheme_at(self, index, value): self.OrganisationScheme.insert(index, value)
    def replace_OrganisationScheme_at(self, index, value): self.OrganisationScheme[index] = value
    def hasContent_(self):
        if (
            self.OrganisationScheme
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationSchemesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationSchemesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationSchemesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationSchemesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationSchemesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for OrganisationScheme_ in self.OrganisationScheme:
            OrganisationScheme_.export(outfile, level, namespace_, name_='OrganisationScheme', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrganisationSchemesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('OrganisationScheme=[\n')
        level += 1
        for OrganisationScheme_ in self.OrganisationScheme:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationSchemeType(\n')
            OrganisationScheme_.exportLiteral(outfile, level, name_='OrganisationSchemeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrganisationScheme':
            obj_ = OrganisationSchemeType.factory()
            obj_.build(child_)
            self.OrganisationScheme.append(obj_)
            obj_.original_tagname_ = 'OrganisationScheme'
# end class OrganisationSchemesType


class OrganisationSchemeType(GeneratedsSuper):
    """OrganisationSchemeType contains the details of an
    OrganisationScheme. In OrganisationSchemes, the organisation
    roles of agency, data provider, and data consumer may be
    specified. A single organisation may play more than one role.
    Name is an element which provides for a human-readable name for
    the organization. Description may be used to provide a longer,
    human-readable description. the is attribute provides a formal
    ID for the organisation scheme; the version attribute specifies
    a particular version. If blank, it is assumed that the version
    is "1.0". The uri attributre specifies the location of a valid
    SDMC Structure Message containing the full details of the
    organisation sc`heme, and is required if the isExternalReference
    attribute has a value of true. If isExternalReference has a
    value of false, full details must be provided in the current
    instance of the OrganisationScheme element. The urn attribute
    provides a formal SDMX Registry URL - see the Logical Registry
    Specification for specific requirements. An agencyID must be
    provided, identifying the maintenance agency of the organisation
    scheme. Also, if the organisation scheme is final, the isFinal
    attribute must have a value of true - otherwise, it will be
    assumed to be non-final. (All production schemes must be made
    final - that is, unchangeable without versioning.) The validFrom
    and validTo attributes provide inclusive dates for providing
    supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, Agencies=None, DataProviders=None, DataConsumers=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Agencies is None:
            self.Agencies = []
        else:
            self.Agencies = Agencies
        if DataProviders is None:
            self.DataProviders = []
        else:
            self.DataProviders = DataProviders
        if DataConsumers is None:
            self.DataConsumers = []
        else:
            self.DataConsumers = DataConsumers
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if OrganisationSchemeType.subclass:
            return OrganisationSchemeType.subclass(*args_, **kwargs_)
        else:
            return OrganisationSchemeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Agencies(self): return self.Agencies
    def set_Agencies(self, Agencies): self.Agencies = Agencies
    def add_Agencies(self, value): self.Agencies.append(value)
    def insert_Agencies_at(self, index, value): self.Agencies.insert(index, value)
    def replace_Agencies_at(self, index, value): self.Agencies[index] = value
    def get_DataProviders(self): return self.DataProviders
    def set_DataProviders(self, DataProviders): self.DataProviders = DataProviders
    def add_DataProviders(self, value): self.DataProviders.append(value)
    def insert_DataProviders_at(self, index, value): self.DataProviders.insert(index, value)
    def replace_DataProviders_at(self, index, value): self.DataProviders[index] = value
    def get_DataConsumers(self): return self.DataConsumers
    def set_DataConsumers(self, DataConsumers): self.DataConsumers = DataConsumers
    def add_DataConsumers(self, value): self.DataConsumers.append(value)
    def insert_DataConsumers_at(self, index, value): self.DataConsumers.insert(index, value)
    def replace_DataConsumers_at(self, index, value): self.DataConsumers[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Agencies or
            self.DataProviders or
            self.DataConsumers or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationSchemeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationSchemeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationSchemeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationSchemeType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationSchemeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Agencies_ in self.Agencies:
            Agencies_.export(outfile, level, namespace_, name_='Agencies', pretty_print=pretty_print)
        for DataProviders_ in self.DataProviders:
            DataProviders_.export(outfile, level, namespace_, name_='DataProviders', pretty_print=pretty_print)
        for DataConsumers_ in self.DataConsumers:
            DataConsumers_.export(outfile, level, namespace_, name_='DataConsumers', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrganisationSchemeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Agencies=[\n')
        level += 1
        for Agencies_ in self.Agencies:
            showIndent(outfile, level)
            outfile.write('model_.AgenciesType(\n')
            Agencies_.exportLiteral(outfile, level, name_='AgenciesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviders=[\n')
        level += 1
        for DataProviders_ in self.DataProviders:
            showIndent(outfile, level)
            outfile.write('model_.DataProvidersType(\n')
            DataProviders_.exportLiteral(outfile, level, name_='DataProvidersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataConsumers=[\n')
        level += 1
        for DataConsumers_ in self.DataConsumers:
            showIndent(outfile, level)
            outfile.write('model_.DataConsumersType(\n')
            DataConsumers_.exportLiteral(outfile, level, name_='DataConsumersType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Agencies':
            obj_ = AgenciesType.factory()
            obj_.build(child_)
            self.Agencies.append(obj_)
            obj_.original_tagname_ = 'Agencies'
        elif nodeName_ == 'DataProviders':
            obj_ = DataProvidersType.factory()
            obj_.build(child_)
            self.DataProviders.append(obj_)
            obj_.original_tagname_ = 'DataProviders'
        elif nodeName_ == 'DataConsumers':
            obj_ = DataConsumersType.factory()
            obj_.build(child_)
            self.DataConsumers.append(obj_)
            obj_.original_tagname_ = 'DataConsumers'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class OrganisationSchemeType


class DataProvidersType(GeneratedsSuper):
    """DataProvidersType contains one or more data providers. Data
    providers are those who report or disseminate data sets or
    metadata sets."""
    subclass = None
    superclass = None
    def __init__(self, DataProvider=None):
        self.original_tagname_ = None
        if DataProvider is None:
            self.DataProvider = []
        else:
            self.DataProvider = DataProvider
    def factory(*args_, **kwargs_):
        if DataProvidersType.subclass:
            return DataProvidersType.subclass(*args_, **kwargs_)
        else:
            return DataProvidersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def add_DataProvider(self, value): self.DataProvider.append(value)
    def insert_DataProvider_at(self, index, value): self.DataProvider.insert(index, value)
    def replace_DataProvider_at(self, index, value): self.DataProvider[index] = value
    def hasContent_(self):
        if (
            self.DataProvider
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataProvidersType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProvidersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataProvidersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataProvidersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataProvidersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataProvider_ in self.DataProvider:
            DataProvider_.export(outfile, level, namespace_, name_='DataProvider', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataProvidersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataProvider=[\n')
        level += 1
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationType(\n')
            DataProvider_.exportLiteral(outfile, level, name_='OrganisationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataProvider':
            obj_ = OrganisationType.factory()
            obj_.build(child_)
            self.DataProvider.append(obj_)
            obj_.original_tagname_ = 'DataProvider'
# end class DataProvidersType


class DataConsumersType(GeneratedsSuper):
    """DataConsumersType contains one or more data consumers. Data
    consumers collect or use disseminated data sets and metadata
    sets."""
    subclass = None
    superclass = None
    def __init__(self, DataConsumer=None):
        self.original_tagname_ = None
        if DataConsumer is None:
            self.DataConsumer = []
        else:
            self.DataConsumer = DataConsumer
    def factory(*args_, **kwargs_):
        if DataConsumersType.subclass:
            return DataConsumersType.subclass(*args_, **kwargs_)
        else:
            return DataConsumersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataConsumer(self): return self.DataConsumer
    def set_DataConsumer(self, DataConsumer): self.DataConsumer = DataConsumer
    def add_DataConsumer(self, value): self.DataConsumer.append(value)
    def insert_DataConsumer_at(self, index, value): self.DataConsumer.insert(index, value)
    def replace_DataConsumer_at(self, index, value): self.DataConsumer[index] = value
    def hasContent_(self):
        if (
            self.DataConsumer
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataConsumersType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataConsumersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataConsumersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataConsumersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataConsumersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataConsumer_ in self.DataConsumer:
            DataConsumer_.export(outfile, level, namespace_, name_='DataConsumer', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataConsumersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataConsumer=[\n')
        level += 1
        for DataConsumer_ in self.DataConsumer:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationType(\n')
            DataConsumer_.exportLiteral(outfile, level, name_='OrganisationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataConsumer':
            obj_ = OrganisationType.factory()
            obj_.build(child_)
            self.DataConsumer.append(obj_)
            obj_.original_tagname_ = 'DataConsumer'
# end class DataConsumersType


class AgenciesType(GeneratedsSuper):
    """AgenciesType contains one or more Agencies. Agencies are those
    organisations which act as the maintainers of structural
    definitions of various types. Agencies are often supplied as
    part of an organisation scheme, but may also be supplied
    independently using this element."""
    subclass = None
    superclass = None
    def __init__(self, Agency=None):
        self.original_tagname_ = None
        if Agency is None:
            self.Agency = []
        else:
            self.Agency = Agency
    def factory(*args_, **kwargs_):
        if AgenciesType.subclass:
            return AgenciesType.subclass(*args_, **kwargs_)
        else:
            return AgenciesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Agency(self): return self.Agency
    def set_Agency(self, Agency): self.Agency = Agency
    def add_Agency(self, value): self.Agency.append(value)
    def insert_Agency_at(self, index, value): self.Agency.insert(index, value)
    def replace_Agency_at(self, index, value): self.Agency[index] = value
    def hasContent_(self):
        if (
            self.Agency
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AgenciesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgenciesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AgenciesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AgenciesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AgenciesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Agency_ in self.Agency:
            Agency_.export(outfile, level, namespace_, name_='Agency', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AgenciesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Agency=[\n')
        level += 1
        for Agency_ in self.Agency:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationType(\n')
            Agency_.exportLiteral(outfile, level, name_='OrganisationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Agency':
            obj_ = OrganisationType.factory()
            obj_.build(child_)
            self.Agency.append(obj_)
            obj_.original_tagname_ = 'Agency'
# end class AgenciesType


class OrganisationType(GeneratedsSuper):
    """OrganisationType provides a structure for describing agencies, data
    providers, and data consumers and their contact information. The
    id attribute carries a code identifying the agency. The version
    attribute indicates the version of the agency description. The
    uri attribute provides a uri for an alternate way of identifying
    the agency information (typically a URL resolving to an agency
    described in SDMX-ML). Name is an element which provides for a
    human-readable name for the organization. Description provides
    for a longer human-readable description of the organisation,
    which may be provided in multiple, parallel language-equivalent
    forms. MaintenanceContact provides contact information for the
    agency when acting as a MaintenanceAgency; CollectorContact does
    the same when the agency is acting as a statistics collector;
    DisseminatorContact for when the agency functions as a
    statistics disseminator; and ReporterContact for when the Agency
    is functioning as a statistics reporter. OtherContact is used to
    describe any other role. Note that the Role field in the contact
    information structure should only be specified for OtherContact.
    It is allowable to reference full Agency information by using
    (at a minimum) only the id, name, and uri fields, with the uri
    pointing to an external description in a valid SDMX-ML Structure
    message which provides more complete information. (This is
    termed an "external reference".) If an external reference is
    being made, the isExternalReference attribute must be set to
    "true". The urn attribute holds a valid SDMX Registry URN (see
    SDMX Registry Specification). The parentOrganisation attribute
    holds the id of a parent organisation of the same type from the
    same scheme, indicating that the organisation in question is a
    department or other sub-division of the parent organisation.
    Annotations may be provided using the Annotations element, in
    multiple, parallel-language form."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, uri=None, validTo=None, version=None, parentOrganisation=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, MaintenanceContact=None, CollectorContact=None, DisseminatorContact=None, ReporterContact=None, OtherContact=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.parentOrganisation = _cast(None, parentOrganisation)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.MaintenanceContact = MaintenanceContact
        self.CollectorContact = CollectorContact
        self.DisseminatorContact = DisseminatorContact
        self.ReporterContact = ReporterContact
        if OtherContact is None:
            self.OtherContact = []
        else:
            self.OtherContact = OtherContact
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if OrganisationType.subclass:
            return OrganisationType.subclass(*args_, **kwargs_)
        else:
            return OrganisationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_MaintenanceContact(self): return self.MaintenanceContact
    def set_MaintenanceContact(self, MaintenanceContact): self.MaintenanceContact = MaintenanceContact
    def get_CollectorContact(self): return self.CollectorContact
    def set_CollectorContact(self, CollectorContact): self.CollectorContact = CollectorContact
    def get_DisseminatorContact(self): return self.DisseminatorContact
    def set_DisseminatorContact(self, DisseminatorContact): self.DisseminatorContact = DisseminatorContact
    def get_ReporterContact(self): return self.ReporterContact
    def set_ReporterContact(self, ReporterContact): self.ReporterContact = ReporterContact
    def get_OtherContact(self): return self.OtherContact
    def set_OtherContact(self, OtherContact): self.OtherContact = OtherContact
    def add_OtherContact(self, value): self.OtherContact.append(value)
    def insert_OtherContact_at(self, index, value): self.OtherContact.insert(index, value)
    def replace_OtherContact_at(self, index, value): self.OtherContact[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_parentOrganisation(self): return self.parentOrganisation
    def set_parentOrganisation(self, parentOrganisation): self.parentOrganisation = parentOrganisation
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.MaintenanceContact is not None or
            self.CollectorContact is not None or
            self.DisseminatorContact is not None or
            self.ReporterContact is not None or
            self.OtherContact or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.parentOrganisation is not None and 'parentOrganisation' not in already_processed:
            already_processed.add('parentOrganisation')
            outfile.write(' parentOrganisation=%s' % (quote_attrib(self.parentOrganisation), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.MaintenanceContact is not None:
            self.MaintenanceContact.export(outfile, level, namespace_, name_='MaintenanceContact', pretty_print=pretty_print)
        if self.CollectorContact is not None:
            self.CollectorContact.export(outfile, level, namespace_, name_='CollectorContact', pretty_print=pretty_print)
        if self.DisseminatorContact is not None:
            self.DisseminatorContact.export(outfile, level, namespace_, name_='DisseminatorContact', pretty_print=pretty_print)
        if self.ReporterContact is not None:
            self.ReporterContact.export(outfile, level, namespace_, name_='ReporterContact', pretty_print=pretty_print)
        for OtherContact_ in self.OtherContact:
            OtherContact_.export(outfile, level, namespace_, name_='OtherContact', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrganisationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.parentOrganisation is not None and 'parentOrganisation' not in already_processed:
            already_processed.add('parentOrganisation')
            showIndent(outfile, level)
            outfile.write('parentOrganisation=%s,\n' % (self.parentOrganisation,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MaintenanceContact is not None:
            showIndent(outfile, level)
            outfile.write('MaintenanceContact=model_.ContactType(\n')
            self.MaintenanceContact.exportLiteral(outfile, level, name_='MaintenanceContact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CollectorContact is not None:
            showIndent(outfile, level)
            outfile.write('CollectorContact=model_.ContactType(\n')
            self.CollectorContact.exportLiteral(outfile, level, name_='CollectorContact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DisseminatorContact is not None:
            showIndent(outfile, level)
            outfile.write('DisseminatorContact=model_.ContactType(\n')
            self.DisseminatorContact.exportLiteral(outfile, level, name_='DisseminatorContact')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReporterContact is not None:
            showIndent(outfile, level)
            outfile.write('ReporterContact=model_.ContactType(\n')
            self.ReporterContact.exportLiteral(outfile, level, name_='ReporterContact')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OtherContact=[\n')
        level += 1
        for OtherContact_ in self.OtherContact:
            showIndent(outfile, level)
            outfile.write('model_.ContactType(\n')
            OtherContact_.exportLiteral(outfile, level, name_='ContactType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('parentOrganisation', node)
        if value is not None and 'parentOrganisation' not in already_processed:
            already_processed.add('parentOrganisation')
            self.parentOrganisation = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'MaintenanceContact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.MaintenanceContact = obj_
            obj_.original_tagname_ = 'MaintenanceContact'
        elif nodeName_ == 'CollectorContact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.CollectorContact = obj_
            obj_.original_tagname_ = 'CollectorContact'
        elif nodeName_ == 'DisseminatorContact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.DisseminatorContact = obj_
            obj_.original_tagname_ = 'DisseminatorContact'
        elif nodeName_ == 'ReporterContact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.ReporterContact = obj_
            obj_.original_tagname_ = 'ReporterContact'
        elif nodeName_ == 'OtherContact':
            obj_ = ContactType.factory()
            obj_.build(child_)
            self.OtherContact.append(obj_)
            obj_.original_tagname_ = 'OtherContact'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class OrganisationType


class DataflowsType(GeneratedsSuper):
    """DataflowsType contains one or more data flows."""
    subclass = None
    superclass = None
    def __init__(self, Dataflow=None):
        self.original_tagname_ = None
        if Dataflow is None:
            self.Dataflow = []
        else:
            self.Dataflow = Dataflow
    def factory(*args_, **kwargs_):
        if DataflowsType.subclass:
            return DataflowsType.subclass(*args_, **kwargs_)
        else:
            return DataflowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dataflow(self): return self.Dataflow
    def set_Dataflow(self, Dataflow): self.Dataflow = Dataflow
    def add_Dataflow(self, value): self.Dataflow.append(value)
    def insert_Dataflow_at(self, index, value): self.Dataflow.insert(index, value)
    def replace_Dataflow_at(self, index, value): self.Dataflow[index] = value
    def hasContent_(self):
        if (
            self.Dataflow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataflowsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataflowsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataflowsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataflowsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataflowsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dataflow_ in self.Dataflow:
            Dataflow_.export(outfile, level, namespace_, name_='Dataflow', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataflowsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Dataflow=[\n')
        level += 1
        for Dataflow_ in self.Dataflow:
            showIndent(outfile, level)
            outfile.write('model_.DataflowType(\n')
            Dataflow_.exportLiteral(outfile, level, name_='DataflowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dataflow':
            obj_ = DataflowType.factory()
            obj_.build(child_)
            self.Dataflow.append(obj_)
            obj_.original_tagname_ = 'Dataflow'
# end class DataflowsType


class DataflowType(GeneratedsSuper):
    """DataflowType describes the structure of a data flow. A human-
    readable name must be provided, and may be given in several
    language-specific variations. A longer human-readable
    description (also in multiple language-specific versions) may be
    provided. A reference must be made to a key family, and to a
    category within a category scheme, using the KeyFamilyRef and
    CategoryRef elements, unless the Dataflow is a reference to an
    external data flow, in which case a url must be provided in the
    uri attribute, and the isExternalReference attribute must be set
    to true.. Annotations may be provided in the Annotations
    element. An id unique to the maintaining agency (identified in
    the agencyID attribute) must be supplied in the "id" attribute;
    a version may be specified, and is assumed to be "1.0" if not
    supplied. The urn attribute may contain a valid registry URN (as
    per the SDMX Registry Specification). If the dataflow is final,
    the isFinal attribute must have a value of true - any production
    dataflow must be final (that is, it cannot be changed without
    versioning). The validFrom and validTo attributes provide
    inclusive dates for providing supplemental validity information
    about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, KeyFamilyRef=None, CategoryRef=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.KeyFamilyRef = KeyFamilyRef
        if CategoryRef is None:
            self.CategoryRef = []
        else:
            self.CategoryRef = CategoryRef
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if DataflowType.subclass:
            return DataflowType.subclass(*args_, **kwargs_)
        else:
            return DataflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def get_CategoryRef(self): return self.CategoryRef
    def set_CategoryRef(self, CategoryRef): self.CategoryRef = CategoryRef
    def add_CategoryRef(self, value): self.CategoryRef.append(value)
    def insert_CategoryRef_at(self, index, value): self.CategoryRef.insert(index, value)
    def replace_CategoryRef_at(self, index, value): self.CategoryRef[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.KeyFamilyRef is not None or
            self.CategoryRef or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataflowType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataflowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataflowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataflowType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataflowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.KeyFamilyRef is not None:
            self.KeyFamilyRef.export(outfile, level, namespace_, name_='KeyFamilyRef', pretty_print=pretty_print)
        for CategoryRef_ in self.CategoryRef:
            CategoryRef_.export(outfile, level, namespace_, name_='CategoryRef', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataflowType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyRef=model_.KeyFamilyRefType(\n')
            self.KeyFamilyRef.exportLiteral(outfile, level, name_='KeyFamilyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CategoryRef=[\n')
        level += 1
        for CategoryRef_ in self.CategoryRef:
            showIndent(outfile, level)
            outfile.write('model_.CategoryRefType(\n')
            CategoryRef_.exportLiteral(outfile, level, name_='CategoryRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'KeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.KeyFamilyRef = obj_
            obj_.original_tagname_ = 'KeyFamilyRef'
        elif nodeName_ == 'CategoryRef':
            obj_ = CategoryRefType.factory()
            obj_.build(child_)
            self.CategoryRef.append(obj_)
            obj_.original_tagname_ = 'CategoryRef'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class DataflowType


class KeyFamilyRefType(GeneratedsSuper):
    """KeyFamilyRefType provides a reference to a key-family (data set
    structure definition). At a minimum, either (a) The key family
    ID must be provided, as assigned to the key family by the agency
    whose ID is the value of KeyFamilyAgencyID. A version must also
    be provided; OR (b) a valid SDMX Registry URN must be provided
    in the URN element (see SDMX Registry Specification)"""
    subclass = None
    superclass = None
    def __init__(self, URN=None, KeyFamilyID=None, KeyFamilyAgencyID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.KeyFamilyID = KeyFamilyID
        self.KeyFamilyAgencyID = KeyFamilyAgencyID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if KeyFamilyRefType.subclass:
            return KeyFamilyRefType.subclass(*args_, **kwargs_)
        else:
            return KeyFamilyRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_KeyFamilyID(self): return self.KeyFamilyID
    def set_KeyFamilyID(self, KeyFamilyID): self.KeyFamilyID = KeyFamilyID
    def get_KeyFamilyAgencyID(self): return self.KeyFamilyAgencyID
    def set_KeyFamilyAgencyID(self, KeyFamilyAgencyID): self.KeyFamilyAgencyID = KeyFamilyAgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.KeyFamilyID is not None or
            self.KeyFamilyAgencyID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeyFamilyRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyFamilyRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeyFamilyRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeyFamilyRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeyFamilyRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.KeyFamilyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyID>%s</%sKeyFamilyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamilyID).encode(ExternalEncoding), input_name='KeyFamilyID'), namespace_, eol_))
        if self.KeyFamilyAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyAgencyID>%s</%sKeyFamilyAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamilyAgencyID).encode(ExternalEncoding), input_name='KeyFamilyAgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='KeyFamilyRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.KeyFamilyID is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyID=%s,\n' % quote_python(self.KeyFamilyID).encode(ExternalEncoding))
        if self.KeyFamilyAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyAgencyID=%s,\n' % quote_python(self.KeyFamilyAgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'KeyFamilyID':
            KeyFamilyID_ = child_.text
            KeyFamilyID_ = self.gds_validate_string(KeyFamilyID_, node, 'KeyFamilyID')
            self.KeyFamilyID = KeyFamilyID_
            self.validate_IDType(self.KeyFamilyID)    # validate type IDType
        elif nodeName_ == 'KeyFamilyAgencyID':
            KeyFamilyAgencyID_ = child_.text
            KeyFamilyAgencyID_ = self.gds_validate_string(KeyFamilyAgencyID_, node, 'KeyFamilyAgencyID')
            self.KeyFamilyAgencyID = KeyFamilyAgencyID_
            self.validate_IDType(self.KeyFamilyAgencyID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class KeyFamilyRefType


class CategoryRefType(GeneratedsSuper):
    """CategoryRefType provides a reference to a category. At a minimum,
    either a value for CategorySchemeAgencyID, CategorySchemeID, and
    CategoryID must be provided, or a valid SDMX Registry URN must
    be provided in the URN element (see SDMX Registry
    Specification)."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, CategorySchemeID=None, CategorySchemeAgencyID=None, CategorySchemeVersion=None, CategoryID=None):
        self.original_tagname_ = None
        self.URN = URN
        self.CategorySchemeID = CategorySchemeID
        self.CategorySchemeAgencyID = CategorySchemeAgencyID
        self.CategorySchemeVersion = CategorySchemeVersion
        self.CategoryID = CategoryID
    def factory(*args_, **kwargs_):
        if CategoryRefType.subclass:
            return CategoryRefType.subclass(*args_, **kwargs_)
        else:
            return CategoryRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_CategorySchemeID(self): return self.CategorySchemeID
    def set_CategorySchemeID(self, CategorySchemeID): self.CategorySchemeID = CategorySchemeID
    def get_CategorySchemeAgencyID(self): return self.CategorySchemeAgencyID
    def set_CategorySchemeAgencyID(self, CategorySchemeAgencyID): self.CategorySchemeAgencyID = CategorySchemeAgencyID
    def get_CategorySchemeVersion(self): return self.CategorySchemeVersion
    def set_CategorySchemeVersion(self, CategorySchemeVersion): self.CategorySchemeVersion = CategorySchemeVersion
    def get_CategoryID(self): return self.CategoryID
    def set_CategoryID(self, CategoryID): self.CategoryID = CategoryID
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.CategorySchemeID is not None or
            self.CategorySchemeAgencyID is not None or
            self.CategorySchemeVersion is not None or
            self.CategoryID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategoryRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategoryRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategoryRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategoryRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.CategorySchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeID>%s</%sCategorySchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategorySchemeID).encode(ExternalEncoding), input_name='CategorySchemeID'), namespace_, eol_))
        if self.CategorySchemeAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeAgencyID>%s</%sCategorySchemeAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategorySchemeAgencyID).encode(ExternalEncoding), input_name='CategorySchemeAgencyID'), namespace_, eol_))
        if self.CategorySchemeVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeVersion>%s</%sCategorySchemeVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategorySchemeVersion).encode(ExternalEncoding), input_name='CategorySchemeVersion'), namespace_, eol_))
        if self.CategoryID is not None:
            self.CategoryID.export(outfile, level, namespace_, name_='CategoryID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategoryRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.CategorySchemeID is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeID=%s,\n' % quote_python(self.CategorySchemeID).encode(ExternalEncoding))
        if self.CategorySchemeAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeAgencyID=%s,\n' % quote_python(self.CategorySchemeAgencyID).encode(ExternalEncoding))
        if self.CategorySchemeVersion is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeVersion=%s,\n' % quote_python(self.CategorySchemeVersion).encode(ExternalEncoding))
        if self.CategoryID is not None:
            showIndent(outfile, level)
            outfile.write('CategoryID=model_.CategoryIDType(\n')
            self.CategoryID.exportLiteral(outfile, level, name_='CategoryID')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'CategorySchemeID':
            CategorySchemeID_ = child_.text
            CategorySchemeID_ = self.gds_validate_string(CategorySchemeID_, node, 'CategorySchemeID')
            self.CategorySchemeID = CategorySchemeID_
            self.validate_IDType(self.CategorySchemeID)    # validate type IDType
        elif nodeName_ == 'CategorySchemeAgencyID':
            CategorySchemeAgencyID_ = child_.text
            CategorySchemeAgencyID_ = self.gds_validate_string(CategorySchemeAgencyID_, node, 'CategorySchemeAgencyID')
            self.CategorySchemeAgencyID = CategorySchemeAgencyID_
            self.validate_IDType(self.CategorySchemeAgencyID)    # validate type IDType
        elif nodeName_ == 'CategorySchemeVersion':
            CategorySchemeVersion_ = child_.text
            CategorySchemeVersion_ = self.gds_validate_string(CategorySchemeVersion_, node, 'CategorySchemeVersion')
            self.CategorySchemeVersion = CategorySchemeVersion_
        elif nodeName_ == 'CategoryID':
            obj_ = CategoryIDType.factory()
            obj_.build(child_)
            self.CategoryID = obj_
            obj_.original_tagname_ = 'CategoryID'
# end class CategoryRefType


class CategoryIDType(GeneratedsSuper):
    """CategoryIDType describes a structure which can provide a path inside
    a hierarchical category scheme. Each node (category) of the
    referenced scheme is represented by a CategoryID element, with
    sub-categories represented by the child CategoryID element. Each
    CategoryID element must be given a node identifier in the ID
    field, which corresponds to the ID of the category. It is not
    necessary to represent the full category path with the nesting
    structure if each node within the hierarchical category scheme
    has a unique id."""
    subclass = None
    superclass = None
    def __init__(self, ID=None, CategoryVersion=None, CategoryID=None):
        self.original_tagname_ = None
        self.ID = ID
        self.CategoryVersion = CategoryVersion
        self.CategoryID = CategoryID
    def factory(*args_, **kwargs_):
        if CategoryIDType.subclass:
            return CategoryIDType.subclass(*args_, **kwargs_)
        else:
            return CategoryIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_CategoryVersion(self): return self.CategoryVersion
    def set_CategoryVersion(self, CategoryVersion): self.CategoryVersion = CategoryVersion
    def get_CategoryID(self): return self.CategoryID
    def set_CategoryID(self, CategoryID): self.CategoryID = CategoryID
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ID is not None or
            self.CategoryVersion is not None or
            self.CategoryID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategoryIDType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategoryIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategoryIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategoryIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.CategoryVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryVersion>%s</%sCategoryVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategoryVersion).encode(ExternalEncoding), input_name='CategoryVersion'), namespace_, eol_))
        if self.CategoryID is not None:
            self.CategoryID.export(outfile, level, namespace_, name_='CategoryID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategoryIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.CategoryVersion is not None:
            showIndent(outfile, level)
            outfile.write('CategoryVersion=%s,\n' % quote_python(self.CategoryVersion).encode(ExternalEncoding))
        if self.CategoryID is not None:
            showIndent(outfile, level)
            outfile.write('CategoryID=model_.CategoryIDType(\n')
            self.CategoryID.exportLiteral(outfile, level, name_='CategoryID')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
            self.validate_IDType(self.ID)    # validate type IDType
        elif nodeName_ == 'CategoryVersion':
            CategoryVersion_ = child_.text
            CategoryVersion_ = self.gds_validate_string(CategoryVersion_, node, 'CategoryVersion')
            self.CategoryVersion = CategoryVersion_
        elif nodeName_ == 'CategoryID':
            obj_ = CategoryIDType.factory()
            obj_.build(child_)
            self.CategoryID = obj_
            obj_.original_tagname_ = 'CategoryID'
# end class CategoryIDType


class MetadataflowsType(GeneratedsSuper):
    """MetadataflowsType contains one or more metadata flows."""
    subclass = None
    superclass = None
    def __init__(self, Metadataflow=None):
        self.original_tagname_ = None
        if Metadataflow is None:
            self.Metadataflow = []
        else:
            self.Metadataflow = Metadataflow
    def factory(*args_, **kwargs_):
        if MetadataflowsType.subclass:
            return MetadataflowsType.subclass(*args_, **kwargs_)
        else:
            return MetadataflowsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Metadataflow(self): return self.Metadataflow
    def set_Metadataflow(self, Metadataflow): self.Metadataflow = Metadataflow
    def add_Metadataflow(self, value): self.Metadataflow.append(value)
    def insert_Metadataflow_at(self, index, value): self.Metadataflow.insert(index, value)
    def replace_Metadataflow_at(self, index, value): self.Metadataflow[index] = value
    def hasContent_(self):
        if (
            self.Metadataflow
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataflowsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataflowsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataflowsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataflowsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataflowsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Metadataflow_ in self.Metadataflow:
            Metadataflow_.export(outfile, level, namespace_, name_='Metadataflow', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataflowsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Metadataflow=[\n')
        level += 1
        for Metadataflow_ in self.Metadataflow:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowType(\n')
            Metadataflow_.exportLiteral(outfile, level, name_='MetadataflowType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Metadataflow':
            obj_ = MetadataflowType.factory()
            obj_.build(child_)
            self.Metadataflow.append(obj_)
            obj_.original_tagname_ = 'Metadataflow'
# end class MetadataflowsType


class MetadataflowType(GeneratedsSuper):
    """MetadataflowType describes the structure of a metadata flow. A
    human-readable name must be provided, and may be given in
    several language-specific variations. A longer human-readable
    description (also in multiple language-specific versions) may be
    provided. A reference must be made to a metadata structure
    definition, and to a category within a category scheme, using
    the MetadataStructureRef and CategoryRef elements. If the
    Metadataflow is an external reference, this is indicated by
    setting the isExternalReference attribute to true, and providing
    a url where the full description can be found in the form of a
    valid SDMX-ML structure message. In this case, only the id and
    name must be provided. Annotations may be provided in the
    Annotations element. An id unique to the maintaining agency
    (identified in the agencyID attribute) must be supplied in the
    "id" attribute; a version may be specified, and is assumed to be
    "1.0" if not supplied. The urn attribute may contain a valid
    registry URN (as per the SDMX Registry Specification). If the
    metadata flow is final, the isFinal attribute must have a value
    of true - any production metadata flow must be final (that is,
    it cannot be changed without versioning). The validFrom and
    validTo attributes provide inclusive dates for providing
    supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, MetadataStructureRef=None, CategoryRef=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.MetadataStructureRef = MetadataStructureRef
        if CategoryRef is None:
            self.CategoryRef = []
        else:
            self.CategoryRef = CategoryRef
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if MetadataflowType.subclass:
            return MetadataflowType.subclass(*args_, **kwargs_)
        else:
            return MetadataflowType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def get_CategoryRef(self): return self.CategoryRef
    def set_CategoryRef(self, CategoryRef): self.CategoryRef = CategoryRef
    def add_CategoryRef(self, value): self.CategoryRef.append(value)
    def insert_CategoryRef_at(self, index, value): self.CategoryRef.insert(index, value)
    def replace_CategoryRef_at(self, index, value): self.CategoryRef[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.MetadataStructureRef is not None or
            self.CategoryRef or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataflowType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataflowType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataflowType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataflowType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataflowType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.MetadataStructureRef is not None:
            self.MetadataStructureRef.export(outfile, level, namespace_, name_='MetadataStructureRef', pretty_print=pretty_print)
        for CategoryRef_ in self.CategoryRef:
            CategoryRef_.export(outfile, level, namespace_, name_='CategoryRef', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataflowType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MetadataStructureRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureRef=model_.MetadataStructureRefType(\n')
            self.MetadataStructureRef.exportLiteral(outfile, level, name_='MetadataStructureRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CategoryRef=[\n')
        level += 1
        for CategoryRef_ in self.CategoryRef:
            showIndent(outfile, level)
            outfile.write('model_.CategoryRefType(\n')
            CategoryRef_.exportLiteral(outfile, level, name_='CategoryRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'MetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.MetadataStructureRef = obj_
            obj_.original_tagname_ = 'MetadataStructureRef'
        elif nodeName_ == 'CategoryRef':
            obj_ = CategoryRefType.factory()
            obj_.build(child_)
            self.CategoryRef.append(obj_)
            obj_.original_tagname_ = 'CategoryRef'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class MetadataflowType


class MetadataStructureRefType(GeneratedsSuper):
    """MetadataStructureRefType provides a reference to a metadata
    structure definition. The ID must be provided, as assigned to
    the metadata structure definition by the agency whose ID is the
    value of MetadataStructureAgencyID. A version must also be
    provided."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, MetadataStructureID=None, MetadataStructureAgencyID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.MetadataStructureID = MetadataStructureID
        self.MetadataStructureAgencyID = MetadataStructureAgencyID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if MetadataStructureRefType.subclass:
            return MetadataStructureRefType.subclass(*args_, **kwargs_)
        else:
            return MetadataStructureRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_MetadataStructureID(self): return self.MetadataStructureID
    def set_MetadataStructureID(self, MetadataStructureID): self.MetadataStructureID = MetadataStructureID
    def get_MetadataStructureAgencyID(self): return self.MetadataStructureAgencyID
    def set_MetadataStructureAgencyID(self, MetadataStructureAgencyID): self.MetadataStructureAgencyID = MetadataStructureAgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.MetadataStructureID is not None or
            self.MetadataStructureAgencyID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataStructureRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStructureRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataStructureRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataStructureRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataStructureRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.MetadataStructureID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructureID>%s</%sMetadataStructureID>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructureID).encode(ExternalEncoding), input_name='MetadataStructureID'), namespace_, eol_))
        if self.MetadataStructureAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructureAgencyID>%s</%sMetadataStructureAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructureAgencyID).encode(ExternalEncoding), input_name='MetadataStructureAgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataStructureRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.MetadataStructureID is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureID=%s,\n' % quote_python(self.MetadataStructureID).encode(ExternalEncoding))
        if self.MetadataStructureAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureAgencyID=%s,\n' % quote_python(self.MetadataStructureAgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'MetadataStructureID':
            MetadataStructureID_ = child_.text
            MetadataStructureID_ = self.gds_validate_string(MetadataStructureID_, node, 'MetadataStructureID')
            self.MetadataStructureID = MetadataStructureID_
            self.validate_IDType(self.MetadataStructureID)    # validate type IDType
        elif nodeName_ == 'MetadataStructureAgencyID':
            MetadataStructureAgencyID_ = child_.text
            MetadataStructureAgencyID_ = self.gds_validate_string(MetadataStructureAgencyID_, node, 'MetadataStructureAgencyID')
            self.MetadataStructureAgencyID = MetadataStructureAgencyID_
            self.validate_IDType(self.MetadataStructureAgencyID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class MetadataStructureRefType


class CategorySchemesType(GeneratedsSuper):
    """CategorySchemesType contains one or more category schemes."""
    subclass = None
    superclass = None
    def __init__(self, CategoryScheme=None):
        self.original_tagname_ = None
        if CategoryScheme is None:
            self.CategoryScheme = []
        else:
            self.CategoryScheme = CategoryScheme
    def factory(*args_, **kwargs_):
        if CategorySchemesType.subclass:
            return CategorySchemesType.subclass(*args_, **kwargs_)
        else:
            return CategorySchemesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CategoryScheme(self): return self.CategoryScheme
    def set_CategoryScheme(self, CategoryScheme): self.CategoryScheme = CategoryScheme
    def add_CategoryScheme(self, value): self.CategoryScheme.append(value)
    def insert_CategoryScheme_at(self, index, value): self.CategoryScheme.insert(index, value)
    def replace_CategoryScheme_at(self, index, value): self.CategoryScheme[index] = value
    def hasContent_(self):
        if (
            self.CategoryScheme
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategorySchemesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategorySchemesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategorySchemesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategorySchemesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategorySchemesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CategoryScheme_ in self.CategoryScheme:
            CategoryScheme_.export(outfile, level, namespace_, name_='CategoryScheme', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategorySchemesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CategoryScheme=[\n')
        level += 1
        for CategoryScheme_ in self.CategoryScheme:
            showIndent(outfile, level)
            outfile.write('model_.CategorySchemeType(\n')
            CategoryScheme_.exportLiteral(outfile, level, name_='CategorySchemeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CategoryScheme':
            obj_ = CategorySchemeType.factory()
            obj_.build(child_)
            self.CategoryScheme.append(obj_)
            obj_.original_tagname_ = 'CategoryScheme'
# end class CategorySchemesType


class CategorySchemeType(GeneratedsSuper):
    """CategorySchemeType describes the structure of a category scheme.
    This is a simple, levelled hierarchy. The scheme itself is given
    a human-readable name (which may be in multiple language-
    specific versions), and may optionally have a human-readable
    description (also in multiple, landuage-specific versions).
    Annotations may be provided in the Annotations element. The
    Category element represents a set of nested categories which
    describe a simple classification hierarchy. The CategoryScheme
    must have an agency specified in teh agency attribute, and a
    unique ID provided for all of the category schemes of that
    agency in the id attribute. A version may also be supplied - if
    ommitted, the version is understood to be "1.0". If the isFinal
    attribute has a value of true, the category scheme is final and
    cannot be changed without versioning. All production category
    schemes must be final. The urn attribute holds a valid registry
    URN (see the SDMX Registry Specification). If the
    isExternalReference attribute has a value of true, then the uri
    attribute must have a value which provides the location of a
    valid SDMX Structure message providing full details of the
    Category Scheme. Otherwise, all details must be provided here.
    The validFrom and validTo attributes provide inclusive dates for
    providing supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, Category=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CategorySchemeType.subclass:
            return CategorySchemeType.subclass(*args_, **kwargs_)
        else:
            return CategorySchemeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Category or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategorySchemeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategorySchemeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategorySchemeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategorySchemeType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategorySchemeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategorySchemeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CategorySchemeType


class CategoryType(GeneratedsSuper):
    """The category is given a human-readable name (which may be in
    multiple language-specific versions), and may optionally have a
    human-readable description (also in multiple, landuage-specific
    versions). Annotations may be provided in the Annotations
    element. References to dataflows and metadataflows may be
    provided. The Category element represents a set of nested
    categories which are child categories. The Category must have a
    unique ID within the Category Scheme provided in the id
    attribute. A version may also be supplied - if ommitted, the
    version is understood to be "1.0". The urn attribute holds a
    valid registry URN (see the SDMX Registry Specification)."""
    subclass = None
    superclass = None
    def __init__(self, isExternalReference=None, urn=None, version=None, id=None, uri=None, Name=None, Description=None, DataflowRef=None, MetadataflowRef=None, Category=None, Annotations=None):
        self.original_tagname_ = None
        self.isExternalReference = _cast(bool, isExternalReference)
        self.urn = _cast(None, urn)
        self.version = _cast(None, version)
        self.id = _cast(None, id)
        self.uri = _cast(None, uri)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if DataflowRef is None:
            self.DataflowRef = []
        else:
            self.DataflowRef = DataflowRef
        if MetadataflowRef is None:
            self.MetadataflowRef = []
        else:
            self.MetadataflowRef = MetadataflowRef
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CategoryType.subclass:
            return CategoryType.subclass(*args_, **kwargs_)
        else:
            return CategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def add_DataflowRef(self, value): self.DataflowRef.append(value)
    def insert_DataflowRef_at(self, index, value): self.DataflowRef.insert(index, value)
    def replace_DataflowRef_at(self, index, value): self.DataflowRef[index] = value
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def add_MetadataflowRef(self, value): self.MetadataflowRef.append(value)
    def insert_MetadataflowRef_at(self, index, value): self.MetadataflowRef.insert(index, value)
    def replace_MetadataflowRef_at(self, index, value): self.MetadataflowRef[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.DataflowRef or
            self.MetadataflowRef or
            self.Category or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategoryType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategoryType'):
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for DataflowRef_ in self.DataflowRef:
            DataflowRef_.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        for MetadataflowRef_ in self.MetadataflowRef:
            MetadataflowRef_.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategoryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowRef=[\n')
        level += 1
        for DataflowRef_ in self.DataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.DataflowRefType(\n')
            DataflowRef_.exportLiteral(outfile, level, name_='DataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowRef=[\n')
        level += 1
        for MetadataflowRef_ in self.MetadataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowRefType(\n')
            MetadataflowRef_.exportLiteral(outfile, level, name_='MetadataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef.append(obj_)
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef.append(obj_)
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CategoryType


class CodeListsType(GeneratedsSuper):
    """CodelistsType contains one or more codelists. It also defines
    uniqueness constraints for codelist IDs."""
    subclass = None
    superclass = None
    def __init__(self, CodeList=None):
        self.original_tagname_ = None
        if CodeList is None:
            self.CodeList = []
        else:
            self.CodeList = CodeList
    def factory(*args_, **kwargs_):
        if CodeListsType.subclass:
            return CodeListsType.subclass(*args_, **kwargs_)
        else:
            return CodeListsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CodeList(self): return self.CodeList
    def set_CodeList(self, CodeList): self.CodeList = CodeList
    def add_CodeList(self, value): self.CodeList.append(value)
    def insert_CodeList_at(self, index, value): self.CodeList.insert(index, value)
    def replace_CodeList_at(self, index, value): self.CodeList[index] = value
    def hasContent_(self):
        if (
            self.CodeList
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodeListsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeListsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodeListsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodeListsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodeListsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for CodeList_ in self.CodeList:
            CodeList_.export(outfile, level, namespace_, name_='CodeList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodeListsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('CodeList=[\n')
        level += 1
        for CodeList_ in self.CodeList:
            showIndent(outfile, level)
            outfile.write('model_.CodeListType(\n')
            CodeList_.exportLiteral(outfile, level, name_='CodeListType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CodeList':
            obj_ = CodeListType.factory()
            obj_.build(child_)
            self.CodeList.append(obj_)
            obj_.original_tagname_ = 'CodeList'
# end class CodeListsType


class CodeListType(GeneratedsSuper):
    """CodeListType defines the contents of a codelist. This includes an
    ID, the agency which maintains the codelist, its version, and a
    URL where it is located. Elements are provided for supplying a
    name and the codes. It is acceptable to provide only the id,
    name, and uri fields at a minimum, with the uri pointing to an
    SDMX Structure message containing complete details on the
    codelist. (This is termed an "external reference".) If an
    external reference is being made, the isExternalReference
    attribute must be set to "true". The urn attribute holds a
    valiud SDMX Registry URN (see SDMX Registry Specification). The
    validFrom and validTo attributes provide inclusive dates for
    providing supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, Code=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Code is None:
            self.Code = []
        else:
            self.Code = Code
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CodeListType.subclass:
            return CodeListType.subclass(*args_, **kwargs_)
        else:
            return CodeListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Code(self): return self.Code
    def set_Code(self, Code): self.Code = Code
    def add_Code(self, value): self.Code.append(value)
    def insert_Code_at(self, index, value): self.Code.insert(index, value)
    def replace_Code_at(self, index, value): self.Code[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Code or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodeListType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodeListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodeListType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodeListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Code_ in self.Code:
            Code_.export(outfile, level, namespace_, name_='Code', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodeListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Code=[\n')
        level += 1
        for Code_ in self.Code:
            showIndent(outfile, level)
            outfile.write('model_.CodeType(\n')
            Code_.exportLiteral(outfile, level, name_='CodeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Code':
            obj_ = CodeType.factory()
            obj_.build(child_)
            self.Code.append(obj_)
            obj_.original_tagname_ = 'Code'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CodeListType


class CodeType(GeneratedsSuper):
    """CodeType defines the structure of a code. This allows for plain-text
    descriptions as element content, and the coded value as the
    value attribute. (Short descriptions or other presentational
    information may be added using Annotations with an indicative
    type field [eg, "ShortDescription"]). The urn attribute supplies
    a valid SDMX Registry URN (see the SDMX Registry
    Specification).The parentCode attribute provides the ability to
    describe simple hierarchies within a single codelist, by
    referenceing the id value of another code in the same codelist."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, parentCode=None, value=None, Description=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.parentCode = _cast(None, parentCode)
        self.value = _cast(None, value)
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CodeType.subclass:
            return CodeType.subclass(*args_, **kwargs_)
        else:
            return CodeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_parentCode(self): return self.parentCode
    def set_parentCode(self, parentCode): self.parentCode = parentCode
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (
            self.Description or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodeType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.parentCode is not None and 'parentCode' not in already_processed:
            already_processed.add('parentCode')
            outfile.write(' parentCode=%s' % (quote_attrib(self.parentCode), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (quote_attrib(self.value), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.parentCode is not None and 'parentCode' not in already_processed:
            already_processed.add('parentCode')
            showIndent(outfile, level)
            outfile.write('parentCode=%s,\n' % (self.parentCode,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%s,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('parentCode', node)
        if value is not None and 'parentCode' not in already_processed:
            already_processed.add('parentCode')
            self.parentCode = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CodeType


class HierarchicalCodelistsType(GeneratedsSuper):
    """HierarchicalCodelistsType contains one or more sets of structural
    information about the hierarchies within a codelist
    (hierarchical codelists). This corresponds to complex
    hierarchical codelists within the SDMX Information Model - very
    simple hierarchies can be described within the regular Codelist,
    using the parentCode attribute."""
    subclass = None
    superclass = None
    def __init__(self, HierarchicalCodelist=None):
        self.original_tagname_ = None
        if HierarchicalCodelist is None:
            self.HierarchicalCodelist = []
        else:
            self.HierarchicalCodelist = HierarchicalCodelist
    def factory(*args_, **kwargs_):
        if HierarchicalCodelistsType.subclass:
            return HierarchicalCodelistsType.subclass(*args_, **kwargs_)
        else:
            return HierarchicalCodelistsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_HierarchicalCodelist(self): return self.HierarchicalCodelist
    def set_HierarchicalCodelist(self, HierarchicalCodelist): self.HierarchicalCodelist = HierarchicalCodelist
    def add_HierarchicalCodelist(self, value): self.HierarchicalCodelist.append(value)
    def insert_HierarchicalCodelist_at(self, index, value): self.HierarchicalCodelist.insert(index, value)
    def replace_HierarchicalCodelist_at(self, index, value): self.HierarchicalCodelist[index] = value
    def hasContent_(self):
        if (
            self.HierarchicalCodelist
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HierarchicalCodelistsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HierarchicalCodelistsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HierarchicalCodelistsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for HierarchicalCodelist_ in self.HierarchicalCodelist:
            HierarchicalCodelist_.export(outfile, level, namespace_, name_='HierarchicalCodelist', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HierarchicalCodelistsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('HierarchicalCodelist=[\n')
        level += 1
        for HierarchicalCodelist_ in self.HierarchicalCodelist:
            showIndent(outfile, level)
            outfile.write('model_.HierarchicalCodelistType(\n')
            HierarchicalCodelist_.exportLiteral(outfile, level, name_='HierarchicalCodelistType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'HierarchicalCodelist':
            obj_ = HierarchicalCodelistType.factory()
            obj_.build(child_)
            self.HierarchicalCodelist.append(obj_)
            obj_.original_tagname_ = 'HierarchicalCodelist'
# end class HierarchicalCodelistsType


class HierarchicalCodelistType(GeneratedsSuper):
    """A hierarchical codelist references a Codelist, and supplies the
    extra structural metadata to assemble the codes into a
    hierarchy. A human-readable name must be supplied, and multiple
    language-specific variants may be provided. A longer human-
    readable description may be provided, and may also be presented
    as a set of language-specific variants. The CodelistRef element
    references a codelist, and may indicate more than one.
    Annotations may be provided in the Annotaions element. An ID
    unique for the agency specified in the agency attribute must be
    assigned, using the id attribute. A version may be provided
    using the version attribute - if no value is provided, it is
    assumed to be "1.0". A valid SDMX Registry URN may be provided
    in the urn attribute, as specified in the SDMX Registry
    Specification. If the isExternalReference attribute has a value
    of true, the uri attribute must specify the location of a valid
    SDMX Structure Message which provides the full details of the
    hierarchical codelist; otherwise, all details must be present.
    The validFrom and validTo attributes provide inclusive dates for
    providing supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, CodelistRef=None, Hierarchy=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if CodelistRef is None:
            self.CodelistRef = []
        else:
            self.CodelistRef = CodelistRef
        if Hierarchy is None:
            self.Hierarchy = []
        else:
            self.Hierarchy = Hierarchy
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if HierarchicalCodelistType.subclass:
            return HierarchicalCodelistType.subclass(*args_, **kwargs_)
        else:
            return HierarchicalCodelistType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_CodelistRef(self): return self.CodelistRef
    def set_CodelistRef(self, CodelistRef): self.CodelistRef = CodelistRef
    def add_CodelistRef(self, value): self.CodelistRef.append(value)
    def insert_CodelistRef_at(self, index, value): self.CodelistRef.insert(index, value)
    def replace_CodelistRef_at(self, index, value): self.CodelistRef[index] = value
    def get_Hierarchy(self): return self.Hierarchy
    def set_Hierarchy(self, Hierarchy): self.Hierarchy = Hierarchy
    def add_Hierarchy(self, value): self.Hierarchy.append(value)
    def insert_Hierarchy_at(self, index, value): self.Hierarchy.insert(index, value)
    def replace_Hierarchy_at(self, index, value): self.Hierarchy[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.CodelistRef or
            self.Hierarchy or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HierarchicalCodelistType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HierarchicalCodelistType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HierarchicalCodelistType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for CodelistRef_ in self.CodelistRef:
            CodelistRef_.export(outfile, level, namespace_, name_='CodelistRef', pretty_print=pretty_print)
        for Hierarchy_ in self.Hierarchy:
            Hierarchy_.export(outfile, level, namespace_, name_='Hierarchy', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HierarchicalCodelistType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodelistRef=[\n')
        level += 1
        for CodelistRef_ in self.CodelistRef:
            showIndent(outfile, level)
            outfile.write('model_.CodelistRefType(\n')
            CodelistRef_.exportLiteral(outfile, level, name_='CodelistRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Hierarchy=[\n')
        level += 1
        for Hierarchy_ in self.Hierarchy:
            showIndent(outfile, level)
            outfile.write('model_.HierarchyType(\n')
            Hierarchy_.exportLiteral(outfile, level, name_='HierarchyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'CodelistRef':
            obj_ = CodelistRefType.factory()
            obj_.build(child_)
            self.CodelistRef.append(obj_)
            obj_.original_tagname_ = 'CodelistRef'
        elif nodeName_ == 'Hierarchy':
            obj_ = HierarchyType.factory()
            obj_.build(child_)
            self.Hierarchy.append(obj_)
            obj_.original_tagname_ = 'Hierarchy'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class HierarchicalCodelistType


class HierarchyType(GeneratedsSuper):
    """The recursive CodeRef element is used to assemble the codes in the
    codelist(s) referenced by the parent hierarchical codelist into
    a hierarchy. The Level element is used to describe the levels of
    a levelled hierarchy, which may be referenced from each of the
    CodeRefs in the Hierarchy. A human-readable name must be
    assigned, which may be provided in multiple, parallel-language
    versions. A longer, human-readable Description may also be
    provided, which can also have multiple parallel-language
    versions. Annotations may be provided with the Annotations
    element. The id attribute provides a unique id for the
    hierarchy. The urn attribute can be used to specify the
    hierarchy with a valid SDMX Registry URN (see the SDMX Registry
    Specification). The version attribute specifies a version
    (understood to be "1.0" if not specified), and isFinal, once
    given a value of true, indicates that nothing may be changed
    without also changing the version number. validFrom and validTo
    are inclusive dates indicating the relevant period of the
    hierarchy."""
    subclass = None
    superclass = None
    def __init__(self, isFinal=None, urn=None, id=None, version=None, validFrom=None, validTo=None, Name=None, Description=None, CodeRef=None, Level=None, Annotations=None):
        self.original_tagname_ = None
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.id = _cast(None, id)
        self.version = _cast(None, version)
        self.validFrom = _cast(None, validFrom)
        self.validTo = _cast(None, validTo)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if CodeRef is None:
            self.CodeRef = []
        else:
            self.CodeRef = CodeRef
        if Level is None:
            self.Level = []
        else:
            self.Level = Level
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if HierarchyType.subclass:
            return HierarchyType.subclass(*args_, **kwargs_)
        else:
            return HierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_CodeRef(self): return self.CodeRef
    def set_CodeRef(self, CodeRef): self.CodeRef = CodeRef
    def add_CodeRef(self, value): self.CodeRef.append(value)
    def insert_CodeRef_at(self, index, value): self.CodeRef.insert(index, value)
    def replace_CodeRef_at(self, index, value): self.CodeRef[index] = value
    def get_Level(self): return self.Level
    def set_Level(self, Level): self.Level = Level
    def add_Level(self, value): self.Level.append(value)
    def insert_Level_at(self, index, value): self.Level.insert(index, value)
    def replace_Level_at(self, index, value): self.Level[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.CodeRef or
            self.Level or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HierarchyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HierarchyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HierarchyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HierarchyType'):
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='HierarchyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for CodeRef_ in self.CodeRef:
            CodeRef_.export(outfile, level, namespace_, name_='CodeRef', pretty_print=pretty_print)
        for Level_ in self.Level:
            Level_.export(outfile, level, namespace_, name_='Level', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='HierarchyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodeRef=[\n')
        level += 1
        for CodeRef_ in self.CodeRef:
            showIndent(outfile, level)
            outfile.write('model_.CodeRefType(\n')
            CodeRef_.exportLiteral(outfile, level, name_='CodeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Level=[\n')
        level += 1
        for Level_ in self.Level:
            showIndent(outfile, level)
            outfile.write('model_.LevelType(\n')
            Level_.exportLiteral(outfile, level, name_='LevelType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'CodeRef':
            obj_ = CodeRefType.factory()
            obj_.build(child_)
            self.CodeRef.append(obj_)
            obj_.original_tagname_ = 'CodeRef'
        elif nodeName_ == 'Level':
            obj_ = LevelType.factory()
            obj_.build(child_)
            self.Level.append(obj_)
            obj_.original_tagname_ = 'Level'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class HierarchyType


class LevelType(GeneratedsSuper):
    """LevelType describes a level in a hierarchical codelist. The Order
    element specifies where the level is in a levelled hierarchy,
    starting with the value "1" for the top level, and going
    sequentially from there using whole integers. CodingType
    specifies the text formatting of the codes at that level. A
    human-readable name must be assigned, which may be provided in
    multiple, parallel-language versions. A longer, human-readable
    Description may also be provided, which can also have multiple
    parallel-language versions. Annotations may be provided with the
    Annotations element. The id attribute provides a unique id for
    the hierarchy. The urn attribute can be used to specify the
    hierarchy with a valid SDMX Registry URN (see the SDMX Registry
    Specification)."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, id=None, Name=None, Description=None, Order=None, CodingType=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Order = Order
        self.CodingType = CodingType
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if LevelType.subclass:
            return LevelType.subclass(*args_, **kwargs_)
        else:
            return LevelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Order(self): return self.Order
    def set_Order(self, Order): self.Order = Order
    def get_CodingType(self): return self.CodingType
    def set_CodingType(self, CodingType): self.CodingType = CodingType
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Order is not None or
            self.CodingType is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='LevelType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LevelType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='LevelType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='LevelType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='LevelType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Order is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrder>%s</%sOrder>%s' % (namespace_, self.gds_format_integer(self.Order, input_name='Order'), namespace_, eol_))
        if self.CodingType is not None:
            self.CodingType.export(outfile, level, namespace_, name_='CodingType', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LevelType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Order is not None:
            showIndent(outfile, level)
            outfile.write('Order=%d,\n' % self.Order)
        if self.CodingType is not None:
            showIndent(outfile, level)
            outfile.write('CodingType=model_.TextFormatType(\n')
            self.CodingType.exportLiteral(outfile, level, name_='CodingType')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Order':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'Order')
            self.Order = ival_
        elif nodeName_ == 'CodingType':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.CodingType = obj_
            obj_.original_tagname_ = 'CodingType'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class LevelType


class CodelistRefType(GeneratedsSuper):
    """The CodelistRefType provides the structure for a codelist reference.
    (Note that this is structured differently than a similarly-named
    type in the Registry namespace.) At a minimum, either: AgencyID
    has the ID of an agency as a value; CodelistID takes the ID of a
    codelist maintained by that agency; and Version specifies the
    version of the codelist; or URN supplies a valid SDMX Registry
    URN (see the SDMX Registry Specification). Alias is used to
    carry the identifier for the referenced codelist, so that codes
    from that list can be easily referenced by the CodeRefs
    contained in the parent Hierarchy, without having to repeat the
    agency and version for each reference. The Alias must be unique
    within the parent Hierarchical Codelist."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, CodelistID=None, Version=None, Alias=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.CodelistID = CodelistID
        self.Version = Version
        self.Alias = Alias
    def factory(*args_, **kwargs_):
        if CodelistRefType.subclass:
            return CodelistRefType.subclass(*args_, **kwargs_)
        else:
            return CodelistRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_CodelistID(self): return self.CodelistID
    def set_CodelistID(self, CodelistID): self.CodelistID = CodelistID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Alias(self): return self.Alias
    def set_Alias(self, Alias): self.Alias = Alias
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.CodelistID is not None or
            self.Version is not None or
            self.Alias is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodelistRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodelistRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodelistRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodelistRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodelistRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.CodelistID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodelistID>%s</%sCodelistID>%s' % (namespace_, self.gds_format_string(quote_xml(self.CodelistID).encode(ExternalEncoding), input_name='CodelistID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Alias is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAlias>%s</%sAlias>%s' % (namespace_, self.gds_format_string(quote_xml(self.Alias).encode(ExternalEncoding), input_name='Alias'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CodelistRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.CodelistID is not None:
            showIndent(outfile, level)
            outfile.write('CodelistID=%s,\n' % quote_python(self.CodelistID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Alias is not None:
            showIndent(outfile, level)
            outfile.write('Alias=%s,\n' % quote_python(self.Alias).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'CodelistID':
            CodelistID_ = child_.text
            CodelistID_ = self.gds_validate_string(CodelistID_, node, 'CodelistID')
            self.CodelistID = CodelistID_
            self.validate_IDType(self.CodelistID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Alias':
            Alias_ = child_.text
            Alias_ = self.gds_validate_string(Alias_, node, 'Alias')
            self.Alias = Alias_
            self.validate_IDType(self.Alias)    # validate type IDType
# end class CodelistRefType


class CodeRefType(GeneratedsSuper):
    """The CodeRefType provides the structure for a codelist reference. At
    a minimum, either a URN value (a valid SDMX Registry URN as
    specified in teh SDMX Registry Specification) must be supplied,
    or a ColdelistAliasRef and a CodeID must be specified.
    CodelistAliasRef references an alias assigned in a CodelistRef
    element in the containing hierarchical codelist.CodeRef
    references a code from the codelist identified at the level of
    the parent hierarchical codelist. Codes are arranged in a
    hierarchy by reference. Note that it is possible to reference a
    single code such that it has multiple parents within the
    hierarchy. Further, the hierarchy may or may not be a levelled
    one. CodeID holds the ID of the code in the codelist referenced
    by the hierarchical codelist. CodeRef references a code.
    LevelRef holds the id of a Level described in the same parent
    Hierarchical Codelist. NodeAliasID allows for an ID to be
    assigned to the use of the particular code at that specific
    point in the hierarchy. This value is unique within the
    hierarchy being created, and is used to map the hierarchy
    against external structures. Version holds the version number of
    the referenced code, to support management of complex
    hierarchies. Along with this field are the ValidFrom and ValidTo
    dates, which are inclusive dates during which the code is valid
    within the parent hierarchy."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, CodelistAliasRef=None, CodeID=None, CodeRef=None, LevelRef=None, NodeAliasID=None, Version=None, ValidFrom=None, ValidTo=None):
        self.original_tagname_ = None
        self.URN = URN
        self.CodelistAliasRef = CodelistAliasRef
        self.CodeID = CodeID
        if CodeRef is None:
            self.CodeRef = []
        else:
            self.CodeRef = CodeRef
        self.LevelRef = LevelRef
        self.NodeAliasID = NodeAliasID
        self.Version = Version
        self.ValidFrom = ValidFrom
        self.ValidTo = ValidTo
    def factory(*args_, **kwargs_):
        if CodeRefType.subclass:
            return CodeRefType.subclass(*args_, **kwargs_)
        else:
            return CodeRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_CodelistAliasRef(self): return self.CodelistAliasRef
    def set_CodelistAliasRef(self, CodelistAliasRef): self.CodelistAliasRef = CodelistAliasRef
    def get_CodeID(self): return self.CodeID
    def set_CodeID(self, CodeID): self.CodeID = CodeID
    def get_CodeRef(self): return self.CodeRef
    def set_CodeRef(self, CodeRef): self.CodeRef = CodeRef
    def add_CodeRef(self, value): self.CodeRef.append(value)
    def insert_CodeRef_at(self, index, value): self.CodeRef.insert(index, value)
    def replace_CodeRef_at(self, index, value): self.CodeRef[index] = value
    def get_LevelRef(self): return self.LevelRef
    def set_LevelRef(self, LevelRef): self.LevelRef = LevelRef
    def get_NodeAliasID(self): return self.NodeAliasID
    def set_NodeAliasID(self, NodeAliasID): self.NodeAliasID = NodeAliasID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_TimePeriodType(self, value):
        # Validate type TimePeriodType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.CodelistAliasRef is not None or
            self.CodeID is not None or
            self.CodeRef or
            self.LevelRef is not None or
            self.NodeAliasID is not None or
            self.Version is not None or
            self.ValidFrom is not None or
            self.ValidTo is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodeRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodeRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodeRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodeRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.CodelistAliasRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodelistAliasRef>%s</%sCodelistAliasRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.CodelistAliasRef).encode(ExternalEncoding), input_name='CodelistAliasRef'), namespace_, eol_))
        if self.CodeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeID>%s</%sCodeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.CodeID).encode(ExternalEncoding), input_name='CodeID'), namespace_, eol_))
        for CodeRef_ in self.CodeRef:
            CodeRef_.export(outfile, level, namespace_, name_='CodeRef', pretty_print=pretty_print)
        if self.LevelRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLevelRef>%s</%sLevelRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.LevelRef).encode(ExternalEncoding), input_name='LevelRef'), namespace_, eol_))
        if self.NodeAliasID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNodeAliasID>%s</%sNodeAliasID>%s' % (namespace_, self.gds_format_string(quote_xml(self.NodeAliasID).encode(ExternalEncoding), input_name='NodeAliasID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.ValidFrom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidFrom>%s</%sValidFrom>%s' % (namespace_, self.gds_format_string(quote_xml(self.ValidFrom).encode(ExternalEncoding), input_name='ValidFrom'), namespace_, eol_))
        if self.ValidTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidTo>%s</%sValidTo>%s' % (namespace_, self.gds_format_string(quote_xml(self.ValidTo).encode(ExternalEncoding), input_name='ValidTo'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CodeRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.CodelistAliasRef is not None:
            showIndent(outfile, level)
            outfile.write('CodelistAliasRef=%s,\n' % quote_python(self.CodelistAliasRef).encode(ExternalEncoding))
        if self.CodeID is not None:
            showIndent(outfile, level)
            outfile.write('CodeID=%s,\n' % quote_python(self.CodeID).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CodeRef=[\n')
        level += 1
        for CodeRef_ in self.CodeRef:
            showIndent(outfile, level)
            outfile.write('model_.CodeRefType(\n')
            CodeRef_.exportLiteral(outfile, level, name_='CodeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.LevelRef is not None:
            showIndent(outfile, level)
            outfile.write('LevelRef=%s,\n' % quote_python(self.LevelRef).encode(ExternalEncoding))
        if self.NodeAliasID is not None:
            showIndent(outfile, level)
            outfile.write('NodeAliasID=%s,\n' % quote_python(self.NodeAliasID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.ValidFrom is not None:
            showIndent(outfile, level)
            outfile.write('ValidFrom=%s,\n' % quote_python(self.ValidFrom).encode(ExternalEncoding))
        if self.ValidTo is not None:
            showIndent(outfile, level)
            outfile.write('ValidTo=%s,\n' % quote_python(self.ValidTo).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'CodelistAliasRef':
            CodelistAliasRef_ = child_.text
            CodelistAliasRef_ = self.gds_validate_string(CodelistAliasRef_, node, 'CodelistAliasRef')
            self.CodelistAliasRef = CodelistAliasRef_
            self.validate_IDType(self.CodelistAliasRef)    # validate type IDType
        elif nodeName_ == 'CodeID':
            CodeID_ = child_.text
            CodeID_ = self.gds_validate_string(CodeID_, node, 'CodeID')
            self.CodeID = CodeID_
            self.validate_IDType(self.CodeID)    # validate type IDType
        elif nodeName_ == 'CodeRef':
            obj_ = CodeRefType.factory()
            obj_.build(child_)
            self.CodeRef.append(obj_)
            obj_.original_tagname_ = 'CodeRef'
        elif nodeName_ == 'LevelRef':
            LevelRef_ = child_.text
            LevelRef_ = self.gds_validate_string(LevelRef_, node, 'LevelRef')
            self.LevelRef = LevelRef_
            self.validate_IDType(self.LevelRef)    # validate type IDType
        elif nodeName_ == 'NodeAliasID':
            NodeAliasID_ = child_.text
            NodeAliasID_ = self.gds_validate_string(NodeAliasID_, node, 'NodeAliasID')
            self.NodeAliasID = NodeAliasID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'ValidFrom':
            ValidFrom_ = child_.text
            ValidFrom_ = self.gds_validate_string(ValidFrom_, node, 'ValidFrom')
            self.ValidFrom = ValidFrom_
            self.validate_TimePeriodType(self.ValidFrom)    # validate type TimePeriodType
        elif nodeName_ == 'ValidTo':
            ValidTo_ = child_.text
            ValidTo_ = self.gds_validate_string(ValidTo_, node, 'ValidTo')
            self.ValidTo = ValidTo_
            self.validate_TimePeriodType(self.ValidTo)    # validate type TimePeriodType
# end class CodeRefType


class ConceptsType(GeneratedsSuper):
    """The ConceptsType describes an XML type which contains information
    about sets of concepts and their relationships, each of which is
    described in a ConceptScheme element. This section replaces the
    section of the version 1.0 SDMXStructure message which provides
    details about concepts. As such, it is backward-compatible, and
    may be used to contain a simple list of concepts as per the 1.0
    SDMX-ML specification."""
    subclass = None
    superclass = None
    def __init__(self, Concept=None, ConceptScheme=None, Annotations=None):
        self.original_tagname_ = None
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        if ConceptScheme is None:
            self.ConceptScheme = []
        else:
            self.ConceptScheme = ConceptScheme
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ConceptsType.subclass:
            return ConceptsType.subclass(*args_, **kwargs_)
        else:
            return ConceptsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_ConceptScheme(self): return self.ConceptScheme
    def set_ConceptScheme(self, ConceptScheme): self.ConceptScheme = ConceptScheme
    def add_ConceptScheme(self, value): self.ConceptScheme.append(value)
    def insert_ConceptScheme_at(self, index, value): self.ConceptScheme.insert(index, value)
    def replace_ConceptScheme_at(self, index, value): self.ConceptScheme[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def hasContent_(self):
        if (
            self.Concept or
            self.ConceptScheme or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Concept_ in self.Concept:
            Concept_.export(outfile, level, namespace_, name_='Concept', pretty_print=pretty_print)
        for ConceptScheme_ in self.ConceptScheme:
            ConceptScheme_.export(outfile, level, namespace_, name_='ConceptScheme', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConceptsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('model_.ConceptType(\n')
            Concept_.exportLiteral(outfile, level, name_='ConceptType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptScheme=[\n')
        level += 1
        for ConceptScheme_ in self.ConceptScheme:
            showIndent(outfile, level)
            outfile.write('model_.ConceptSchemeType(\n')
            ConceptScheme_.exportLiteral(outfile, level, name_='ConceptSchemeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Concept':
            obj_ = ConceptType.factory()
            obj_.build(child_)
            self.Concept.append(obj_)
            obj_.original_tagname_ = 'Concept'
        elif nodeName_ == 'ConceptScheme':
            obj_ = ConceptSchemeType.factory()
            obj_.build(child_)
            self.ConceptScheme.append(obj_)
            obj_.original_tagname_ = 'ConceptScheme'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ConceptsType


class ConceptType(GeneratedsSuper):
    """ConceptType specifies the information provided for a single concept.
    This includes a name, as element content, and an ID. It is
    possible to use the uri field to point to the location of an
    SDMX-ML Structure message which contains a more detailed version
    of the concept. (This is termed an "external reference".) If an
    external reference is being made, the isExternalReference
    attribute must be set to "true". In this case, all details of
    the concept are assumed to be found externally, and inline
    characteristics provided through child elements and the
    coreRepresentation and coreRepresentationAgency attributes are
    to be ignored. The coreRepresentation and
    coreRepresentationAgency attributes can identify a codelist
    which is a default representation of the concept. Uncoded
    default representations (or information about the textual
    aspects of coded default representations) can be provided with
    the TextFormat child element of the concept. Semantic
    relationships between concepts which occur within a single
    concept scheme can be captured with the parent and parentAgency
    attributes - these identify the concept of which the current
    concept is a qualification (in the ISO 11179 sense) or subclass.
    When used outside of a containing ConceptScheme, these
    attributes may be ignored. If a coreRepresentation and core
    RepresentationAgency are not provided, but are provided in the
    indicated parent, then the default representation is inherited
    from the specified parent concept. Note that all concepts within
    a concept scheme must be uniquely identified by their id - each
    concept scheme has only one agency for all its concepts. The
    agency attribute here is provided for backward-compatibility
    with version 1.0 of the standards, and it must not be used for
    concepts which are child elements of a concept scheme."""
    subclass = None
    superclass = None
    def __init__(self, parentAgency=None, coreRepresentation=None, parent=None, agencyID=None, urn=None, uri=None, version=None, isExternalReference=None, id=None, coreRepresentationAgency=None, Name=None, Description=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.parentAgency = _cast(None, parentAgency)
        self.coreRepresentation = _cast(None, coreRepresentation)
        self.parent = _cast(None, parent)
        self.agencyID = _cast(None, agencyID)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.id = _cast(None, id)
        self.coreRepresentationAgency = _cast(None, coreRepresentationAgency)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ConceptType.subclass:
            return ConceptType.subclass(*args_, **kwargs_)
        else:
            return ConceptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_parentAgency(self): return self.parentAgency
    def set_parentAgency(self, parentAgency): self.parentAgency = parentAgency
    def get_coreRepresentation(self): return self.coreRepresentation
    def set_coreRepresentation(self, coreRepresentation): self.coreRepresentation = coreRepresentation
    def get_parent(self): return self.parent
    def set_parent(self, parent): self.parent = parent
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_coreRepresentationAgency(self): return self.coreRepresentationAgency
    def set_coreRepresentationAgency(self, coreRepresentationAgency): self.coreRepresentationAgency = coreRepresentationAgency
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptType'):
        if self.parentAgency is not None and 'parentAgency' not in already_processed:
            already_processed.add('parentAgency')
            outfile.write(' parentAgency=%s' % (quote_attrib(self.parentAgency), ))
        if self.coreRepresentation is not None and 'coreRepresentation' not in already_processed:
            already_processed.add('coreRepresentation')
            outfile.write(' coreRepresentation=%s' % (quote_attrib(self.coreRepresentation), ))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            outfile.write(' parent=%s' % (quote_attrib(self.parent), ))
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.coreRepresentationAgency is not None and 'coreRepresentationAgency' not in already_processed:
            already_processed.add('coreRepresentationAgency')
            outfile.write(' coreRepresentationAgency=%s' % (quote_attrib(self.coreRepresentationAgency), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConceptType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.parentAgency is not None and 'parentAgency' not in already_processed:
            already_processed.add('parentAgency')
            showIndent(outfile, level)
            outfile.write('parentAgency=%s,\n' % (self.parentAgency,))
        if self.coreRepresentation is not None and 'coreRepresentation' not in already_processed:
            already_processed.add('coreRepresentation')
            showIndent(outfile, level)
            outfile.write('coreRepresentation=%s,\n' % (self.coreRepresentation,))
        if self.parent is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            showIndent(outfile, level)
            outfile.write('parent=%s,\n' % (self.parent,))
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.coreRepresentationAgency is not None and 'coreRepresentationAgency' not in already_processed:
            already_processed.add('coreRepresentationAgency')
            showIndent(outfile, level)
            outfile.write('coreRepresentationAgency=%s,\n' % (self.coreRepresentationAgency,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('parentAgency', node)
        if value is not None and 'parentAgency' not in already_processed:
            already_processed.add('parentAgency')
            self.parentAgency = value
        value = find_attr_value_('coreRepresentation', node)
        if value is not None and 'coreRepresentation' not in already_processed:
            already_processed.add('coreRepresentation')
            self.coreRepresentation = value
        value = find_attr_value_('parent', node)
        if value is not None and 'parent' not in already_processed:
            already_processed.add('parent')
            self.parent = value
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('coreRepresentationAgency', node)
        if value is not None and 'coreRepresentationAgency' not in already_processed:
            already_processed.add('coreRepresentationAgency')
            self.coreRepresentationAgency = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ConceptType


class ConceptSchemeType(GeneratedsSuper):
    """ConceptSchemeType describes the structure of a ConceptScheme
    element, which is the preferred form (as of version 2.0) of
    presenting the concepts used in other SDMX constructs.
    ConceptSchemes may be included inline (that is, with all details
    provided in the instance or may be referenced externally. It is
    possible to use the uri field to point to the location of an
    SDMX-ML Structure message which contains a more detailed version
    of the concept. (This is termed an "external reference".) If an
    external reference is being made, the isExternalReference
    attribute must be set to "true". A Name may be provided as a
    child element (in multiple parallel language versions) and an ID
    and version and agency information may be provided.
    ConceptSchemes represent a collection of concepts which are used
    to describe a meaningful set of distinct concepts, to be used in
    the reporting of data or metadata. The validFrom and validTo
    attributes provide inclusive dates for providing supplemental
    validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, Concept=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ConceptSchemeType.subclass:
            return ConceptSchemeType.subclass(*args_, **kwargs_)
        else:
            return ConceptSchemeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Concept or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptSchemeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptSchemeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptSchemeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptSchemeType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptSchemeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Concept_ in self.Concept:
            Concept_.export(outfile, level, namespace_, name_='Concept', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConceptSchemeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('model_.ConceptType(\n')
            Concept_.exportLiteral(outfile, level, name_='ConceptType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Concept':
            obj_ = ConceptType.factory()
            obj_.build(child_)
            self.Concept.append(obj_)
            obj_.original_tagname_ = 'Concept'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ConceptSchemeType


class MetadataStructureDefinitionsType(GeneratedsSuper):
    """MetadataStructureDefinitionsType describes one or more metadata
    structure definitions."""
    subclass = None
    superclass = None
    def __init__(self, MetadataStructureDefinition=None):
        self.original_tagname_ = None
        if MetadataStructureDefinition is None:
            self.MetadataStructureDefinition = []
        else:
            self.MetadataStructureDefinition = MetadataStructureDefinition
    def factory(*args_, **kwargs_):
        if MetadataStructureDefinitionsType.subclass:
            return MetadataStructureDefinitionsType.subclass(*args_, **kwargs_)
        else:
            return MetadataStructureDefinitionsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataStructureDefinition(self): return self.MetadataStructureDefinition
    def set_MetadataStructureDefinition(self, MetadataStructureDefinition): self.MetadataStructureDefinition = MetadataStructureDefinition
    def add_MetadataStructureDefinition(self, value): self.MetadataStructureDefinition.append(value)
    def insert_MetadataStructureDefinition_at(self, index, value): self.MetadataStructureDefinition.insert(index, value)
    def replace_MetadataStructureDefinition_at(self, index, value): self.MetadataStructureDefinition[index] = value
    def hasContent_(self):
        if (
            self.MetadataStructureDefinition
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataStructureDefinitionsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStructureDefinitionsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataStructureDefinitionsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataStructureDefinitionsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataStructureDefinitionsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetadataStructureDefinition_ in self.MetadataStructureDefinition:
            MetadataStructureDefinition_.export(outfile, level, namespace_, name_='MetadataStructureDefinition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataStructureDefinitionsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MetadataStructureDefinition=[\n')
        level += 1
        for MetadataStructureDefinition_ in self.MetadataStructureDefinition:
            showIndent(outfile, level)
            outfile.write('model_.MetadataStructureDefinitionType(\n')
            MetadataStructureDefinition_.exportLiteral(outfile, level, name_='MetadataStructureDefinitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataStructureDefinition':
            obj_ = MetadataStructureDefinitionType.factory()
            obj_.build(child_)
            self.MetadataStructureDefinition.append(obj_)
            obj_.original_tagname_ = 'MetadataStructureDefinition'
# end class MetadataStructureDefinitionsType


class MetadataStructureDefinitionType(GeneratedsSuper):
    """A metadata structure definition performs several functions: it
    groups sets of objects into "targets" against which reference
    metadata may be reported. Targets define the structure of the
    reference metadata "keys" which identify specific types of
    reported metadata, and describe the valid values for populating
    the keys. Also, metadata structure definitions provide a
    presentational organization of concepts for reporting purposes.
    The structure of a reference metadata report is derived from
    this presentational structure. Also, representations - unless
    defaults from the concepts are used - must be indicated as part
    of this presentational structure. Attributes allow the
    assignment of an ID, an agency, a version, and a uri. It is
    possible to use the uri field to point to the location of an
    SDMX-ML Structure message which contains a more detailed version
    of the metadata structure definition. (This is termed an
    "external reference".) If an external reference is being made,
    the isExternalReference attribute must be set to "true". When an
    external reference is being made, none of the child elements
    should be included. Otherwise, both TargetIdentifiers and at
    least one ReportStructure must be included. The urn attribute
    holds a valid SDMX registry URN (see the SDMX Registry
    Specification). The validFrom and validTo attributes provide
    inclusive dates for providing supplemental validity information
    about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, TargetIdentifiers=None, ReportStructure=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.TargetIdentifiers = TargetIdentifiers
        if ReportStructure is None:
            self.ReportStructure = []
        else:
            self.ReportStructure = ReportStructure
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if MetadataStructureDefinitionType.subclass:
            return MetadataStructureDefinitionType.subclass(*args_, **kwargs_)
        else:
            return MetadataStructureDefinitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_TargetIdentifiers(self): return self.TargetIdentifiers
    def set_TargetIdentifiers(self, TargetIdentifiers): self.TargetIdentifiers = TargetIdentifiers
    def get_ReportStructure(self): return self.ReportStructure
    def set_ReportStructure(self, ReportStructure): self.ReportStructure = ReportStructure
    def add_ReportStructure(self, value): self.ReportStructure.append(value)
    def insert_ReportStructure_at(self, index, value): self.ReportStructure.insert(index, value)
    def replace_ReportStructure_at(self, index, value): self.ReportStructure[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.TargetIdentifiers is not None or
            self.ReportStructure or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataStructureDefinitionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStructureDefinitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataStructureDefinitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataStructureDefinitionType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataStructureDefinitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.TargetIdentifiers is not None:
            self.TargetIdentifiers.export(outfile, level, namespace_, name_='TargetIdentifiers', pretty_print=pretty_print)
        for ReportStructure_ in self.ReportStructure:
            ReportStructure_.export(outfile, level, namespace_, name_='ReportStructure', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataStructureDefinitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TargetIdentifiers is not None:
            showIndent(outfile, level)
            outfile.write('TargetIdentifiers=model_.TargetIdentifiersType(\n')
            self.TargetIdentifiers.exportLiteral(outfile, level, name_='TargetIdentifiers')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ReportStructure=[\n')
        level += 1
        for ReportStructure_ in self.ReportStructure:
            showIndent(outfile, level)
            outfile.write('model_.ReportStructureType(\n')
            ReportStructure_.exportLiteral(outfile, level, name_='ReportStructureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'TargetIdentifiers':
            obj_ = TargetIdentifiersType.factory()
            obj_.build(child_)
            self.TargetIdentifiers = obj_
            obj_.original_tagname_ = 'TargetIdentifiers'
        elif nodeName_ == 'ReportStructure':
            obj_ = ReportStructureType.factory()
            obj_.build(child_)
            self.ReportStructure.append(obj_)
            obj_.original_tagname_ = 'ReportStructure'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class MetadataStructureDefinitionType


class TargetIdentifiersType(GeneratedsSuper):
    """TargetIdentifiers are the set of objects against which reference
    metadata is reported (data providers, data flows, data or
    metadata structures, etc.). There are two types of
    TargetIdentifiers: the "full" target identifier, which lists
    every object used to attach metadata to in the metadata
    structure definition, and the partial target identifiers, which
    indicate sub-sets of those concepts against which reference
    metadata may be reported. It is sometimes the case that metadata
    will also be reported against the full target identifier. An
    example of this is as follows: we might wish to collect some
    metadata concepts such as contact information for some of the
    objects described by the SDMX Information Model - for each
    instance of a metadata flow or a data provider, for example. Our
    concepts would be the concepts associated with contact
    information: CONTACT_NAME, CONTACT_PHONE_NUMBER, etc. We would
    determine how these concepts are associated with the objects in
    the model: do we want a contact for each data provider broken
    out by data flow? Or do we want only a single contact reported
    for each data provider (who might provide several data flows)?
    Each object or combination of objects we need to have metadata
    reported for becomes a partial target identifier, unless it
    happens to contain the full target identifier, in which case we
    use that instead. Thus, our valid partial target identifiers
    here would be "data flow" and "data provider", because "data
    flow by data provider" is a full target identifier. For each
    target identifier, we could have some set of our concepts
    reported."""
    subclass = None
    superclass = None
    def __init__(self, FullTargetIdentifier=None, PartialTargetIdentifier=None, Annotations=None):
        self.original_tagname_ = None
        self.FullTargetIdentifier = FullTargetIdentifier
        if PartialTargetIdentifier is None:
            self.PartialTargetIdentifier = []
        else:
            self.PartialTargetIdentifier = PartialTargetIdentifier
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if TargetIdentifiersType.subclass:
            return TargetIdentifiersType.subclass(*args_, **kwargs_)
        else:
            return TargetIdentifiersType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FullTargetIdentifier(self): return self.FullTargetIdentifier
    def set_FullTargetIdentifier(self, FullTargetIdentifier): self.FullTargetIdentifier = FullTargetIdentifier
    def get_PartialTargetIdentifier(self): return self.PartialTargetIdentifier
    def set_PartialTargetIdentifier(self, PartialTargetIdentifier): self.PartialTargetIdentifier = PartialTargetIdentifier
    def add_PartialTargetIdentifier(self, value): self.PartialTargetIdentifier.append(value)
    def insert_PartialTargetIdentifier_at(self, index, value): self.PartialTargetIdentifier.insert(index, value)
    def replace_PartialTargetIdentifier_at(self, index, value): self.PartialTargetIdentifier[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def hasContent_(self):
        if (
            self.FullTargetIdentifier is not None or
            self.PartialTargetIdentifier or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TargetIdentifiersType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetIdentifiersType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TargetIdentifiersType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TargetIdentifiersType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='TargetIdentifiersType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FullTargetIdentifier is not None:
            self.FullTargetIdentifier.export(outfile, level, namespace_, name_='FullTargetIdentifier', pretty_print=pretty_print)
        for PartialTargetIdentifier_ in self.PartialTargetIdentifier:
            PartialTargetIdentifier_.export(outfile, level, namespace_, name_='PartialTargetIdentifier', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TargetIdentifiersType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FullTargetIdentifier is not None:
            showIndent(outfile, level)
            outfile.write('FullTargetIdentifier=model_.FullTargetIdentifierType(\n')
            self.FullTargetIdentifier.exportLiteral(outfile, level, name_='FullTargetIdentifier')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('PartialTargetIdentifier=[\n')
        level += 1
        for PartialTargetIdentifier_ in self.PartialTargetIdentifier:
            showIndent(outfile, level)
            outfile.write('model_.PartialTargetIdentifierType(\n')
            PartialTargetIdentifier_.exportLiteral(outfile, level, name_='PartialTargetIdentifierType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FullTargetIdentifier':
            obj_ = FullTargetIdentifierType.factory()
            obj_.build(child_)
            self.FullTargetIdentifier = obj_
            obj_.original_tagname_ = 'FullTargetIdentifier'
        elif nodeName_ == 'PartialTargetIdentifier':
            obj_ = PartialTargetIdentifierType.factory()
            obj_.build(child_)
            self.PartialTargetIdentifier.append(obj_)
            obj_.original_tagname_ = 'PartialTargetIdentifier'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class TargetIdentifiersType


class FullTargetIdentifierType(GeneratedsSuper):
    """The full target identifier provides details on all of the objects
    against which metadata can be reported. The full target
    identifier is made up of a set of identifier components - each
    getting its own child element - which are similar to the
    dimensions of a key family: each one indicates that a value will
    be provided by the metadata reporter to identify and describe
    the metadata being reported. A human-readable name must be
    provided, which may be provided in multiple, parallel-language
    versions. A longer, human-readable name may also be provided in
    multiple, language-parallel versions. Annotations may be
    provided."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, id=None, uri=None, Name=None, Description=None, IdentifierComponent=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.id = _cast(None, id)
        self.uri = _cast(None, uri)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if IdentifierComponent is None:
            self.IdentifierComponent = []
        else:
            self.IdentifierComponent = IdentifierComponent
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if FullTargetIdentifierType.subclass:
            return FullTargetIdentifierType.subclass(*args_, **kwargs_)
        else:
            return FullTargetIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_IdentifierComponent(self): return self.IdentifierComponent
    def set_IdentifierComponent(self, IdentifierComponent): self.IdentifierComponent = IdentifierComponent
    def add_IdentifierComponent(self, value): self.IdentifierComponent.append(value)
    def insert_IdentifierComponent_at(self, index, value): self.IdentifierComponent.insert(index, value)
    def replace_IdentifierComponent_at(self, index, value): self.IdentifierComponent[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.IdentifierComponent or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='FullTargetIdentifierType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FullTargetIdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='FullTargetIdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='FullTargetIdentifierType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='FullTargetIdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for IdentifierComponent_ in self.IdentifierComponent:
            IdentifierComponent_.export(outfile, level, namespace_, name_='IdentifierComponent', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FullTargetIdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IdentifierComponent=[\n')
        level += 1
        for IdentifierComponent_ in self.IdentifierComponent:
            showIndent(outfile, level)
            outfile.write('model_.IdentifierComponentType(\n')
            IdentifierComponent_.exportLiteral(outfile, level, name_='IdentifierComponentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'IdentifierComponent':
            obj_ = IdentifierComponentType.factory()
            obj_.build(child_)
            self.IdentifierComponent.append(obj_)
            obj_.original_tagname_ = 'IdentifierComponent'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class FullTargetIdentifierType


class IdentifierComponentType(GeneratedsSuper):
    """An identifier component describes the use of an object within the
    full target identifier set. An identifier component must be one
    of the formally-recognized object classes found in the SDMX
    Information Model: the sub-element TargetObjectClass provides a
    way of indicating which objects will be used in reporting
    metadata, and will indicate how those objects are to be
    identified by the metadata reporters (which value sets will be
    allowed for each identification field for each object). The
    RepresentationScheme child element is used to indicate the valid
    range of values for the providing taget identifiers in reported
    metadata."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, id=None, uri=None, Name=None, Description=None, TargetObjectClass=None, RepresentationScheme=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.id = _cast(None, id)
        self.uri = _cast(None, uri)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.TargetObjectClass = TargetObjectClass
        self.RepresentationScheme = RepresentationScheme
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if IdentifierComponentType.subclass:
            return IdentifierComponentType.subclass(*args_, **kwargs_)
        else:
            return IdentifierComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_TargetObjectClass(self): return self.TargetObjectClass
    def set_TargetObjectClass(self, TargetObjectClass): self.TargetObjectClass = TargetObjectClass
    def get_RepresentationScheme(self): return self.RepresentationScheme
    def set_RepresentationScheme(self, RepresentationScheme): self.RepresentationScheme = RepresentationScheme
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def validate_ObjectIDType(self, value):
        # Validate type ObjectIDType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.TargetObjectClass is not None or
            self.RepresentationScheme is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='IdentifierComponentType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierComponentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='IdentifierComponentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='IdentifierComponentType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='IdentifierComponentType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.TargetObjectClass is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargetObjectClass>%s</%sTargetObjectClass>%s' % (namespace_, self.gds_format_string(quote_xml(self.TargetObjectClass).encode(ExternalEncoding), input_name='TargetObjectClass'), namespace_, eol_))
        if self.RepresentationScheme is not None:
            self.RepresentationScheme.export(outfile, level, namespace_, name_='RepresentationScheme', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IdentifierComponentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TargetObjectClass is not None:
            showIndent(outfile, level)
            outfile.write('TargetObjectClass=%s,\n' % quote_python(self.TargetObjectClass).encode(ExternalEncoding))
        if self.RepresentationScheme is not None:
            showIndent(outfile, level)
            outfile.write('RepresentationScheme=model_.RepresentationSchemeType(\n')
            self.RepresentationScheme.exportLiteral(outfile, level, name_='RepresentationScheme')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'TargetObjectClass':
            TargetObjectClass_ = child_.text
            TargetObjectClass_ = self.gds_validate_string(TargetObjectClass_, node, 'TargetObjectClass')
            self.TargetObjectClass = TargetObjectClass_
            self.validate_ObjectIDType(self.TargetObjectClass)    # validate type ObjectIDType
        elif nodeName_ == 'RepresentationScheme':
            obj_ = RepresentationSchemeType.factory()
            obj_.build(child_)
            self.RepresentationScheme = obj_
            obj_.original_tagname_ = 'RepresentationScheme'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class IdentifierComponentType


class PartialTargetIdentifierType(GeneratedsSuper):
    """Partial target identifiers are subsets of the full target
    identifier. They are themselves given an identifier, so that
    they can be referenced by the metadata attributes of a report. A
    human-readable name must be provided, which may be provided in
    multiple, parallel-language versions. A longer, human-readable
    name may also be provided in multiple, language-parallel
    versions. Annotations may be provided."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, id=None, uri=None, Name=None, Description=None, IdentifierComponentRef=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.id = _cast(None, id)
        self.uri = _cast(None, uri)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if IdentifierComponentRef is None:
            self.IdentifierComponentRef = []
        else:
            self.IdentifierComponentRef = IdentifierComponentRef
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if PartialTargetIdentifierType.subclass:
            return PartialTargetIdentifierType.subclass(*args_, **kwargs_)
        else:
            return PartialTargetIdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_IdentifierComponentRef(self): return self.IdentifierComponentRef
    def set_IdentifierComponentRef(self, IdentifierComponentRef): self.IdentifierComponentRef = IdentifierComponentRef
    def add_IdentifierComponentRef(self, value): self.IdentifierComponentRef.append(value)
    def insert_IdentifierComponentRef_at(self, index, value): self.IdentifierComponentRef.insert(index, value)
    def replace_IdentifierComponentRef_at(self, index, value): self.IdentifierComponentRef[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.IdentifierComponentRef or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='PartialTargetIdentifierType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialTargetIdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='PartialTargetIdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='PartialTargetIdentifierType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='PartialTargetIdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for IdentifierComponentRef_ in self.IdentifierComponentRef:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sIdentifierComponentRef>%s</%sIdentifierComponentRef>%s' % (namespace_, self.gds_format_string(quote_xml(IdentifierComponentRef_).encode(ExternalEncoding), input_name='IdentifierComponentRef'), namespace_, eol_))
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PartialTargetIdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('IdentifierComponentRef=[\n')
        level += 1
        for IdentifierComponentRef_ in self.IdentifierComponentRef:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(IdentifierComponentRef_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'IdentifierComponentRef':
            IdentifierComponentRef_ = child_.text
            IdentifierComponentRef_ = self.gds_validate_string(IdentifierComponentRef_, node, 'IdentifierComponentRef')
            self.IdentifierComponentRef.append(IdentifierComponentRef_)
            self.validate_IDType(self.IdentifierComponentRef)    # validate type IDType
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class PartialTargetIdentifierType


class RepresentationSchemeType(GeneratedsSuper):
    """Representation schemes indicated which values are valid for
    identifying objects within each class. For any given
    representation scheme, two IDs must be provided: the
    RepresentationScheme must have an ID as assigned to it by it
    representationSchemeAgency, whose ID must also be provided. The
    type of the representation scheme is expressed in the
    representationSchemeType attribute."""
    subclass = None
    superclass = None
    def __init__(self, representationScheme=None, representationSchemeAgency=None, representationSchemeType=None):
        self.original_tagname_ = None
        self.representationScheme = _cast(None, representationScheme)
        self.representationSchemeAgency = _cast(None, representationSchemeAgency)
        self.representationSchemeType = _cast(None, representationSchemeType)
    def factory(*args_, **kwargs_):
        if RepresentationSchemeType.subclass:
            return RepresentationSchemeType.subclass(*args_, **kwargs_)
        else:
            return RepresentationSchemeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_representationScheme(self): return self.representationScheme
    def set_representationScheme(self, representationScheme): self.representationScheme = representationScheme
    def get_representationSchemeAgency(self): return self.representationSchemeAgency
    def set_representationSchemeAgency(self, representationSchemeAgency): self.representationSchemeAgency = representationSchemeAgency
    def get_representationSchemeType(self): return self.representationSchemeType
    def set_representationSchemeType(self, representationSchemeType): self.representationSchemeType = representationSchemeType
    def validate_RepresentationSchemeTypeType(self, value):
        # Validate type RepresentationSchemeTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RepresentationSchemeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RepresentationSchemeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RepresentationSchemeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RepresentationSchemeType'):
        if self.representationScheme is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            outfile.write(' representationScheme=%s' % (quote_attrib(self.representationScheme), ))
        if self.representationSchemeAgency is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            outfile.write(' representationSchemeAgency=%s' % (quote_attrib(self.representationSchemeAgency), ))
        if self.representationSchemeType is not None and 'representationSchemeType' not in already_processed:
            already_processed.add('representationSchemeType')
            outfile.write(' representationSchemeType=%s' % (quote_attrib(self.representationSchemeType), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='RepresentationSchemeType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RepresentationSchemeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.representationScheme is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            showIndent(outfile, level)
            outfile.write('representationScheme=%s,\n' % (self.representationScheme,))
        if self.representationSchemeAgency is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            showIndent(outfile, level)
            outfile.write('representationSchemeAgency=%s,\n' % (self.representationSchemeAgency,))
        if self.representationSchemeType is not None and 'representationSchemeType' not in already_processed:
            already_processed.add('representationSchemeType')
            showIndent(outfile, level)
            outfile.write('representationSchemeType="%s",\n' % (self.representationSchemeType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representationScheme', node)
        if value is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            self.representationScheme = value
        value = find_attr_value_('representationSchemeAgency', node)
        if value is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            self.representationSchemeAgency = value
        value = find_attr_value_('representationSchemeType', node)
        if value is not None and 'representationSchemeType' not in already_processed:
            already_processed.add('representationSchemeType')
            self.representationSchemeType = value
            self.validate_RepresentationSchemeTypeType(self.representationSchemeType)    # validate type RepresentationSchemeTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RepresentationSchemeType


class ReportStructureType(GeneratedsSuper):
    """The report structure describes the presentation of the reported
    concepts, and associates them with target identifiers, full or
    partial. It can be given a name and/or annotations. It must be
    given an ID, using the id attribute, which must be unique within
    the MetadataStructureDefinition element. It contains one or more
    MetadataAttribute elements, each of which may either hold a
    value, or may have subordinate MetadataAttribute elements. The
    target attribute holds the ID of a full or partial identifier,
    which is the identifier of the target against which the metadata
    attributes are reported."""
    subclass = None
    superclass = None
    def __init__(self, urn=None, target=None, id=None, uri=None, Name=None, Description=None, MetadataAttribute=None, Annotations=None):
        self.original_tagname_ = None
        self.urn = _cast(None, urn)
        self.target = _cast(None, target)
        self.id = _cast(None, id)
        self.uri = _cast(None, uri)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if MetadataAttribute is None:
            self.MetadataAttribute = []
        else:
            self.MetadataAttribute = MetadataAttribute
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ReportStructureType.subclass:
            return ReportStructureType.subclass(*args_, **kwargs_)
        else:
            return ReportStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_MetadataAttribute(self): return self.MetadataAttribute
    def set_MetadataAttribute(self, MetadataAttribute): self.MetadataAttribute = MetadataAttribute
    def add_MetadataAttribute(self, value): self.MetadataAttribute.append(value)
    def insert_MetadataAttribute_at(self, index, value): self.MetadataAttribute.insert(index, value)
    def replace_MetadataAttribute_at(self, index, value): self.MetadataAttribute[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.MetadataAttribute or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportStructureType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportStructureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportStructureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportStructureType'):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            outfile.write(' target=%s' % (quote_attrib(self.target), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportStructureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for MetadataAttribute_ in self.MetadataAttribute:
            MetadataAttribute_.export(outfile, level, namespace_, name_='MetadataAttribute', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReportStructureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.target is not None and 'target' not in already_processed:
            already_processed.add('target')
            showIndent(outfile, level)
            outfile.write('target=%s,\n' % (self.target,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataAttribute=[\n')
        level += 1
        for MetadataAttribute_ in self.MetadataAttribute:
            showIndent(outfile, level)
            outfile.write('model_.MetadataAttributeType(\n')
            MetadataAttribute_.exportLiteral(outfile, level, name_='MetadataAttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.add('target')
            self.target = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'MetadataAttribute':
            obj_ = MetadataAttributeType.factory()
            obj_.build(child_)
            self.MetadataAttribute.append(obj_)
            obj_.original_tagname_ = 'MetadataAttribute'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ReportStructureType


class MetadataAttributeType(GeneratedsSuper):
    """Metadata attributes are those concepts - whether taking a coded or
    uncoded value, or made up of child concepts, or both - which are
    reported against a full or partial target identifier. If there
    are nested metadata attributes, these concepts are subordinate
    to the parent metadata attribute - that is, for the purposes of
    presentation, the parent concept is made up of the child
    concepts. This hierarchy is strictly presentational, for the
    purposes of structuring reports. If the metadata attribute can
    have a coded or uncoded value, then the charateristics of the
    value are indicated with the TextFormat child element. If the
    value is coded, then the representationScheme and
    representationSchemeAgency attributes must hold values: the
    representationScheme attribute takes the ID of a representation
    scheme, and the representationSchemeAgency takes the ID of the
    agency which maintains that scheme. The conceptRef attribute
    holds the ID of the metadata attribute's concept. The
    conceptAgency attribute takes the agency ID of the concept
    referenced in conceptRef. The conceptSchemeRef attribute holds
    the ID value of the concept scheme from which the concept is
    taken, and the conceptSchemeAgency holds the ID of the agency
    that maintains the concept scheme referenced in the
    conceptSchemeRef attribute. The useageStatus attribute indicates
    whether provision of the metadata attribute is conditional or
    mandatory."""
    subclass = None
    superclass = None
    def __init__(self, conceptSchemeAgency=None, representationSchemeAgency=None, usageStatus=None, conceptRef=None, representationScheme=None, conceptAgency=None, conceptSchemeRef=None, conceptVersion=None, MetadataAttribute=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.representationSchemeAgency = _cast(None, representationSchemeAgency)
        self.usageStatus = _cast(None, usageStatus)
        self.conceptRef = _cast(None, conceptRef)
        self.representationScheme = _cast(None, representationScheme)
        self.conceptAgency = _cast(None, conceptAgency)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        if MetadataAttribute is None:
            self.MetadataAttribute = []
        else:
            self.MetadataAttribute = MetadataAttribute
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if MetadataAttributeType.subclass:
            return MetadataAttributeType.subclass(*args_, **kwargs_)
        else:
            return MetadataAttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataAttribute(self): return self.MetadataAttribute
    def set_MetadataAttribute(self, MetadataAttribute): self.MetadataAttribute = MetadataAttribute
    def add_MetadataAttribute(self, value): self.MetadataAttribute.append(value)
    def insert_MetadataAttribute_at(self, index, value): self.MetadataAttribute.insert(index, value)
    def replace_MetadataAttribute_at(self, index, value): self.MetadataAttribute[index] = value
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_representationSchemeAgency(self): return self.representationSchemeAgency
    def set_representationSchemeAgency(self, representationSchemeAgency): self.representationSchemeAgency = representationSchemeAgency
    def get_usageStatus(self): return self.usageStatus
    def set_usageStatus(self, usageStatus): self.usageStatus = usageStatus
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_representationScheme(self): return self.representationScheme
    def set_representationScheme(self, representationScheme): self.representationScheme = representationScheme
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def validate_UsageStatusType(self, value):
        # Validate type UsageStatusType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.MetadataAttribute or
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataAttributeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataAttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataAttributeType'):
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.representationSchemeAgency is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            outfile.write(' representationSchemeAgency=%s' % (quote_attrib(self.representationSchemeAgency), ))
        if self.usageStatus is not None and 'usageStatus' not in already_processed:
            already_processed.add('usageStatus')
            outfile.write(' usageStatus=%s' % (quote_attrib(self.usageStatus), ))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.representationScheme is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            outfile.write(' representationScheme=%s' % (quote_attrib(self.representationScheme), ))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataAttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MetadataAttribute_ in self.MetadataAttribute:
            MetadataAttribute_.export(outfile, level, namespace_, name_='MetadataAttribute', pretty_print=pretty_print)
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataAttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.representationSchemeAgency is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            showIndent(outfile, level)
            outfile.write('representationSchemeAgency=%s,\n' % (self.representationSchemeAgency,))
        if self.usageStatus is not None and 'usageStatus' not in already_processed:
            already_processed.add('usageStatus')
            showIndent(outfile, level)
            outfile.write('usageStatus="%s",\n' % (self.usageStatus,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.representationScheme is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            showIndent(outfile, level)
            outfile.write('representationScheme=%s,\n' % (self.representationScheme,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MetadataAttribute=[\n')
        level += 1
        for MetadataAttribute_ in self.MetadataAttribute:
            showIndent(outfile, level)
            outfile.write('model_.MetadataAttributeType(\n')
            MetadataAttribute_.exportLiteral(outfile, level, name_='MetadataAttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('representationSchemeAgency', node)
        if value is not None and 'representationSchemeAgency' not in already_processed:
            already_processed.add('representationSchemeAgency')
            self.representationSchemeAgency = value
        value = find_attr_value_('usageStatus', node)
        if value is not None and 'usageStatus' not in already_processed:
            already_processed.add('usageStatus')
            self.usageStatus = value
            self.validate_UsageStatusType(self.usageStatus)    # validate type UsageStatusType
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('representationScheme', node)
        if value is not None and 'representationScheme' not in already_processed:
            already_processed.add('representationScheme')
            self.representationScheme = value
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataAttribute':
            obj_ = MetadataAttributeType.factory()
            obj_.build(child_)
            self.MetadataAttribute.append(obj_)
            obj_.original_tagname_ = 'MetadataAttribute'
        elif nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class MetadataAttributeType


class TextFormatType(GeneratedsSuper):
    """TextFormatType defines the information for describing a text format.
    If the TextType attribute is not specified, any valid characters
    may be included in the text field. (It corresponds to the
    xs:string datatype of W3C XML Schema.) The textType attribute
    provides a description of the data type, and may place
    restrictions on the values of the other attributes, referred to
    as "facets". The isSequence attribute indicates whether the
    values are intended to be ordered, and it may work in
    combination with the interval attribute. The minLength and
    maxLength attributes specify the minimum and maximum lengths of
    the value in characters. startValue and endValue are used for
    inclusive and exclusive ranges, indicating what the bounds of
    the range are. The interval attribute specifies the permitted
    interval between two values. The timeInterval attribute
    indicates the permitted duration between two time expressions.
    The decimals attribute indicates the number of characters
    allowed after the decimal separator. The pattern attribute holds
    any regular expression permitted in the simila facet in W3C XML
    Schema."""
    subclass = None
    superclass = None
    def __init__(self, timeInterval=None, minLength=None, interval=None, isSequence=None, startValue=None, endValue=None, maxLength=None, pattern=None, decimals=None, textType=None):
        self.original_tagname_ = None
        self.timeInterval = _cast(None, timeInterval)
        self.minLength = _cast(int, minLength)
        self.interval = _cast(float, interval)
        self.isSequence = _cast(bool, isSequence)
        self.startValue = _cast(float, startValue)
        self.endValue = _cast(float, endValue)
        self.maxLength = _cast(int, maxLength)
        self.pattern = _cast(None, pattern)
        self.decimals = _cast(int, decimals)
        self.textType = _cast(None, textType)
    def factory(*args_, **kwargs_):
        if TextFormatType.subclass:
            return TextFormatType.subclass(*args_, **kwargs_)
        else:
            return TextFormatType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_timeInterval(self): return self.timeInterval
    def set_timeInterval(self, timeInterval): self.timeInterval = timeInterval
    def get_minLength(self): return self.minLength
    def set_minLength(self, minLength): self.minLength = minLength
    def get_interval(self): return self.interval
    def set_interval(self, interval): self.interval = interval
    def get_isSequence(self): return self.isSequence
    def set_isSequence(self, isSequence): self.isSequence = isSequence
    def get_startValue(self): return self.startValue
    def set_startValue(self, startValue): self.startValue = startValue
    def get_endValue(self): return self.endValue
    def set_endValue(self, endValue): self.endValue = endValue
    def get_maxLength(self): return self.maxLength
    def set_maxLength(self, maxLength): self.maxLength = maxLength
    def get_pattern(self): return self.pattern
    def set_pattern(self, pattern): self.pattern = pattern
    def get_decimals(self): return self.decimals
    def set_decimals(self, decimals): self.decimals = decimals
    def get_textType(self): return self.textType
    def set_textType(self, textType): self.textType = textType
    def validate_TextTypeType(self, value):
        # Validate type TextTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TextFormatType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextFormatType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TextFormatType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TextFormatType'):
        if self.timeInterval is not None and 'timeInterval' not in already_processed:
            already_processed.add('timeInterval')
            outfile.write(' timeInterval=%s' % (self.gds_format_string(quote_attrib(self.timeInterval).encode(ExternalEncoding), input_name='timeInterval'), ))
        if self.minLength is not None and 'minLength' not in already_processed:
            already_processed.add('minLength')
            outfile.write(' minLength="%s"' % self.gds_format_integer(self.minLength, input_name='minLength'))
        if self.interval is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            outfile.write(' interval="%s"' % self.gds_format_double(self.interval, input_name='interval'))
        if self.isSequence is not None and 'isSequence' not in already_processed:
            already_processed.add('isSequence')
            outfile.write(' isSequence="%s"' % self.gds_format_boolean(self.isSequence, input_name='isSequence'))
        if self.startValue is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            outfile.write(' startValue="%s"' % self.gds_format_double(self.startValue, input_name='startValue'))
        if self.endValue is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            outfile.write(' endValue="%s"' % self.gds_format_double(self.endValue, input_name='endValue'))
        if self.maxLength is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            outfile.write(' maxLength="%s"' % self.gds_format_integer(self.maxLength, input_name='maxLength'))
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            outfile.write(' pattern=%s' % (self.gds_format_string(quote_attrib(self.pattern).encode(ExternalEncoding), input_name='pattern'), ))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            outfile.write(' decimals="%s"' % self.gds_format_integer(self.decimals, input_name='decimals'))
        if self.textType is not None and 'textType' not in already_processed:
            already_processed.add('textType')
            outfile.write(' textType=%s' % (quote_attrib(self.textType), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='TextFormatType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TextFormatType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timeInterval is not None and 'timeInterval' not in already_processed:
            already_processed.add('timeInterval')
            showIndent(outfile, level)
            outfile.write('timeInterval="%s",\n' % (self.timeInterval,))
        if self.minLength is not None and 'minLength' not in already_processed:
            already_processed.add('minLength')
            showIndent(outfile, level)
            outfile.write('minLength=%d,\n' % (self.minLength,))
        if self.interval is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            showIndent(outfile, level)
            outfile.write('interval=%e,\n' % (self.interval,))
        if self.isSequence is not None and 'isSequence' not in already_processed:
            already_processed.add('isSequence')
            showIndent(outfile, level)
            outfile.write('isSequence=%s,\n' % (self.isSequence,))
        if self.startValue is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            showIndent(outfile, level)
            outfile.write('startValue=%e,\n' % (self.startValue,))
        if self.endValue is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            showIndent(outfile, level)
            outfile.write('endValue=%e,\n' % (self.endValue,))
        if self.maxLength is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            showIndent(outfile, level)
            outfile.write('maxLength=%d,\n' % (self.maxLength,))
        if self.pattern is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            showIndent(outfile, level)
            outfile.write('pattern="%s",\n' % (self.pattern,))
        if self.decimals is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            showIndent(outfile, level)
            outfile.write('decimals=%d,\n' % (self.decimals,))
        if self.textType is not None and 'textType' not in already_processed:
            already_processed.add('textType')
            showIndent(outfile, level)
            outfile.write('textType="%s",\n' % (self.textType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeInterval', node)
        if value is not None and 'timeInterval' not in already_processed:
            already_processed.add('timeInterval')
            self.timeInterval = value
        value = find_attr_value_('minLength', node)
        if value is not None and 'minLength' not in already_processed:
            already_processed.add('minLength')
            try:
                self.minLength = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('interval', node)
        if value is not None and 'interval' not in already_processed:
            already_processed.add('interval')
            try:
                self.interval = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (interval): %s' % exp)
        value = find_attr_value_('isSequence', node)
        if value is not None and 'isSequence' not in already_processed:
            already_processed.add('isSequence')
            if value in ('true', '1'):
                self.isSequence = True
            elif value in ('false', '0'):
                self.isSequence = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('startValue', node)
        if value is not None and 'startValue' not in already_processed:
            already_processed.add('startValue')
            try:
                self.startValue = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (startValue): %s' % exp)
        value = find_attr_value_('endValue', node)
        if value is not None and 'endValue' not in already_processed:
            already_processed.add('endValue')
            try:
                self.endValue = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (endValue): %s' % exp)
        value = find_attr_value_('maxLength', node)
        if value is not None and 'maxLength' not in already_processed:
            already_processed.add('maxLength')
            try:
                self.maxLength = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('pattern', node)
        if value is not None and 'pattern' not in already_processed:
            already_processed.add('pattern')
            self.pattern = value
        value = find_attr_value_('decimals', node)
        if value is not None and 'decimals' not in already_processed:
            already_processed.add('decimals')
            try:
                self.decimals = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('textType', node)
        if value is not None and 'textType' not in already_processed:
            already_processed.add('textType')
            self.textType = value
            self.validate_TextTypeType(self.textType)    # validate type TextTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextFormatType


class KeyFamiliesType(GeneratedsSuper):
    """KeyFamiliesType defines the structure for describing one or more key
    families. It also provides uniqueness constraints for each of
    the key family IDs."""
    subclass = None
    superclass = None
    def __init__(self, KeyFamily=None):
        self.original_tagname_ = None
        if KeyFamily is None:
            self.KeyFamily = []
        else:
            self.KeyFamily = KeyFamily
    def factory(*args_, **kwargs_):
        if KeyFamiliesType.subclass:
            return KeyFamiliesType.subclass(*args_, **kwargs_)
        else:
            return KeyFamiliesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def add_KeyFamily(self, value): self.KeyFamily.append(value)
    def insert_KeyFamily_at(self, index, value): self.KeyFamily.insert(index, value)
    def replace_KeyFamily_at(self, index, value): self.KeyFamily[index] = value
    def hasContent_(self):
        if (
            self.KeyFamily
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeyFamiliesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyFamiliesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeyFamiliesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeyFamiliesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeyFamiliesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyFamily_ in self.KeyFamily:
            KeyFamily_.export(outfile, level, namespace_, name_='KeyFamily', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='KeyFamiliesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('KeyFamily=[\n')
        level += 1
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level)
            outfile.write('model_.KeyFamilyType(\n')
            KeyFamily_.exportLiteral(outfile, level, name_='KeyFamilyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamily':
            obj_ = KeyFamilyType.factory()
            obj_.build(child_)
            self.KeyFamily.append(obj_)
            obj_.original_tagname_ = 'KeyFamily'
# end class KeyFamiliesType


class KeyFamilyType(GeneratedsSuper):
    """KeyFamilyType defines the structure of a key-family description.
    This includes the name and a set of components (attributes and
    dimensions) as element content, and an ID, agency, version, and
    the URL where located as attributes. The urn attribute holds a
    valid SDMX Registry URN, as per the SDMX Registry spec. The
    isFinal attribute, once set to true, indicates that no changes
    may be made without versioning. The validFrom and validTo
    attributes provide inclusive dates for providing supplemental
    validity information about the version. If the
    isExternalReference attribute is true, then the uri attribute
    must be provided, giving a location where a valid structure
    message can be found containing the full details of the key
    family."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, Components=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Components = Components
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if KeyFamilyType.subclass:
            return KeyFamilyType.subclass(*args_, **kwargs_)
        else:
            return KeyFamilyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Components(self): return self.Components
    def set_Components(self, Components): self.Components = Components
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Components is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeyFamilyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyFamilyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeyFamilyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeyFamilyType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeyFamilyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Components is not None:
            self.Components.export(outfile, level, namespace_, name_='Components', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='KeyFamilyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Components is not None:
            showIndent(outfile, level)
            outfile.write('Components=model_.ComponentsType(\n')
            self.Components.exportLiteral(outfile, level, name_='Components')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Components':
            obj_ = ComponentsType.factory()
            obj_.build(child_)
            self.Components = obj_
            obj_.original_tagname_ = 'Components'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class KeyFamilyType


class ComponentsType(GeneratedsSuper):
    """ComponentsType describes the dimensions, groups, attributes, and
    measures of the key family. If TimeDimension is included in the
    key family - which it must be if time series formats for the
    data (GenericData, CompactData, and UtilityData formats) are to
    be used - then there must also be a frequency dimension."""
    subclass = None
    superclass = None
    def __init__(self, Dimension=None, TimeDimension=None, Group=None, PrimaryMeasure=None, CrossSectionalMeasure=None, Attribute=None):
        self.original_tagname_ = None
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        self.TimeDimension = TimeDimension
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        self.PrimaryMeasure = PrimaryMeasure
        if CrossSectionalMeasure is None:
            self.CrossSectionalMeasure = []
        else:
            self.CrossSectionalMeasure = CrossSectionalMeasure
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
    def factory(*args_, **kwargs_):
        if ComponentsType.subclass:
            return ComponentsType.subclass(*args_, **kwargs_)
        else:
            return ComponentsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def add_Dimension(self, value): self.Dimension.append(value)
    def insert_Dimension_at(self, index, value): self.Dimension.insert(index, value)
    def replace_Dimension_at(self, index, value): self.Dimension[index] = value
    def get_TimeDimension(self): return self.TimeDimension
    def set_TimeDimension(self, TimeDimension): self.TimeDimension = TimeDimension
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group_at(self, index, value): self.Group.insert(index, value)
    def replace_Group_at(self, index, value): self.Group[index] = value
    def get_PrimaryMeasure(self): return self.PrimaryMeasure
    def set_PrimaryMeasure(self, PrimaryMeasure): self.PrimaryMeasure = PrimaryMeasure
    def get_CrossSectionalMeasure(self): return self.CrossSectionalMeasure
    def set_CrossSectionalMeasure(self, CrossSectionalMeasure): self.CrossSectionalMeasure = CrossSectionalMeasure
    def add_CrossSectionalMeasure(self, value): self.CrossSectionalMeasure.append(value)
    def insert_CrossSectionalMeasure_at(self, index, value): self.CrossSectionalMeasure.insert(index, value)
    def replace_CrossSectionalMeasure_at(self, index, value): self.CrossSectionalMeasure[index] = value
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute_at(self, index, value): self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value): self.Attribute[index] = value
    def hasContent_(self):
        if (
            self.Dimension or
            self.TimeDimension is not None or
            self.Group or
            self.PrimaryMeasure is not None or
            self.CrossSectionalMeasure or
            self.Attribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ComponentsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComponentsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ComponentsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ComponentsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ComponentsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Dimension_ in self.Dimension:
            Dimension_.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        if self.TimeDimension is not None:
            self.TimeDimension.export(outfile, level, namespace_, name_='TimeDimension', pretty_print=pretty_print)
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group', pretty_print=pretty_print)
        if self.PrimaryMeasure is not None:
            self.PrimaryMeasure.export(outfile, level, namespace_, name_='PrimaryMeasure', pretty_print=pretty_print)
        for CrossSectionalMeasure_ in self.CrossSectionalMeasure:
            CrossSectionalMeasure_.export(outfile, level, namespace_, name_='CrossSectionalMeasure', pretty_print=pretty_print)
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ComponentsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Dimension=[\n')
        level += 1
        for Dimension_ in self.Dimension:
            showIndent(outfile, level)
            outfile.write('model_.DimensionType(\n')
            Dimension_.exportLiteral(outfile, level, name_='DimensionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.TimeDimension is not None:
            showIndent(outfile, level)
            outfile.write('TimeDimension=model_.TimeDimensionType(\n')
            self.TimeDimension.exportLiteral(outfile, level, name_='TimeDimension')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PrimaryMeasure is not None:
            showIndent(outfile, level)
            outfile.write('PrimaryMeasure=model_.PrimaryMeasureType(\n')
            self.PrimaryMeasure.exportLiteral(outfile, level, name_='PrimaryMeasure')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CrossSectionalMeasure=[\n')
        level += 1
        for CrossSectionalMeasure_ in self.CrossSectionalMeasure:
            showIndent(outfile, level)
            outfile.write('model_.CrossSectionalMeasureType(\n')
            CrossSectionalMeasure_.exportLiteral(outfile, level, name_='CrossSectionalMeasureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            Attribute_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension.append(obj_)
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'TimeDimension':
            obj_ = TimeDimensionType.factory()
            obj_.build(child_)
            self.TimeDimension = obj_
            obj_.original_tagname_ = 'TimeDimension'
        elif nodeName_ == 'Group':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Group> element')
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
        elif nodeName_ == 'PrimaryMeasure':
            obj_ = PrimaryMeasureType.factory()
            obj_.build(child_)
            self.PrimaryMeasure = obj_
            obj_.original_tagname_ = 'PrimaryMeasure'
        elif nodeName_ == 'CrossSectionalMeasure':
            obj_ = CrossSectionalMeasureType.factory()
            obj_.build(child_)
            self.CrossSectionalMeasure.append(obj_)
            obj_.original_tagname_ = 'CrossSectionalMeasure'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
# end class ComponentsType


class DimensionType(GeneratedsSuper):
    """DimensionType describes the structure of non-Time dimensions. The
    order of their declaration is significant: it is used to
    describe the order in which they will appear in data formats for
    which key values are supplied in an ordered fashion (exclusive
    of the Time dimension, which is not represented as a member of
    the ordered key). Some types of non-Time dimensions have un-
    coded values: the TextFormat element must be provided, to
    indicate what type of values are permissible. The attributes
    isFrequencyDimension and isEntityDimension may have a "true"
    value for any instance of the Dimension element, indicating that
    it is a dimension of the stated type. The attributes
    isCountDimension, isNonObservationalTimeDimension,
    isMeasureDimension, and is IdentityDimension may occur multiple
    times, and take a true value to indicate that the diemsnion in
    question is of that type. Note that only one dimension in the
    key family may be of the following types: Frequency dimension
    and Entity dimension, and only if there is not also an attribute
    in the key family of the same type. Any given dimension may only
    have a true value for one of the set of attributes
    isFrequencyDimension, isCountDimension, is measureDimension,
    isEntityDimension, isNonObservationalTimeDimension, and is
    IdentityDimension. The definitions and limits on representation
    of each dimension type are as follows: Frequency dimension
    describes the period between observations, and is coded; Count
    dimensions are represented by values which are sequential,
    incrementing numbers - representations are always of the
    Increment or Count type; measureType dimensions are always
    coded, and they enumerate the set of possible measures declared
    for the key family; Entity dimensions describe the subject of
    the data set (ie, a country) - they can be coded or represented
    in any other form; Non-Observational Time dimensions must have a
    representation which contains a time; Identity dimensions may be
    coded or uncoded, but must be represented by a scheme which
    refers to the identifiers of external entites. (Conventionally,
    it is the first dimension in the ordered set of dimensions - the
    key.) If a key family describes cross-sectional data, then for
    each dimension, the crossSectionalAttachDataSet,
    crossSectionalAttachGroup, crossSectionalAttachSection, and
    crossSectionalAttachObservation attributes must be given values.
    A value of "true" for any of these attributes indicates that the
    dimension may be provided a value at the indicated level within
    the cross-sectional structure. Note that these attributes do not
    need to be provided for any dimension with the
    isFrequencyDimension set to "true", as these dimensions are
    always attached only at the group level, as is time. A key
    family designed for cross-sectional use must be structured such
    that any observation's complete key can be unambiguously
    described by taking each dimension value from its observation
    level, section level, group level, and data set level, and
    ordered according to the sequence given in the key family. For
    any dimension, the id of the referenced concept must be unique
    acrss the entire key family, including all dimensions,
    attributes and measures."""
    subclass = None
    superclass = None
    def __init__(self, crossSectionalAttachDataSet=None, codelist=None, isEntityDimension=False, isFrequencyDimension=False, conceptSchemeAgency=None, codelistAgency=None, isCountDimension=False, crossSectionalAttachSection=None, isMeasureDimension=False, conceptRef=None, isNonObservationTimeDimension=False, conceptAgency=None, isIdentityDimension=False, codelistVersion=None, crossSectionalAttachObservation=None, conceptSchemeRef=None, conceptVersion=None, crossSectionalAttachGroup=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.crossSectionalAttachDataSet = _cast(bool, crossSectionalAttachDataSet)
        self.codelist = _cast(None, codelist)
        self.isEntityDimension = _cast(bool, isEntityDimension)
        self.isFrequencyDimension = _cast(bool, isFrequencyDimension)
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.codelistAgency = _cast(None, codelistAgency)
        self.isCountDimension = _cast(bool, isCountDimension)
        self.crossSectionalAttachSection = _cast(bool, crossSectionalAttachSection)
        self.isMeasureDimension = _cast(bool, isMeasureDimension)
        self.conceptRef = _cast(None, conceptRef)
        self.isNonObservationTimeDimension = _cast(bool, isNonObservationTimeDimension)
        self.conceptAgency = _cast(None, conceptAgency)
        self.isIdentityDimension = _cast(bool, isIdentityDimension)
        self.codelistVersion = _cast(None, codelistVersion)
        self.crossSectionalAttachObservation = _cast(bool, crossSectionalAttachObservation)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        self.crossSectionalAttachGroup = _cast(bool, crossSectionalAttachGroup)
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if DimensionType.subclass:
            return DimensionType.subclass(*args_, **kwargs_)
        else:
            return DimensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_crossSectionalAttachDataSet(self): return self.crossSectionalAttachDataSet
    def set_crossSectionalAttachDataSet(self, crossSectionalAttachDataSet): self.crossSectionalAttachDataSet = crossSectionalAttachDataSet
    def get_codelist(self): return self.codelist
    def set_codelist(self, codelist): self.codelist = codelist
    def get_isEntityDimension(self): return self.isEntityDimension
    def set_isEntityDimension(self, isEntityDimension): self.isEntityDimension = isEntityDimension
    def get_isFrequencyDimension(self): return self.isFrequencyDimension
    def set_isFrequencyDimension(self, isFrequencyDimension): self.isFrequencyDimension = isFrequencyDimension
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_codelistAgency(self): return self.codelistAgency
    def set_codelistAgency(self, codelistAgency): self.codelistAgency = codelistAgency
    def get_isCountDimension(self): return self.isCountDimension
    def set_isCountDimension(self, isCountDimension): self.isCountDimension = isCountDimension
    def get_crossSectionalAttachSection(self): return self.crossSectionalAttachSection
    def set_crossSectionalAttachSection(self, crossSectionalAttachSection): self.crossSectionalAttachSection = crossSectionalAttachSection
    def get_isMeasureDimension(self): return self.isMeasureDimension
    def set_isMeasureDimension(self, isMeasureDimension): self.isMeasureDimension = isMeasureDimension
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_isNonObservationTimeDimension(self): return self.isNonObservationTimeDimension
    def set_isNonObservationTimeDimension(self, isNonObservationTimeDimension): self.isNonObservationTimeDimension = isNonObservationTimeDimension
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_isIdentityDimension(self): return self.isIdentityDimension
    def set_isIdentityDimension(self, isIdentityDimension): self.isIdentityDimension = isIdentityDimension
    def get_codelistVersion(self): return self.codelistVersion
    def set_codelistVersion(self, codelistVersion): self.codelistVersion = codelistVersion
    def get_crossSectionalAttachObservation(self): return self.crossSectionalAttachObservation
    def set_crossSectionalAttachObservation(self, crossSectionalAttachObservation): self.crossSectionalAttachObservation = crossSectionalAttachObservation
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def get_crossSectionalAttachGroup(self): return self.crossSectionalAttachGroup
    def set_crossSectionalAttachGroup(self, crossSectionalAttachGroup): self.crossSectionalAttachGroup = crossSectionalAttachGroup
    def hasContent_(self):
        if (
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DimensionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DimensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DimensionType'):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            outfile.write(' crossSectionalAttachDataSet="%s"' % self.gds_format_boolean(self.crossSectionalAttachDataSet, input_name='crossSectionalAttachDataSet'))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            outfile.write(' codelist=%s' % (quote_attrib(self.codelist), ))
        if self.isEntityDimension is not None and 'isEntityDimension' not in already_processed:
            already_processed.add('isEntityDimension')
            outfile.write(' isEntityDimension="%s"' % self.gds_format_boolean(self.isEntityDimension, input_name='isEntityDimension'))
        if self.isFrequencyDimension is not None and 'isFrequencyDimension' not in already_processed:
            already_processed.add('isFrequencyDimension')
            outfile.write(' isFrequencyDimension="%s"' % self.gds_format_boolean(self.isFrequencyDimension, input_name='isFrequencyDimension'))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            outfile.write(' codelistAgency=%s' % (quote_attrib(self.codelistAgency), ))
        if self.isCountDimension is not None and 'isCountDimension' not in already_processed:
            already_processed.add('isCountDimension')
            outfile.write(' isCountDimension="%s"' % self.gds_format_boolean(self.isCountDimension, input_name='isCountDimension'))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            outfile.write(' crossSectionalAttachSection="%s"' % self.gds_format_boolean(self.crossSectionalAttachSection, input_name='crossSectionalAttachSection'))
        if self.isMeasureDimension is not None and 'isMeasureDimension' not in already_processed:
            already_processed.add('isMeasureDimension')
            outfile.write(' isMeasureDimension="%s"' % self.gds_format_boolean(self.isMeasureDimension, input_name='isMeasureDimension'))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.isNonObservationTimeDimension is not None and 'isNonObservationTimeDimension' not in already_processed:
            already_processed.add('isNonObservationTimeDimension')
            outfile.write(' isNonObservationTimeDimension="%s"' % self.gds_format_boolean(self.isNonObservationTimeDimension, input_name='isNonObservationTimeDimension'))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.isIdentityDimension is not None and 'isIdentityDimension' not in already_processed:
            already_processed.add('isIdentityDimension')
            outfile.write(' isIdentityDimension="%s"' % self.gds_format_boolean(self.isIdentityDimension, input_name='isIdentityDimension'))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            outfile.write(' codelistVersion=%s' % (self.gds_format_string(quote_attrib(self.codelistVersion).encode(ExternalEncoding), input_name='codelistVersion'), ))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            outfile.write(' crossSectionalAttachObservation="%s"' % self.gds_format_boolean(self.crossSectionalAttachObservation, input_name='crossSectionalAttachObservation'))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            outfile.write(' crossSectionalAttachGroup="%s"' % self.gds_format_boolean(self.crossSectionalAttachGroup, input_name='crossSectionalAttachGroup'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='DimensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DimensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachDataSet=%s,\n' % (self.crossSectionalAttachDataSet,))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            showIndent(outfile, level)
            outfile.write('codelist=%s,\n' % (self.codelist,))
        if self.isEntityDimension is not None and 'isEntityDimension' not in already_processed:
            already_processed.add('isEntityDimension')
            showIndent(outfile, level)
            outfile.write('isEntityDimension=%s,\n' % (self.isEntityDimension,))
        if self.isFrequencyDimension is not None and 'isFrequencyDimension' not in already_processed:
            already_processed.add('isFrequencyDimension')
            showIndent(outfile, level)
            outfile.write('isFrequencyDimension=%s,\n' % (self.isFrequencyDimension,))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            showIndent(outfile, level)
            outfile.write('codelistAgency=%s,\n' % (self.codelistAgency,))
        if self.isCountDimension is not None and 'isCountDimension' not in already_processed:
            already_processed.add('isCountDimension')
            showIndent(outfile, level)
            outfile.write('isCountDimension=%s,\n' % (self.isCountDimension,))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachSection=%s,\n' % (self.crossSectionalAttachSection,))
        if self.isMeasureDimension is not None and 'isMeasureDimension' not in already_processed:
            already_processed.add('isMeasureDimension')
            showIndent(outfile, level)
            outfile.write('isMeasureDimension=%s,\n' % (self.isMeasureDimension,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.isNonObservationTimeDimension is not None and 'isNonObservationTimeDimension' not in already_processed:
            already_processed.add('isNonObservationTimeDimension')
            showIndent(outfile, level)
            outfile.write('isNonObservationTimeDimension=%s,\n' % (self.isNonObservationTimeDimension,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.isIdentityDimension is not None and 'isIdentityDimension' not in already_processed:
            already_processed.add('isIdentityDimension')
            showIndent(outfile, level)
            outfile.write('isIdentityDimension=%s,\n' % (self.isIdentityDimension,))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            showIndent(outfile, level)
            outfile.write('codelistVersion="%s",\n' % (self.codelistVersion,))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachObservation=%s,\n' % (self.crossSectionalAttachObservation,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachGroup=%s,\n' % (self.crossSectionalAttachGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crossSectionalAttachDataSet', node)
        if value is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            if value in ('true', '1'):
                self.crossSectionalAttachDataSet = True
            elif value in ('false', '0'):
                self.crossSectionalAttachDataSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('codelist', node)
        if value is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            self.codelist = value
        value = find_attr_value_('isEntityDimension', node)
        if value is not None and 'isEntityDimension' not in already_processed:
            already_processed.add('isEntityDimension')
            if value in ('true', '1'):
                self.isEntityDimension = True
            elif value in ('false', '0'):
                self.isEntityDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isFrequencyDimension', node)
        if value is not None and 'isFrequencyDimension' not in already_processed:
            already_processed.add('isFrequencyDimension')
            if value in ('true', '1'):
                self.isFrequencyDimension = True
            elif value in ('false', '0'):
                self.isFrequencyDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('codelistAgency', node)
        if value is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            self.codelistAgency = value
        value = find_attr_value_('isCountDimension', node)
        if value is not None and 'isCountDimension' not in already_processed:
            already_processed.add('isCountDimension')
            if value in ('true', '1'):
                self.isCountDimension = True
            elif value in ('false', '0'):
                self.isCountDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('crossSectionalAttachSection', node)
        if value is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            if value in ('true', '1'):
                self.crossSectionalAttachSection = True
            elif value in ('false', '0'):
                self.crossSectionalAttachSection = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isMeasureDimension', node)
        if value is not None and 'isMeasureDimension' not in already_processed:
            already_processed.add('isMeasureDimension')
            if value in ('true', '1'):
                self.isMeasureDimension = True
            elif value in ('false', '0'):
                self.isMeasureDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('isNonObservationTimeDimension', node)
        if value is not None and 'isNonObservationTimeDimension' not in already_processed:
            already_processed.add('isNonObservationTimeDimension')
            if value in ('true', '1'):
                self.isNonObservationTimeDimension = True
            elif value in ('false', '0'):
                self.isNonObservationTimeDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('isIdentityDimension', node)
        if value is not None and 'isIdentityDimension' not in already_processed:
            already_processed.add('isIdentityDimension')
            if value in ('true', '1'):
                self.isIdentityDimension = True
            elif value in ('false', '0'):
                self.isIdentityDimension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('codelistVersion', node)
        if value is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            self.codelistVersion = value
        value = find_attr_value_('crossSectionalAttachObservation', node)
        if value is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            if value in ('true', '1'):
                self.crossSectionalAttachObservation = True
            elif value in ('false', '0'):
                self.crossSectionalAttachObservation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
        value = find_attr_value_('crossSectionalAttachGroup', node)
        if value is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            if value in ('true', '1'):
                self.crossSectionalAttachGroup = True
            elif value in ('false', '0'):
                self.crossSectionalAttachGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class DimensionType


class TimeDimensionType(GeneratedsSuper):
    """TimeDimensionType describes the special Time dimension. Any key
    family which will be used for time-series formats (GenericData,
    CompactData, and UtilityData) must include the time dimension.
    Any key family which uses the time dimension must also declare a
    frequency dimension, conventionally the first dimension in the
    key (the set of ordered non-time dimensions). A TextFormat
    element may be included for indicating the representation of
    time. The concept attribute must contain the concept name of the
    time concept. The codelist attribute may provide the value of
    the concept name of a codelist if needed. If a key family
    describes cross-sectional data, then for each dimension, the
    crossSectionalAttachDataSet, crossSectionalAttachGroup,
    crossSectionalAttachSection, and crossSectionalAttachObservation
    attributes must be given values. A value of "true" for any of
    these attributes indicates that the dimension may be provided a
    value at the indicated level within the cross-sectional
    structure. Note that these attributes do not need to be provided
    for any dimension with the isFrequencyDimension set to "true",
    as these dimensions are always attached only at the group level,
    as is time. A key family designed for cross-sectional use must
    be structured such that any observation's complete key can be
    unambiguously described by taking each dimension value from its
    observation level, section level, group level, and data set
    level, and ordered according to the sequence given in the key
    family."""
    subclass = None
    superclass = None
    def __init__(self, crossSectionalAttachDataSet=None, codelist=None, crossSectionalAttachObservation=None, conceptSchemeAgency=None, codelistAgency=None, crossSectionalAttachSection=None, conceptRef=None, conceptAgency=None, codelistVersion=None, conceptSchemeRef=None, conceptVersion=None, crossSectionalAttachGroup=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.crossSectionalAttachDataSet = _cast(bool, crossSectionalAttachDataSet)
        self.codelist = _cast(None, codelist)
        self.crossSectionalAttachObservation = _cast(bool, crossSectionalAttachObservation)
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.codelistAgency = _cast(None, codelistAgency)
        self.crossSectionalAttachSection = _cast(bool, crossSectionalAttachSection)
        self.conceptRef = _cast(None, conceptRef)
        self.conceptAgency = _cast(None, conceptAgency)
        self.codelistVersion = _cast(None, codelistVersion)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        self.crossSectionalAttachGroup = _cast(bool, crossSectionalAttachGroup)
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if TimeDimensionType.subclass:
            return TimeDimensionType.subclass(*args_, **kwargs_)
        else:
            return TimeDimensionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_crossSectionalAttachDataSet(self): return self.crossSectionalAttachDataSet
    def set_crossSectionalAttachDataSet(self, crossSectionalAttachDataSet): self.crossSectionalAttachDataSet = crossSectionalAttachDataSet
    def get_codelist(self): return self.codelist
    def set_codelist(self, codelist): self.codelist = codelist
    def get_crossSectionalAttachObservation(self): return self.crossSectionalAttachObservation
    def set_crossSectionalAttachObservation(self, crossSectionalAttachObservation): self.crossSectionalAttachObservation = crossSectionalAttachObservation
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_codelistAgency(self): return self.codelistAgency
    def set_codelistAgency(self, codelistAgency): self.codelistAgency = codelistAgency
    def get_crossSectionalAttachSection(self): return self.crossSectionalAttachSection
    def set_crossSectionalAttachSection(self, crossSectionalAttachSection): self.crossSectionalAttachSection = crossSectionalAttachSection
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_codelistVersion(self): return self.codelistVersion
    def set_codelistVersion(self, codelistVersion): self.codelistVersion = codelistVersion
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def get_crossSectionalAttachGroup(self): return self.crossSectionalAttachGroup
    def set_crossSectionalAttachGroup(self, crossSectionalAttachGroup): self.crossSectionalAttachGroup = crossSectionalAttachGroup
    def hasContent_(self):
        if (
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TimeDimensionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeDimensionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TimeDimensionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TimeDimensionType'):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            outfile.write(' crossSectionalAttachDataSet="%s"' % self.gds_format_boolean(self.crossSectionalAttachDataSet, input_name='crossSectionalAttachDataSet'))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            outfile.write(' codelist=%s' % (quote_attrib(self.codelist), ))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            outfile.write(' crossSectionalAttachObservation="%s"' % self.gds_format_boolean(self.crossSectionalAttachObservation, input_name='crossSectionalAttachObservation'))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            outfile.write(' codelistAgency=%s' % (quote_attrib(self.codelistAgency), ))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            outfile.write(' crossSectionalAttachSection="%s"' % self.gds_format_boolean(self.crossSectionalAttachSection, input_name='crossSectionalAttachSection'))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            outfile.write(' codelistVersion=%s' % (self.gds_format_string(quote_attrib(self.codelistVersion).encode(ExternalEncoding), input_name='codelistVersion'), ))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            outfile.write(' crossSectionalAttachGroup="%s"' % self.gds_format_boolean(self.crossSectionalAttachGroup, input_name='crossSectionalAttachGroup'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='TimeDimensionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TimeDimensionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachDataSet=%s,\n' % (self.crossSectionalAttachDataSet,))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            showIndent(outfile, level)
            outfile.write('codelist=%s,\n' % (self.codelist,))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachObservation=%s,\n' % (self.crossSectionalAttachObservation,))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            showIndent(outfile, level)
            outfile.write('codelistAgency=%s,\n' % (self.codelistAgency,))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachSection=%s,\n' % (self.crossSectionalAttachSection,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            showIndent(outfile, level)
            outfile.write('codelistVersion="%s",\n' % (self.codelistVersion,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachGroup=%s,\n' % (self.crossSectionalAttachGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crossSectionalAttachDataSet', node)
        if value is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            if value in ('true', '1'):
                self.crossSectionalAttachDataSet = True
            elif value in ('false', '0'):
                self.crossSectionalAttachDataSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('codelist', node)
        if value is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            self.codelist = value
        value = find_attr_value_('crossSectionalAttachObservation', node)
        if value is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            if value in ('true', '1'):
                self.crossSectionalAttachObservation = True
            elif value in ('false', '0'):
                self.crossSectionalAttachObservation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('codelistAgency', node)
        if value is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            self.codelistAgency = value
        value = find_attr_value_('crossSectionalAttachSection', node)
        if value is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            if value in ('true', '1'):
                self.crossSectionalAttachSection = True
            elif value in ('false', '0'):
                self.crossSectionalAttachSection = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('codelistVersion', node)
        if value is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            self.codelistVersion = value
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
        value = find_attr_value_('crossSectionalAttachGroup', node)
        if value is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            if value in ('true', '1'):
                self.crossSectionalAttachGroup = True
            elif value in ('false', '0'):
                self.crossSectionalAttachGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class TimeDimensionType


class GroupType(GeneratedsSuper):
    """GroupType declares any useful groupings of data, based on a
    selection of the declared (non-Time) dimensions (indicated with
    the DimensionRef element) which form partial keys to which
    attributes may be attached. The value of the DimensionRef
    element is the concept of the dimension - that is, the value of
    the dimension's concept attribute. Thus, if data is to be
    presented as a set of time series which vary only according to
    their differing frequencies, a "sibling group" would be
    declared, with all dimensions except the frequency dimension in
    it. If data is commonly grouped as a set of all countries, then
    a "Country Group" could be declared, with all dimensions except
    the country dimension forming part of the partial key. Any
    dimension which is not part of a group has a value which varies
    at the series level (for time series formats). There is no
    requirement to have only a single dimension ommitted from a
    partial key - it can be any subset of the set of ordered
    dimensions (that is, all dimensions except the time dimension,
    which may never be declared as belonging to a group partial
    key). All groups declared in the key family must be unique -
    that is, you may not have duplicate partial keys. All groups
    must also be given unique names (id attributes). Although it is
    conventional to declare dimensions in the same order as they are
    declared in the ordered key, there is no requirement to do so -
    the ordering of the values of the key are taken from the order
    in which the dimensions are declared. The Description element
    provides a human-readable description (potentially in multiple,
    parallel languages) of the group. Note that for cross-sectional
    formats, the named group mechanism is not used, but is instead
    replaced by a generic group which carries time and frequency
    values with it, and allows for any available group-level
    attributes to be specified if desired."""
    subclass = None
    superclass = None
    def __init__(self, id=None, DimensionRef=None, AttachmentConstraintRef=None, Description=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if DimensionRef is None:
            self.DimensionRef = []
        else:
            self.DimensionRef = DimensionRef
        self.AttachmentConstraintRef = AttachmentConstraintRef
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if GroupType.subclass:
            return GroupType.subclass(*args_, **kwargs_)
        else:
            return GroupType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DimensionRef(self): return self.DimensionRef
    def set_DimensionRef(self, DimensionRef): self.DimensionRef = DimensionRef
    def add_DimensionRef(self, value): self.DimensionRef.append(value)
    def insert_DimensionRef_at(self, index, value): self.DimensionRef.insert(index, value)
    def replace_DimensionRef_at(self, index, value): self.DimensionRef[index] = value
    def get_AttachmentConstraintRef(self): return self.AttachmentConstraintRef
    def set_AttachmentConstraintRef(self, AttachmentConstraintRef): self.AttachmentConstraintRef = AttachmentConstraintRef
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DimensionRef or
            self.AttachmentConstraintRef is not None or
            self.Description or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='GroupType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GroupType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='GroupType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='GroupType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='GroupType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DimensionRef_ in self.DimensionRef:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDimensionRef>%s</%sDimensionRef>%s' % (namespace_, self.gds_format_string(quote_xml(DimensionRef_).encode(ExternalEncoding), input_name='DimensionRef'), namespace_, eol_))
        if self.AttachmentConstraintRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentConstraintRef>%s</%sAttachmentConstraintRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.AttachmentConstraintRef).encode(ExternalEncoding), input_name='AttachmentConstraintRef'), namespace_, eol_))
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='GroupType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DimensionRef=[\n')
        level += 1
        for DimensionRef_ in self.DimensionRef:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DimensionRef_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.AttachmentConstraintRef is not None:
            showIndent(outfile, level)
            outfile.write('AttachmentConstraintRef=%s,\n' % quote_python(self.AttachmentConstraintRef).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DimensionRef':
            DimensionRef_ = child_.text
            DimensionRef_ = self.gds_validate_string(DimensionRef_, node, 'DimensionRef')
            self.DimensionRef.append(DimensionRef_)
            self.validate_IDType(self.DimensionRef)    # validate type IDType
        elif nodeName_ == 'AttachmentConstraintRef':
            AttachmentConstraintRef_ = child_.text
            AttachmentConstraintRef_ = self.gds_validate_string(AttachmentConstraintRef_, node, 'AttachmentConstraintRef')
            self.AttachmentConstraintRef = AttachmentConstraintRef_
            self.validate_IDType(self.AttachmentConstraintRef)    # validate type IDType
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class GroupType


class AttachmentConstraintRefType(GeneratedsSuper):
    """AttachmentConstraintRefType describes a reference to an attachment
    constraint. This includes a reference to a dataflow,
    metadataflow, data provider, or provision agreement plus the ID
    of the attachment constraint, as assigned within the constraints
    associated with the referenced object, in the ConstraintRef
    element."""
    subclass = None
    superclass = None
    def __init__(self, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None, ProvisionAgreementRef=None, ConstraintRef=None):
        self.original_tagname_ = None
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.DataProviderRef = DataProviderRef
        self.ProvisionAgreementRef = ProvisionAgreementRef
        self.ConstraintRef = ConstraintRef
    def factory(*args_, **kwargs_):
        if AttachmentConstraintRefType.subclass:
            return AttachmentConstraintRefType.subclass(*args_, **kwargs_)
        else:
            return AttachmentConstraintRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def get_ConstraintRef(self): return self.ConstraintRef
    def set_ConstraintRef(self, ConstraintRef): self.ConstraintRef = ConstraintRef
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.DataProviderRef is not None or
            self.ProvisionAgreementRef is not None or
            self.ConstraintRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AttachmentConstraintRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttachmentConstraintRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AttachmentConstraintRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AttachmentConstraintRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AttachmentConstraintRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
        if self.ConstraintRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConstraintRef>%s</%sConstraintRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConstraintRef).encode(ExternalEncoding), input_name='ConstraintRef'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AttachmentConstraintRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConstraintRef is not None:
            showIndent(outfile, level)
            outfile.write('ConstraintRef=%s,\n' % quote_python(self.ConstraintRef).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
        elif nodeName_ == 'ConstraintRef':
            ConstraintRef_ = child_.text
            ConstraintRef_ = self.gds_validate_string(ConstraintRef_, node, 'ConstraintRef')
            self.ConstraintRef = ConstraintRef_
            self.validate_IDType(self.ConstraintRef)    # validate type IDType
# end class AttachmentConstraintRefType


class ProvisionAgreementRefType(GeneratedsSuper):
    """ProvisionAgreementRef allows for the identification of a provision
    agreement. At a minimum, either the URN element - holding a
    valid registry URN - or the set of OragnisationSchemeAgencyID,
    OrganisationSchemeID, DataProviderID, DataflowAgencyID, and
    DataflowID must be specified. Constraint can be used to express
    constraints associated with the provision agreement. This type
    differs from the similar type in the Registry namespace package
    by not providing information about the datasource or
    constraints."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, OrganisationSchemeAgencyID=None, OrganisationSchemeID=None, DataProviderID=None, DataProviderVersion=None, DataflowAgencyID=None, DataflowID=None, DataflowVersion=None, Constraint=None):
        self.original_tagname_ = None
        self.URN = URN
        self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
        self.OrganisationSchemeID = OrganisationSchemeID
        self.DataProviderID = DataProviderID
        self.DataProviderVersion = DataProviderVersion
        self.DataflowAgencyID = DataflowAgencyID
        self.DataflowID = DataflowID
        self.DataflowVersion = DataflowVersion
        self.Constraint = Constraint
    def factory(*args_, **kwargs_):
        if ProvisionAgreementRefType.subclass:
            return ProvisionAgreementRefType.subclass(*args_, **kwargs_)
        else:
            return ProvisionAgreementRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_OrganisationSchemeAgencyID(self): return self.OrganisationSchemeAgencyID
    def set_OrganisationSchemeAgencyID(self, OrganisationSchemeAgencyID): self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
    def get_OrganisationSchemeID(self): return self.OrganisationSchemeID
    def set_OrganisationSchemeID(self, OrganisationSchemeID): self.OrganisationSchemeID = OrganisationSchemeID
    def get_DataProviderID(self): return self.DataProviderID
    def set_DataProviderID(self, DataProviderID): self.DataProviderID = DataProviderID
    def get_DataProviderVersion(self): return self.DataProviderVersion
    def set_DataProviderVersion(self, DataProviderVersion): self.DataProviderVersion = DataProviderVersion
    def get_DataflowAgencyID(self): return self.DataflowAgencyID
    def set_DataflowAgencyID(self, DataflowAgencyID): self.DataflowAgencyID = DataflowAgencyID
    def get_DataflowID(self): return self.DataflowID
    def set_DataflowID(self, DataflowID): self.DataflowID = DataflowID
    def get_DataflowVersion(self): return self.DataflowVersion
    def set_DataflowVersion(self, DataflowVersion): self.DataflowVersion = DataflowVersion
    def get_Constraint(self): return self.Constraint
    def set_Constraint(self, Constraint): self.Constraint = Constraint
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.OrganisationSchemeAgencyID is not None or
            self.OrganisationSchemeID is not None or
            self.DataProviderID is not None or
            self.DataProviderVersion is not None or
            self.DataflowAgencyID is not None or
            self.DataflowID is not None or
            self.DataflowVersion is not None or
            self.Constraint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProvisionAgreementRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProvisionAgreementRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProvisionAgreementRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProvisionAgreementRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProvisionAgreementRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeAgencyID>%s</%sOrganisationSchemeAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeAgencyID).encode(ExternalEncoding), input_name='OrganisationSchemeAgencyID'), namespace_, eol_))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeID>%s</%sOrganisationSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeID).encode(ExternalEncoding), input_name='OrganisationSchemeID'), namespace_, eol_))
        if self.DataProviderID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderID>%s</%sDataProviderID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataProviderID).encode(ExternalEncoding), input_name='DataProviderID'), namespace_, eol_))
        if self.DataProviderVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderVersion>%s</%sDataProviderVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataProviderVersion).encode(ExternalEncoding), input_name='DataProviderVersion'), namespace_, eol_))
        if self.DataflowAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowAgencyID>%s</%sDataflowAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataflowAgencyID).encode(ExternalEncoding), input_name='DataflowAgencyID'), namespace_, eol_))
        if self.DataflowID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowID>%s</%sDataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataflowID).encode(ExternalEncoding), input_name='DataflowID'), namespace_, eol_))
        if self.DataflowVersion is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowVersion>%s</%sDataflowVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataflowVersion).encode(ExternalEncoding), input_name='DataflowVersion'), namespace_, eol_))
        if self.Constraint is not None:
            self.Constraint.export(outfile, level, namespace_, name_='Constraint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProvisionAgreementRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeAgencyID=%s,\n' % quote_python(self.OrganisationSchemeAgencyID).encode(ExternalEncoding))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeID=%s,\n' % quote_python(self.OrganisationSchemeID).encode(ExternalEncoding))
        if self.DataProviderID is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderID=%s,\n' % quote_python(self.DataProviderID).encode(ExternalEncoding))
        if self.DataProviderVersion is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderVersion=%s,\n' % quote_python(self.DataProviderVersion).encode(ExternalEncoding))
        if self.DataflowAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('DataflowAgencyID=%s,\n' % quote_python(self.DataflowAgencyID).encode(ExternalEncoding))
        if self.DataflowID is not None:
            showIndent(outfile, level)
            outfile.write('DataflowID=%s,\n' % quote_python(self.DataflowID).encode(ExternalEncoding))
        if self.DataflowVersion is not None:
            showIndent(outfile, level)
            outfile.write('DataflowVersion=%s,\n' % quote_python(self.DataflowVersion).encode(ExternalEncoding))
        if self.Constraint is not None:
            showIndent(outfile, level)
            outfile.write('Constraint=model_.ConstraintType(\n')
            self.Constraint.exportLiteral(outfile, level, name_='Constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'OrganisationSchemeAgencyID':
            OrganisationSchemeAgencyID_ = child_.text
            OrganisationSchemeAgencyID_ = self.gds_validate_string(OrganisationSchemeAgencyID_, node, 'OrganisationSchemeAgencyID')
            self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID_
            self.validate_IDType(self.OrganisationSchemeAgencyID)    # validate type IDType
        elif nodeName_ == 'OrganisationSchemeID':
            OrganisationSchemeID_ = child_.text
            OrganisationSchemeID_ = self.gds_validate_string(OrganisationSchemeID_, node, 'OrganisationSchemeID')
            self.OrganisationSchemeID = OrganisationSchemeID_
            self.validate_IDType(self.OrganisationSchemeID)    # validate type IDType
        elif nodeName_ == 'DataProviderID':
            DataProviderID_ = child_.text
            DataProviderID_ = self.gds_validate_string(DataProviderID_, node, 'DataProviderID')
            self.DataProviderID = DataProviderID_
            self.validate_IDType(self.DataProviderID)    # validate type IDType
        elif nodeName_ == 'DataProviderVersion':
            DataProviderVersion_ = child_.text
            DataProviderVersion_ = self.gds_validate_string(DataProviderVersion_, node, 'DataProviderVersion')
            self.DataProviderVersion = DataProviderVersion_
        elif nodeName_ == 'DataflowAgencyID':
            DataflowAgencyID_ = child_.text
            DataflowAgencyID_ = self.gds_validate_string(DataflowAgencyID_, node, 'DataflowAgencyID')
            self.DataflowAgencyID = DataflowAgencyID_
            self.validate_IDType(self.DataflowAgencyID)    # validate type IDType
        elif nodeName_ == 'DataflowID':
            DataflowID_ = child_.text
            DataflowID_ = self.gds_validate_string(DataflowID_, node, 'DataflowID')
            self.DataflowID = DataflowID_
            self.validate_IDType(self.DataflowID)    # validate type IDType
        elif nodeName_ == 'DataflowVersion':
            DataflowVersion_ = child_.text
            DataflowVersion_ = self.gds_validate_string(DataflowVersion_, node, 'DataflowVersion')
            self.DataflowVersion = DataflowVersion_
        elif nodeName_ == 'Constraint':
            obj_ = ConstraintType.factory()
            obj_.build(child_)
            self.Constraint = obj_
            obj_.original_tagname_ = 'Constraint'
# end class ProvisionAgreementRefType


class DataProviderRefType(GeneratedsSuper):
    """The DataProviderRef type structures a reference to a data provider.
    This requires that IDs be provided for an organisation scheme,
    its maintenance agency, and the data provider as identified in
    the referenced organisation scheme. The Version element may be
    used to specify the version of the indicated data provider. If
    absent, the most recent version is assumed. The URN element is
    used to provide the registry-specific urn as an alternate means
    of identification. At a minimum, either the URN element or
    OrgansisationSchemeID, OrganisationSchemeAgencyID,
    DataProviderID, and (optionally) Version must be supplied. When
    used in a response document of any type, the URN must always be
    provided. Constraints can be used to specify constraints
    associated with the data provider. This type differs from the
    similar type in the Registry namespace by not describing the
    datasource."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, OrganisationSchemeAgencyID=None, OrganisationSchemeID=None, DataProviderID=None, Version=None, Constraint=None):
        self.original_tagname_ = None
        self.URN = URN
        self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
        self.OrganisationSchemeID = OrganisationSchemeID
        self.DataProviderID = DataProviderID
        self.Version = Version
        self.Constraint = Constraint
    def factory(*args_, **kwargs_):
        if DataProviderRefType.subclass:
            return DataProviderRefType.subclass(*args_, **kwargs_)
        else:
            return DataProviderRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_OrganisationSchemeAgencyID(self): return self.OrganisationSchemeAgencyID
    def set_OrganisationSchemeAgencyID(self, OrganisationSchemeAgencyID): self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
    def get_OrganisationSchemeID(self): return self.OrganisationSchemeID
    def set_OrganisationSchemeID(self, OrganisationSchemeID): self.OrganisationSchemeID = OrganisationSchemeID
    def get_DataProviderID(self): return self.DataProviderID
    def set_DataProviderID(self, DataProviderID): self.DataProviderID = DataProviderID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Constraint(self): return self.Constraint
    def set_Constraint(self, Constraint): self.Constraint = Constraint
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.OrganisationSchemeAgencyID is not None or
            self.OrganisationSchemeID is not None or
            self.DataProviderID is not None or
            self.Version is not None or
            self.Constraint is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataProviderRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProviderRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataProviderRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataProviderRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataProviderRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeAgencyID>%s</%sOrganisationSchemeAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeAgencyID).encode(ExternalEncoding), input_name='OrganisationSchemeAgencyID'), namespace_, eol_))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeID>%s</%sOrganisationSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeID).encode(ExternalEncoding), input_name='OrganisationSchemeID'), namespace_, eol_))
        if self.DataProviderID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderID>%s</%sDataProviderID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataProviderID).encode(ExternalEncoding), input_name='DataProviderID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Constraint is not None:
            self.Constraint.export(outfile, level, namespace_, name_='Constraint', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataProviderRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeAgencyID=%s,\n' % quote_python(self.OrganisationSchemeAgencyID).encode(ExternalEncoding))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeID=%s,\n' % quote_python(self.OrganisationSchemeID).encode(ExternalEncoding))
        if self.DataProviderID is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderID=%s,\n' % quote_python(self.DataProviderID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Constraint is not None:
            showIndent(outfile, level)
            outfile.write('Constraint=model_.ConstraintType(\n')
            self.Constraint.exportLiteral(outfile, level, name_='Constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'OrganisationSchemeAgencyID':
            OrganisationSchemeAgencyID_ = child_.text
            OrganisationSchemeAgencyID_ = self.gds_validate_string(OrganisationSchemeAgencyID_, node, 'OrganisationSchemeAgencyID')
            self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID_
            self.validate_IDType(self.OrganisationSchemeAgencyID)    # validate type IDType
        elif nodeName_ == 'OrganisationSchemeID':
            OrganisationSchemeID_ = child_.text
            OrganisationSchemeID_ = self.gds_validate_string(OrganisationSchemeID_, node, 'OrganisationSchemeID')
            self.OrganisationSchemeID = OrganisationSchemeID_
            self.validate_IDType(self.OrganisationSchemeID)    # validate type IDType
        elif nodeName_ == 'DataProviderID':
            DataProviderID_ = child_.text
            DataProviderID_ = self.gds_validate_string(DataProviderID_, node, 'DataProviderID')
            self.DataProviderID = DataProviderID_
            self.validate_IDType(self.DataProviderID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Constraint':
            obj_ = ConstraintType.factory()
            obj_.build(child_)
            self.Constraint = obj_
            obj_.original_tagname_ = 'Constraint'
# end class DataProviderRefType


class AttributeType(GeneratedsSuper):
    """AttributeType describes the structure of attributes declared in the
    key family. If the codelist attribute is not used, then the
    attribute is uncoded. You may use the TextFormat element to
    specify constraints on the value of the uncoded attribute. The
    concept attribute contains the name of a concept. The codelist
    attribute supplies the id value of a codelist. The
    attachmentLevel attribute indicates the level to which the
    attribute is attached in time-series formats (GenericData,
    CompactData, and UtilityData formats). The assignmentStatus
    attribute indicates whether a value must be provided for the
    attribute when sending documentation along with the data. The
    AttachmentGroup element is included only when the attribute is
    attached at the Group level, to indicate which declared group or
    groups the attribute may be attached to. For each such group, an
    AttachmentGroup element should appear, with the content of the
    element being the name of the group. The AttachmentMeasure
    element is similar, indicating for cross-sectional formats which
    declared measure or measures the attribute attached at the
    observation level may be attached to. The isTimeFormat attribute
    indicates that the attribute represents the concept of time
    format (typically a mandatory series-level attribute with a
    codelist representation taken from ISO 8601). For key families
    not used to structure cross-sectional formats, this element may
    be ommitted. Each such element contains the name of the declared
    measure. The attributes crossSectionalAttachDataSet,
    crossSectionalAttachGroup, crossSectionalAttachSection, and
    crossSectionalAttachObservation indicate what the attachment
    level or levels are for cross-sectional data formats, and may be
    ommitted if the key family will not be used to structure them. A
    value of "true" indicates that it is permissible to provide a
    value for the attribute at the specified level within the
    structure. Note that all groups in cross-sectional formats are
    replaced by a generic group which has any values for time and
    frequency, and allows any group-level attributes to be attached
    to it. An attribute which is an Entity attribute has a true
    value for the isEntityAttribute attribute - you may have either
    one Entity dimension or one Entity Attribute in a key family; a
    non-observational time has a true value for
    isNonObservationalTimeAttribute; and a Count attribute has a
    true value for the isCountAttribute attribute. The attributes
    isFrequencyAttribute and isEntityAttribute are mutually
    exclusive - that is, only one of them may have a "true" value
    for any instance of the Attribute element. The definitions and
    limits on representation of each attribute type are as follows:
    Frequency attribute describes the period between observations,
    and is coded; Count attributes are represented by values which
    are sequential, incrementing numbers - representations are
    always of the Increment or Count type; Entity attributes
    describe the subject of the data set - they can be coded or
    represented in any other form; Non-Observational Time attributes
    must have a representation which contains a time; Identity
    attributes may be coded or uncoded, but must be represented by a
    scheme which refers to the identifiers of external entities. Any
    given instance of an attribute may only have a true value for
    this set of attributes, and if so may not have a true value for
    the isTimeFormat attribute."""
    subclass = None
    superclass = None
    def __init__(self, crossSectionalAttachDataSet=None, isEntityAttribute=False, codelist=None, isTimeFormat=False, crossSectionalAttachObservation=None, conceptSchemeAgency=None, attachmentLevel=None, codelistAgency=None, isFrequencyAttribute=False, crossSectionalAttachSection=None, isNonObservationalTimeAttribute=False, isCountAttribute=False, conceptRef=None, conceptAgency=None, isIdentityAttribute=False, codelistVersion=None, assignmentStatus=None, conceptSchemeRef=None, conceptVersion=None, crossSectionalAttachGroup=None, TextFormat=None, AttachmentGroup=None, AttachmentMeasure=None, Annotations=None):
        self.original_tagname_ = None
        self.crossSectionalAttachDataSet = _cast(bool, crossSectionalAttachDataSet)
        self.isEntityAttribute = _cast(bool, isEntityAttribute)
        self.codelist = _cast(None, codelist)
        self.isTimeFormat = _cast(bool, isTimeFormat)
        self.crossSectionalAttachObservation = _cast(bool, crossSectionalAttachObservation)
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.attachmentLevel = _cast(None, attachmentLevel)
        self.codelistAgency = _cast(None, codelistAgency)
        self.isFrequencyAttribute = _cast(bool, isFrequencyAttribute)
        self.crossSectionalAttachSection = _cast(bool, crossSectionalAttachSection)
        self.isNonObservationalTimeAttribute = _cast(bool, isNonObservationalTimeAttribute)
        self.isCountAttribute = _cast(bool, isCountAttribute)
        self.conceptRef = _cast(None, conceptRef)
        self.conceptAgency = _cast(None, conceptAgency)
        self.isIdentityAttribute = _cast(bool, isIdentityAttribute)
        self.codelistVersion = _cast(None, codelistVersion)
        self.assignmentStatus = _cast(None, assignmentStatus)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        self.crossSectionalAttachGroup = _cast(bool, crossSectionalAttachGroup)
        self.TextFormat = TextFormat
        if AttachmentGroup is None:
            self.AttachmentGroup = []
        else:
            self.AttachmentGroup = AttachmentGroup
        if AttachmentMeasure is None:
            self.AttachmentMeasure = []
        else:
            self.AttachmentMeasure = AttachmentMeasure
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_AttachmentGroup(self): return self.AttachmentGroup
    def set_AttachmentGroup(self, AttachmentGroup): self.AttachmentGroup = AttachmentGroup
    def add_AttachmentGroup(self, value): self.AttachmentGroup.append(value)
    def insert_AttachmentGroup_at(self, index, value): self.AttachmentGroup.insert(index, value)
    def replace_AttachmentGroup_at(self, index, value): self.AttachmentGroup[index] = value
    def get_AttachmentMeasure(self): return self.AttachmentMeasure
    def set_AttachmentMeasure(self, AttachmentMeasure): self.AttachmentMeasure = AttachmentMeasure
    def add_AttachmentMeasure(self, value): self.AttachmentMeasure.append(value)
    def insert_AttachmentMeasure_at(self, index, value): self.AttachmentMeasure.insert(index, value)
    def replace_AttachmentMeasure_at(self, index, value): self.AttachmentMeasure[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_crossSectionalAttachDataSet(self): return self.crossSectionalAttachDataSet
    def set_crossSectionalAttachDataSet(self, crossSectionalAttachDataSet): self.crossSectionalAttachDataSet = crossSectionalAttachDataSet
    def get_isEntityAttribute(self): return self.isEntityAttribute
    def set_isEntityAttribute(self, isEntityAttribute): self.isEntityAttribute = isEntityAttribute
    def get_codelist(self): return self.codelist
    def set_codelist(self, codelist): self.codelist = codelist
    def get_isTimeFormat(self): return self.isTimeFormat
    def set_isTimeFormat(self, isTimeFormat): self.isTimeFormat = isTimeFormat
    def get_crossSectionalAttachObservation(self): return self.crossSectionalAttachObservation
    def set_crossSectionalAttachObservation(self, crossSectionalAttachObservation): self.crossSectionalAttachObservation = crossSectionalAttachObservation
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_attachmentLevel(self): return self.attachmentLevel
    def set_attachmentLevel(self, attachmentLevel): self.attachmentLevel = attachmentLevel
    def get_codelistAgency(self): return self.codelistAgency
    def set_codelistAgency(self, codelistAgency): self.codelistAgency = codelistAgency
    def get_isFrequencyAttribute(self): return self.isFrequencyAttribute
    def set_isFrequencyAttribute(self, isFrequencyAttribute): self.isFrequencyAttribute = isFrequencyAttribute
    def get_crossSectionalAttachSection(self): return self.crossSectionalAttachSection
    def set_crossSectionalAttachSection(self, crossSectionalAttachSection): self.crossSectionalAttachSection = crossSectionalAttachSection
    def get_isNonObservationalTimeAttribute(self): return self.isNonObservationalTimeAttribute
    def set_isNonObservationalTimeAttribute(self, isNonObservationalTimeAttribute): self.isNonObservationalTimeAttribute = isNonObservationalTimeAttribute
    def get_isCountAttribute(self): return self.isCountAttribute
    def set_isCountAttribute(self, isCountAttribute): self.isCountAttribute = isCountAttribute
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_isIdentityAttribute(self): return self.isIdentityAttribute
    def set_isIdentityAttribute(self, isIdentityAttribute): self.isIdentityAttribute = isIdentityAttribute
    def get_codelistVersion(self): return self.codelistVersion
    def set_codelistVersion(self, codelistVersion): self.codelistVersion = codelistVersion
    def get_assignmentStatus(self): return self.assignmentStatus
    def set_assignmentStatus(self, assignmentStatus): self.assignmentStatus = assignmentStatus
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def get_crossSectionalAttachGroup(self): return self.crossSectionalAttachGroup
    def set_crossSectionalAttachGroup(self, crossSectionalAttachGroup): self.crossSectionalAttachGroup = crossSectionalAttachGroup
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TextFormat is not None or
            self.AttachmentGroup or
            self.AttachmentMeasure or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AttributeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AttributeType'):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            outfile.write(' crossSectionalAttachDataSet="%s"' % self.gds_format_boolean(self.crossSectionalAttachDataSet, input_name='crossSectionalAttachDataSet'))
        if self.isEntityAttribute is not None and 'isEntityAttribute' not in already_processed:
            already_processed.add('isEntityAttribute')
            outfile.write(' isEntityAttribute="%s"' % self.gds_format_boolean(self.isEntityAttribute, input_name='isEntityAttribute'))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            outfile.write(' codelist=%s' % (quote_attrib(self.codelist), ))
        if self.isTimeFormat is not None and 'isTimeFormat' not in already_processed:
            already_processed.add('isTimeFormat')
            outfile.write(' isTimeFormat="%s"' % self.gds_format_boolean(self.isTimeFormat, input_name='isTimeFormat'))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            outfile.write(' crossSectionalAttachObservation="%s"' % self.gds_format_boolean(self.crossSectionalAttachObservation, input_name='crossSectionalAttachObservation'))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.attachmentLevel is not None and 'attachmentLevel' not in already_processed:
            already_processed.add('attachmentLevel')
            outfile.write(' attachmentLevel=%s' % (quote_attrib(self.attachmentLevel), ))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            outfile.write(' codelistAgency=%s' % (quote_attrib(self.codelistAgency), ))
        if self.isFrequencyAttribute is not None and 'isFrequencyAttribute' not in already_processed:
            already_processed.add('isFrequencyAttribute')
            outfile.write(' isFrequencyAttribute="%s"' % self.gds_format_boolean(self.isFrequencyAttribute, input_name='isFrequencyAttribute'))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            outfile.write(' crossSectionalAttachSection="%s"' % self.gds_format_boolean(self.crossSectionalAttachSection, input_name='crossSectionalAttachSection'))
        if self.isNonObservationalTimeAttribute is not None and 'isNonObservationalTimeAttribute' not in already_processed:
            already_processed.add('isNonObservationalTimeAttribute')
            outfile.write(' isNonObservationalTimeAttribute="%s"' % self.gds_format_boolean(self.isNonObservationalTimeAttribute, input_name='isNonObservationalTimeAttribute'))
        if self.isCountAttribute is not None and 'isCountAttribute' not in already_processed:
            already_processed.add('isCountAttribute')
            outfile.write(' isCountAttribute="%s"' % self.gds_format_boolean(self.isCountAttribute, input_name='isCountAttribute'))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.isIdentityAttribute is not None and 'isIdentityAttribute' not in already_processed:
            already_processed.add('isIdentityAttribute')
            outfile.write(' isIdentityAttribute="%s"' % self.gds_format_boolean(self.isIdentityAttribute, input_name='isIdentityAttribute'))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            outfile.write(' codelistVersion=%s' % (self.gds_format_string(quote_attrib(self.codelistVersion).encode(ExternalEncoding), input_name='codelistVersion'), ))
        if self.assignmentStatus is not None and 'assignmentStatus' not in already_processed:
            already_processed.add('assignmentStatus')
            outfile.write(' assignmentStatus=%s' % (quote_attrib(self.assignmentStatus), ))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            outfile.write(' crossSectionalAttachGroup="%s"' % self.gds_format_boolean(self.crossSectionalAttachGroup, input_name='crossSectionalAttachGroup'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        for AttachmentGroup_ in self.AttachmentGroup:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentGroup>%s</%sAttachmentGroup>%s' % (namespace_, self.gds_format_string(quote_xml(AttachmentGroup_).encode(ExternalEncoding), input_name='AttachmentGroup'), namespace_, eol_))
        for AttachmentMeasure_ in self.AttachmentMeasure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAttachmentMeasure>%s</%sAttachmentMeasure>%s' % (namespace_, self.gds_format_string(quote_xml(AttachmentMeasure_).encode(ExternalEncoding), input_name='AttachmentMeasure'), namespace_, eol_))
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.crossSectionalAttachDataSet is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachDataSet=%s,\n' % (self.crossSectionalAttachDataSet,))
        if self.isEntityAttribute is not None and 'isEntityAttribute' not in already_processed:
            already_processed.add('isEntityAttribute')
            showIndent(outfile, level)
            outfile.write('isEntityAttribute=%s,\n' % (self.isEntityAttribute,))
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            showIndent(outfile, level)
            outfile.write('codelist=%s,\n' % (self.codelist,))
        if self.isTimeFormat is not None and 'isTimeFormat' not in already_processed:
            already_processed.add('isTimeFormat')
            showIndent(outfile, level)
            outfile.write('isTimeFormat=%s,\n' % (self.isTimeFormat,))
        if self.crossSectionalAttachObservation is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachObservation=%s,\n' % (self.crossSectionalAttachObservation,))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.attachmentLevel is not None and 'attachmentLevel' not in already_processed:
            already_processed.add('attachmentLevel')
            showIndent(outfile, level)
            outfile.write('attachmentLevel=%s,\n' % (self.attachmentLevel,))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            showIndent(outfile, level)
            outfile.write('codelistAgency=%s,\n' % (self.codelistAgency,))
        if self.isFrequencyAttribute is not None and 'isFrequencyAttribute' not in already_processed:
            already_processed.add('isFrequencyAttribute')
            showIndent(outfile, level)
            outfile.write('isFrequencyAttribute=%s,\n' % (self.isFrequencyAttribute,))
        if self.crossSectionalAttachSection is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachSection=%s,\n' % (self.crossSectionalAttachSection,))
        if self.isNonObservationalTimeAttribute is not None and 'isNonObservationalTimeAttribute' not in already_processed:
            already_processed.add('isNonObservationalTimeAttribute')
            showIndent(outfile, level)
            outfile.write('isNonObservationalTimeAttribute=%s,\n' % (self.isNonObservationalTimeAttribute,))
        if self.isCountAttribute is not None and 'isCountAttribute' not in already_processed:
            already_processed.add('isCountAttribute')
            showIndent(outfile, level)
            outfile.write('isCountAttribute=%s,\n' % (self.isCountAttribute,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.isIdentityAttribute is not None and 'isIdentityAttribute' not in already_processed:
            already_processed.add('isIdentityAttribute')
            showIndent(outfile, level)
            outfile.write('isIdentityAttribute=%s,\n' % (self.isIdentityAttribute,))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            showIndent(outfile, level)
            outfile.write('codelistVersion="%s",\n' % (self.codelistVersion,))
        if self.assignmentStatus is not None and 'assignmentStatus' not in already_processed:
            already_processed.add('assignmentStatus')
            showIndent(outfile, level)
            outfile.write('assignmentStatus=%s,\n' % (self.assignmentStatus,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
        if self.crossSectionalAttachGroup is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            showIndent(outfile, level)
            outfile.write('crossSectionalAttachGroup=%s,\n' % (self.crossSectionalAttachGroup,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('AttachmentGroup=[\n')
        level += 1
        for AttachmentGroup_ in self.AttachmentGroup:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AttachmentGroup_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AttachmentMeasure=[\n')
        level += 1
        for AttachmentMeasure_ in self.AttachmentMeasure:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AttachmentMeasure_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('crossSectionalAttachDataSet', node)
        if value is not None and 'crossSectionalAttachDataSet' not in already_processed:
            already_processed.add('crossSectionalAttachDataSet')
            if value in ('true', '1'):
                self.crossSectionalAttachDataSet = True
            elif value in ('false', '0'):
                self.crossSectionalAttachDataSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isEntityAttribute', node)
        if value is not None and 'isEntityAttribute' not in already_processed:
            already_processed.add('isEntityAttribute')
            if value in ('true', '1'):
                self.isEntityAttribute = True
            elif value in ('false', '0'):
                self.isEntityAttribute = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('codelist', node)
        if value is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            self.codelist = value
        value = find_attr_value_('isTimeFormat', node)
        if value is not None and 'isTimeFormat' not in already_processed:
            already_processed.add('isTimeFormat')
            if value in ('true', '1'):
                self.isTimeFormat = True
            elif value in ('false', '0'):
                self.isTimeFormat = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('crossSectionalAttachObservation', node)
        if value is not None and 'crossSectionalAttachObservation' not in already_processed:
            already_processed.add('crossSectionalAttachObservation')
            if value in ('true', '1'):
                self.crossSectionalAttachObservation = True
            elif value in ('false', '0'):
                self.crossSectionalAttachObservation = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('attachmentLevel', node)
        if value is not None and 'attachmentLevel' not in already_processed:
            already_processed.add('attachmentLevel')
            self.attachmentLevel = value
        value = find_attr_value_('codelistAgency', node)
        if value is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            self.codelistAgency = value
        value = find_attr_value_('isFrequencyAttribute', node)
        if value is not None and 'isFrequencyAttribute' not in already_processed:
            already_processed.add('isFrequencyAttribute')
            if value in ('true', '1'):
                self.isFrequencyAttribute = True
            elif value in ('false', '0'):
                self.isFrequencyAttribute = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('crossSectionalAttachSection', node)
        if value is not None and 'crossSectionalAttachSection' not in already_processed:
            already_processed.add('crossSectionalAttachSection')
            if value in ('true', '1'):
                self.crossSectionalAttachSection = True
            elif value in ('false', '0'):
                self.crossSectionalAttachSection = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isNonObservationalTimeAttribute', node)
        if value is not None and 'isNonObservationalTimeAttribute' not in already_processed:
            already_processed.add('isNonObservationalTimeAttribute')
            if value in ('true', '1'):
                self.isNonObservationalTimeAttribute = True
            elif value in ('false', '0'):
                self.isNonObservationalTimeAttribute = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isCountAttribute', node)
        if value is not None and 'isCountAttribute' not in already_processed:
            already_processed.add('isCountAttribute')
            if value in ('true', '1'):
                self.isCountAttribute = True
            elif value in ('false', '0'):
                self.isCountAttribute = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('isIdentityAttribute', node)
        if value is not None and 'isIdentityAttribute' not in already_processed:
            already_processed.add('isIdentityAttribute')
            if value in ('true', '1'):
                self.isIdentityAttribute = True
            elif value in ('false', '0'):
                self.isIdentityAttribute = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('codelistVersion', node)
        if value is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            self.codelistVersion = value
        value = find_attr_value_('assignmentStatus', node)
        if value is not None and 'assignmentStatus' not in already_processed:
            already_processed.add('assignmentStatus')
            self.assignmentStatus = value
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
        value = find_attr_value_('crossSectionalAttachGroup', node)
        if value is not None and 'crossSectionalAttachGroup' not in already_processed:
            already_processed.add('crossSectionalAttachGroup')
            if value in ('true', '1'):
                self.crossSectionalAttachGroup = True
            elif value in ('false', '0'):
                self.crossSectionalAttachGroup = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'AttachmentGroup':
            AttachmentGroup_ = child_.text
            AttachmentGroup_ = self.gds_validate_string(AttachmentGroup_, node, 'AttachmentGroup')
            self.AttachmentGroup.append(AttachmentGroup_)
            self.validate_IDType(self.AttachmentGroup)    # validate type IDType
        elif nodeName_ == 'AttachmentMeasure':
            AttachmentMeasure_ = child_.text
            AttachmentMeasure_ = self.gds_validate_string(AttachmentMeasure_, node, 'AttachmentMeasure')
            self.AttachmentMeasure.append(AttachmentMeasure_)
            self.validate_IDType(self.AttachmentMeasure)    # validate type IDType
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class AttributeType


class PrimaryMeasureType(GeneratedsSuper):
    """PrimaryMeasureType describes the observation values for all
    presentations of the data, except those cross-sectional formats
    which have multiple measures (for which a set of cross-sectional
    measures are used instead). The concept attribute points to the
    unique concept represented by the measure. The PrimaryMeasure is
    conventionally associated with the OBS-VALUE concept. The
    TextFormat element allows description of the contents of the
    observation value. The codelist attribute references a codelist
    if the observation value is coded. If this attribute is used,
    then codelistAgencyID must contain the ID of the maintenance
    agency of the referenced codelist. The codelistVersion attribute
    may be specified - if not, then the version of the referenced
    codelist is assumed to be "1.0"."""
    subclass = None
    superclass = None
    def __init__(self, codelist=None, conceptSchemeAgency=None, codelistAgency=None, conceptRef=None, conceptAgency=None, codelistVersion=None, conceptSchemeRef=None, conceptVersion=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.codelist = _cast(None, codelist)
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.codelistAgency = _cast(None, codelistAgency)
        self.conceptRef = _cast(None, conceptRef)
        self.conceptAgency = _cast(None, conceptAgency)
        self.codelistVersion = _cast(None, codelistVersion)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if PrimaryMeasureType.subclass:
            return PrimaryMeasureType.subclass(*args_, **kwargs_)
        else:
            return PrimaryMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_codelist(self): return self.codelist
    def set_codelist(self, codelist): self.codelist = codelist
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_codelistAgency(self): return self.codelistAgency
    def set_codelistAgency(self, codelistAgency): self.codelistAgency = codelistAgency
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_codelistVersion(self): return self.codelistVersion
    def set_codelistVersion(self, codelistVersion): self.codelistVersion = codelistVersion
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def hasContent_(self):
        if (
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='PrimaryMeasureType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PrimaryMeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='PrimaryMeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='PrimaryMeasureType'):
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            outfile.write(' codelist=%s' % (quote_attrib(self.codelist), ))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            outfile.write(' codelistAgency=%s' % (quote_attrib(self.codelistAgency), ))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            outfile.write(' codelistVersion=%s' % (self.gds_format_string(quote_attrib(self.codelistVersion).encode(ExternalEncoding), input_name='codelistVersion'), ))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='PrimaryMeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PrimaryMeasureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            showIndent(outfile, level)
            outfile.write('codelist=%s,\n' % (self.codelist,))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            showIndent(outfile, level)
            outfile.write('codelistAgency=%s,\n' % (self.codelistAgency,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            showIndent(outfile, level)
            outfile.write('codelistVersion="%s",\n' % (self.codelistVersion,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codelist', node)
        if value is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            self.codelist = value
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('codelistAgency', node)
        if value is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            self.codelistAgency = value
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('codelistVersion', node)
        if value is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            self.codelistVersion = value
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class PrimaryMeasureType


class CrossSectionalMeasureType(GeneratedsSuper):
    """CrossSectionalMeasureType describes the observation values for
    multiple-measure cross-sectional data formats. For non-cross
    sectional key families, it is not necesary to specify any cross-
    sectional measures.The concept attribute points to the unique
    concept represented by the measure. The measureDimension
    attribute contains the concept name of the measure dimension.
    The code attribute contains the value of its corresponding code
    in the codelist used to represent the measure dimension. A
    CrossSectionalMeasure must be declared for each code in the
    codelist used to represent the measure dimension - these will
    replace the primary measure for multiple-measure cross-sectional
    data formats.The TextFormat element allows description of the
    contents of the observation value. The codelist attribute
    references a codelist if the observation value is coded. If this
    attribute is used, then codelistAgencyID must contain the ID of
    the maintenance agency of the referenced codelist. The
    codelistVersion attribute may be specified - if not, then the
    version of the referenced codelist is assumed to be "1.0"."""
    subclass = None
    superclass = None
    def __init__(self, codelist=None, conceptSchemeAgency=None, codelistAgency=None, conceptRef=None, code=None, conceptAgency=None, codelistVersion=None, measureDimension=None, conceptSchemeRef=None, conceptVersion=None, TextFormat=None, Annotations=None):
        self.original_tagname_ = None
        self.codelist = _cast(None, codelist)
        self.conceptSchemeAgency = _cast(None, conceptSchemeAgency)
        self.codelistAgency = _cast(None, codelistAgency)
        self.conceptRef = _cast(None, conceptRef)
        self.code = _cast(None, code)
        self.conceptAgency = _cast(None, conceptAgency)
        self.codelistVersion = _cast(None, codelistVersion)
        self.measureDimension = _cast(None, measureDimension)
        self.conceptSchemeRef = _cast(None, conceptSchemeRef)
        self.conceptVersion = _cast(None, conceptVersion)
        self.TextFormat = TextFormat
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CrossSectionalMeasureType.subclass:
            return CrossSectionalMeasureType.subclass(*args_, **kwargs_)
        else:
            return CrossSectionalMeasureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TextFormat(self): return self.TextFormat
    def set_TextFormat(self, TextFormat): self.TextFormat = TextFormat
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_codelist(self): return self.codelist
    def set_codelist(self, codelist): self.codelist = codelist
    def get_conceptSchemeAgency(self): return self.conceptSchemeAgency
    def set_conceptSchemeAgency(self, conceptSchemeAgency): self.conceptSchemeAgency = conceptSchemeAgency
    def get_codelistAgency(self): return self.codelistAgency
    def set_codelistAgency(self, codelistAgency): self.codelistAgency = codelistAgency
    def get_conceptRef(self): return self.conceptRef
    def set_conceptRef(self, conceptRef): self.conceptRef = conceptRef
    def get_code(self): return self.code
    def set_code(self, code): self.code = code
    def get_conceptAgency(self): return self.conceptAgency
    def set_conceptAgency(self, conceptAgency): self.conceptAgency = conceptAgency
    def get_codelistVersion(self): return self.codelistVersion
    def set_codelistVersion(self, codelistVersion): self.codelistVersion = codelistVersion
    def get_measureDimension(self): return self.measureDimension
    def set_measureDimension(self, measureDimension): self.measureDimension = measureDimension
    def get_conceptSchemeRef(self): return self.conceptSchemeRef
    def set_conceptSchemeRef(self, conceptSchemeRef): self.conceptSchemeRef = conceptSchemeRef
    def get_conceptVersion(self): return self.conceptVersion
    def set_conceptVersion(self, conceptVersion): self.conceptVersion = conceptVersion
    def hasContent_(self):
        if (
            self.TextFormat is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CrossSectionalMeasureType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CrossSectionalMeasureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CrossSectionalMeasureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CrossSectionalMeasureType'):
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            outfile.write(' codelist=%s' % (quote_attrib(self.codelist), ))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            outfile.write(' conceptSchemeAgency=%s' % (quote_attrib(self.conceptSchemeAgency), ))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            outfile.write(' codelistAgency=%s' % (quote_attrib(self.codelistAgency), ))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            outfile.write(' conceptRef=%s' % (quote_attrib(self.conceptRef), ))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            outfile.write(' code=%s' % (quote_attrib(self.code), ))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            outfile.write(' conceptAgency=%s' % (quote_attrib(self.conceptAgency), ))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            outfile.write(' codelistVersion=%s' % (self.gds_format_string(quote_attrib(self.codelistVersion).encode(ExternalEncoding), input_name='codelistVersion'), ))
        if self.measureDimension is not None and 'measureDimension' not in already_processed:
            already_processed.add('measureDimension')
            outfile.write(' measureDimension=%s' % (quote_attrib(self.measureDimension), ))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            outfile.write(' conceptSchemeRef=%s' % (quote_attrib(self.conceptSchemeRef), ))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            outfile.write(' conceptVersion=%s' % (self.gds_format_string(quote_attrib(self.conceptVersion).encode(ExternalEncoding), input_name='conceptVersion'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CrossSectionalMeasureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TextFormat is not None:
            self.TextFormat.export(outfile, level, namespace_, name_='TextFormat', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CrossSectionalMeasureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.codelist is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            showIndent(outfile, level)
            outfile.write('codelist=%s,\n' % (self.codelist,))
        if self.conceptSchemeAgency is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            showIndent(outfile, level)
            outfile.write('conceptSchemeAgency=%s,\n' % (self.conceptSchemeAgency,))
        if self.codelistAgency is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            showIndent(outfile, level)
            outfile.write('codelistAgency=%s,\n' % (self.codelistAgency,))
        if self.conceptRef is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            showIndent(outfile, level)
            outfile.write('conceptRef=%s,\n' % (self.conceptRef,))
        if self.code is not None and 'code' not in already_processed:
            already_processed.add('code')
            showIndent(outfile, level)
            outfile.write('code=%s,\n' % (self.code,))
        if self.conceptAgency is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            showIndent(outfile, level)
            outfile.write('conceptAgency=%s,\n' % (self.conceptAgency,))
        if self.codelistVersion is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            showIndent(outfile, level)
            outfile.write('codelistVersion="%s",\n' % (self.codelistVersion,))
        if self.measureDimension is not None and 'measureDimension' not in already_processed:
            already_processed.add('measureDimension')
            showIndent(outfile, level)
            outfile.write('measureDimension=%s,\n' % (self.measureDimension,))
        if self.conceptSchemeRef is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('conceptSchemeRef=%s,\n' % (self.conceptSchemeRef,))
        if self.conceptVersion is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            showIndent(outfile, level)
            outfile.write('conceptVersion="%s",\n' % (self.conceptVersion,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TextFormat is not None:
            showIndent(outfile, level)
            outfile.write('TextFormat=model_.TextFormatType(\n')
            self.TextFormat.exportLiteral(outfile, level, name_='TextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('codelist', node)
        if value is not None and 'codelist' not in already_processed:
            already_processed.add('codelist')
            self.codelist = value
        value = find_attr_value_('conceptSchemeAgency', node)
        if value is not None and 'conceptSchemeAgency' not in already_processed:
            already_processed.add('conceptSchemeAgency')
            self.conceptSchemeAgency = value
        value = find_attr_value_('codelistAgency', node)
        if value is not None and 'codelistAgency' not in already_processed:
            already_processed.add('codelistAgency')
            self.codelistAgency = value
        value = find_attr_value_('conceptRef', node)
        if value is not None and 'conceptRef' not in already_processed:
            already_processed.add('conceptRef')
            self.conceptRef = value
        value = find_attr_value_('code', node)
        if value is not None and 'code' not in already_processed:
            already_processed.add('code')
            self.code = value
        value = find_attr_value_('conceptAgency', node)
        if value is not None and 'conceptAgency' not in already_processed:
            already_processed.add('conceptAgency')
            self.conceptAgency = value
        value = find_attr_value_('codelistVersion', node)
        if value is not None and 'codelistVersion' not in already_processed:
            already_processed.add('codelistVersion')
            self.codelistVersion = value
        value = find_attr_value_('measureDimension', node)
        if value is not None and 'measureDimension' not in already_processed:
            already_processed.add('measureDimension')
            self.measureDimension = value
        value = find_attr_value_('conceptSchemeRef', node)
        if value is not None and 'conceptSchemeRef' not in already_processed:
            already_processed.add('conceptSchemeRef')
            self.conceptSchemeRef = value
        value = find_attr_value_('conceptVersion', node)
        if value is not None and 'conceptVersion' not in already_processed:
            already_processed.add('conceptVersion')
            self.conceptVersion = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.TextFormat = obj_
            obj_.original_tagname_ = 'TextFormat'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CrossSectionalMeasureType


class StructureSetsType(GeneratedsSuper):
    """StructureSetsType contains one or more structure sets."""
    subclass = None
    superclass = None
    def __init__(self, StructureSet=None):
        self.original_tagname_ = None
        if StructureSet is None:
            self.StructureSet = []
        else:
            self.StructureSet = StructureSet
    def factory(*args_, **kwargs_):
        if StructureSetsType.subclass:
            return StructureSetsType.subclass(*args_, **kwargs_)
        else:
            return StructureSetsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StructureSet(self): return self.StructureSet
    def set_StructureSet(self, StructureSet): self.StructureSet = StructureSet
    def add_StructureSet(self, value): self.StructureSet.append(value)
    def insert_StructureSet_at(self, index, value): self.StructureSet.insert(index, value)
    def replace_StructureSet_at(self, index, value): self.StructureSet[index] = value
    def hasContent_(self):
        if (
            self.StructureSet
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureSetsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureSetsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureSetsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureSetsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureSetsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for StructureSet_ in self.StructureSet:
            StructureSet_.export(outfile, level, namespace_, name_='StructureSet', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StructureSetsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StructureSet=[\n')
        level += 1
        for StructureSet_ in self.StructureSet:
            showIndent(outfile, level)
            outfile.write('model_.StructureSetType(\n')
            StructureSet_.exportLiteral(outfile, level, name_='StructureSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StructureSet':
            obj_ = StructureSetType.factory()
            obj_.build(child_)
            self.StructureSet.append(obj_)
            obj_.original_tagname_ = 'StructureSet'
# end class StructureSetsType


class StructureSetType(GeneratedsSuper):
    """StructureSetType describes the relationships between two or more key
    families and/or metadata structure definitions, including the
    mapping between category schemes and concept schemes, to provide
    for the mapping of representations. This can include inheritance
    and extension of properties, or total or partial equivalencies.
    It also includes mapping of concepts existing in metadata
    structure definitions to those used in key families, and vice-
    versa. A human-readable name is provided in the Name element,
    which may include several language-specific variants. A longer
    human-readable description may also be provided, in the
    Description element, which may also have language-specific
    variants provided. The Annotations element may be used to
    provide annotations. The StructureRefs element references all of
    the key families and/or metadata structure definitions included
    in the Structure Set - these must be provided if a StructureMap
    element is used, but is not required if the structure set is
    only used to provide codelist mappings, concept mappings, or
    category mappings. The StructureMap element indicates which
    components in the included data and metadata structures are
    equivalent; CodelistMap indicates which codes map to other
    codelists. CategorySchemeMap indicates which categories in one
    scheme map to those in another scheme. ConceptSchemeMap
    indicates which concepts in one scheme map to those in another
    scheme. OrganisationSchemeMap describes how one organisation
    scheme maps to another. The id attribute takes an id which is
    unique to all structure sets maintained by the agency specified
    in the agency attribute. version specifies a version number (by
    default "1.0"). The uri attribute holds a URL where a valid SDMX
    Structure messgae can be found which provides full details of
    the StructureSet, and it must be used if the isExternalReference
    attribute has a value of true. The urn attribute holds a valid
    SDMX Registry URN as described in the SDMX Registry
    specification. A true value in the isFinal attribute indicates
    that the contents of the structure set may not be changed
    without versioning. The validFrom and validTo attributes provide
    inclusive dates for providing supplemental validity information
    about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, RelatedStructures=None, StructureMap=None, CodelistMap=None, CategorySchemeMap=None, ConceptSchemeMap=None, OrganisationSchemeMap=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.RelatedStructures = RelatedStructures
        self.StructureMap = StructureMap
        self.CodelistMap = CodelistMap
        self.CategorySchemeMap = CategorySchemeMap
        self.ConceptSchemeMap = ConceptSchemeMap
        self.OrganisationSchemeMap = OrganisationSchemeMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if StructureSetType.subclass:
            return StructureSetType.subclass(*args_, **kwargs_)
        else:
            return StructureSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_RelatedStructures(self): return self.RelatedStructures
    def set_RelatedStructures(self, RelatedStructures): self.RelatedStructures = RelatedStructures
    def get_StructureMap(self): return self.StructureMap
    def set_StructureMap(self, StructureMap): self.StructureMap = StructureMap
    def get_CodelistMap(self): return self.CodelistMap
    def set_CodelistMap(self, CodelistMap): self.CodelistMap = CodelistMap
    def get_CategorySchemeMap(self): return self.CategorySchemeMap
    def set_CategorySchemeMap(self, CategorySchemeMap): self.CategorySchemeMap = CategorySchemeMap
    def get_ConceptSchemeMap(self): return self.ConceptSchemeMap
    def set_ConceptSchemeMap(self, ConceptSchemeMap): self.ConceptSchemeMap = ConceptSchemeMap
    def get_OrganisationSchemeMap(self): return self.OrganisationSchemeMap
    def set_OrganisationSchemeMap(self, OrganisationSchemeMap): self.OrganisationSchemeMap = OrganisationSchemeMap
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.RelatedStructures is not None or
            self.StructureMap is not None or
            self.CodelistMap is not None or
            self.CategorySchemeMap is not None or
            self.ConceptSchemeMap is not None or
            self.OrganisationSchemeMap is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureSetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureSetType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.RelatedStructures is not None:
            self.RelatedStructures.export(outfile, level, namespace_, name_='RelatedStructures', pretty_print=pretty_print)
        if self.StructureMap is not None:
            self.StructureMap.export(outfile, level, namespace_, name_='StructureMap', pretty_print=pretty_print)
        if self.CodelistMap is not None:
            self.CodelistMap.export(outfile, level, namespace_, name_='CodelistMap', pretty_print=pretty_print)
        if self.CategorySchemeMap is not None:
            self.CategorySchemeMap.export(outfile, level, namespace_, name_='CategorySchemeMap', pretty_print=pretty_print)
        if self.ConceptSchemeMap is not None:
            self.ConceptSchemeMap.export(outfile, level, namespace_, name_='ConceptSchemeMap', pretty_print=pretty_print)
        if self.OrganisationSchemeMap is not None:
            self.OrganisationSchemeMap.export(outfile, level, namespace_, name_='OrganisationSchemeMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StructureSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.RelatedStructures is not None:
            showIndent(outfile, level)
            outfile.write('RelatedStructures=model_.RelatedStructuresType(\n')
            self.RelatedStructures.exportLiteral(outfile, level, name_='RelatedStructures')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureMap is not None:
            showIndent(outfile, level)
            outfile.write('StructureMap=model_.StructureMapType(\n')
            self.StructureMap.exportLiteral(outfile, level, name_='StructureMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CodelistMap is not None:
            showIndent(outfile, level)
            outfile.write('CodelistMap=model_.CodelistMapType(\n')
            self.CodelistMap.exportLiteral(outfile, level, name_='CodelistMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CategorySchemeMap is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeMap=model_.CategorySchemeMapType(\n')
            self.CategorySchemeMap.exportLiteral(outfile, level, name_='CategorySchemeMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConceptSchemeMap is not None:
            showIndent(outfile, level)
            outfile.write('ConceptSchemeMap=model_.ConceptSchemeMapType(\n')
            self.ConceptSchemeMap.exportLiteral(outfile, level, name_='ConceptSchemeMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationSchemeMap is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeMap=model_.OrganisationSchemeMapType(\n')
            self.OrganisationSchemeMap.exportLiteral(outfile, level, name_='OrganisationSchemeMap')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'RelatedStructures':
            obj_ = RelatedStructuresType.factory()
            obj_.build(child_)
            self.RelatedStructures = obj_
            obj_.original_tagname_ = 'RelatedStructures'
        elif nodeName_ == 'StructureMap':
            obj_ = StructureMapType.factory()
            obj_.build(child_)
            self.StructureMap = obj_
            obj_.original_tagname_ = 'StructureMap'
        elif nodeName_ == 'CodelistMap':
            obj_ = CodelistMapType.factory()
            obj_.build(child_)
            self.CodelistMap = obj_
            obj_.original_tagname_ = 'CodelistMap'
        elif nodeName_ == 'CategorySchemeMap':
            obj_ = CategorySchemeMapType.factory()
            obj_.build(child_)
            self.CategorySchemeMap = obj_
            obj_.original_tagname_ = 'CategorySchemeMap'
        elif nodeName_ == 'ConceptSchemeMap':
            obj_ = ConceptSchemeMapType.factory()
            obj_.build(child_)
            self.ConceptSchemeMap = obj_
            obj_.original_tagname_ = 'ConceptSchemeMap'
        elif nodeName_ == 'OrganisationSchemeMap':
            obj_ = OrganisationSchemeMapType.factory()
            obj_.build(child_)
            self.OrganisationSchemeMap = obj_
            obj_.original_tagname_ = 'OrganisationSchemeMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class StructureSetType


class RelatedStructuresType(GeneratedsSuper):
    """RelatedStructuresType includes references to key families (in the
    KeyFamilyRef element) and/or metadata structure definitions (In
    the MetadataStructureRef element). Any mapped CategorySchemes,
    ConceptSchemes, or Organisation Schemes should also be
    referenced. HierarchicalCodelistRef allows for
    HierarchicalCodelists which describe relationships between
    pertinent codelists to be referenced and included in the
    structure set - this must be used if the CodelistMap in the
    StructureSet refers to any hierarchical codelists."""
    subclass = None
    superclass = None
    def __init__(self, KeyFamilyRef=None, MetadataStructureRef=None, ConceptSchemeRef=None, CategorySchemeRef=None, OrganisationSchemeRef=None, HierarchicalCodelistRef=None):
        self.original_tagname_ = None
        if KeyFamilyRef is None:
            self.KeyFamilyRef = []
        else:
            self.KeyFamilyRef = KeyFamilyRef
        if MetadataStructureRef is None:
            self.MetadataStructureRef = []
        else:
            self.MetadataStructureRef = MetadataStructureRef
        if ConceptSchemeRef is None:
            self.ConceptSchemeRef = []
        else:
            self.ConceptSchemeRef = ConceptSchemeRef
        if CategorySchemeRef is None:
            self.CategorySchemeRef = []
        else:
            self.CategorySchemeRef = CategorySchemeRef
        if OrganisationSchemeRef is None:
            self.OrganisationSchemeRef = []
        else:
            self.OrganisationSchemeRef = OrganisationSchemeRef
        if HierarchicalCodelistRef is None:
            self.HierarchicalCodelistRef = []
        else:
            self.HierarchicalCodelistRef = HierarchicalCodelistRef
    def factory(*args_, **kwargs_):
        if RelatedStructuresType.subclass:
            return RelatedStructuresType.subclass(*args_, **kwargs_)
        else:
            return RelatedStructuresType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def add_KeyFamilyRef(self, value): self.KeyFamilyRef.append(value)
    def insert_KeyFamilyRef_at(self, index, value): self.KeyFamilyRef.insert(index, value)
    def replace_KeyFamilyRef_at(self, index, value): self.KeyFamilyRef[index] = value
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def add_MetadataStructureRef(self, value): self.MetadataStructureRef.append(value)
    def insert_MetadataStructureRef_at(self, index, value): self.MetadataStructureRef.insert(index, value)
    def replace_MetadataStructureRef_at(self, index, value): self.MetadataStructureRef[index] = value
    def get_ConceptSchemeRef(self): return self.ConceptSchemeRef
    def set_ConceptSchemeRef(self, ConceptSchemeRef): self.ConceptSchemeRef = ConceptSchemeRef
    def add_ConceptSchemeRef(self, value): self.ConceptSchemeRef.append(value)
    def insert_ConceptSchemeRef_at(self, index, value): self.ConceptSchemeRef.insert(index, value)
    def replace_ConceptSchemeRef_at(self, index, value): self.ConceptSchemeRef[index] = value
    def get_CategorySchemeRef(self): return self.CategorySchemeRef
    def set_CategorySchemeRef(self, CategorySchemeRef): self.CategorySchemeRef = CategorySchemeRef
    def add_CategorySchemeRef(self, value): self.CategorySchemeRef.append(value)
    def insert_CategorySchemeRef_at(self, index, value): self.CategorySchemeRef.insert(index, value)
    def replace_CategorySchemeRef_at(self, index, value): self.CategorySchemeRef[index] = value
    def get_OrganisationSchemeRef(self): return self.OrganisationSchemeRef
    def set_OrganisationSchemeRef(self, OrganisationSchemeRef): self.OrganisationSchemeRef = OrganisationSchemeRef
    def add_OrganisationSchemeRef(self, value): self.OrganisationSchemeRef.append(value)
    def insert_OrganisationSchemeRef_at(self, index, value): self.OrganisationSchemeRef.insert(index, value)
    def replace_OrganisationSchemeRef_at(self, index, value): self.OrganisationSchemeRef[index] = value
    def get_HierarchicalCodelistRef(self): return self.HierarchicalCodelistRef
    def set_HierarchicalCodelistRef(self, HierarchicalCodelistRef): self.HierarchicalCodelistRef = HierarchicalCodelistRef
    def add_HierarchicalCodelistRef(self, value): self.HierarchicalCodelistRef.append(value)
    def insert_HierarchicalCodelistRef_at(self, index, value): self.HierarchicalCodelistRef.insert(index, value)
    def replace_HierarchicalCodelistRef_at(self, index, value): self.HierarchicalCodelistRef[index] = value
    def hasContent_(self):
        if (
            self.KeyFamilyRef or
            self.MetadataStructureRef or
            self.ConceptSchemeRef or
            self.CategorySchemeRef or
            self.OrganisationSchemeRef or
            self.HierarchicalCodelistRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RelatedStructuresType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RelatedStructuresType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RelatedStructuresType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RelatedStructuresType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='RelatedStructuresType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyFamilyRef_ in self.KeyFamilyRef:
            KeyFamilyRef_.export(outfile, level, namespace_, name_='KeyFamilyRef', pretty_print=pretty_print)
        for MetadataStructureRef_ in self.MetadataStructureRef:
            MetadataStructureRef_.export(outfile, level, namespace_, name_='MetadataStructureRef', pretty_print=pretty_print)
        for ConceptSchemeRef_ in self.ConceptSchemeRef:
            ConceptSchemeRef_.export(outfile, level, namespace_, name_='ConceptSchemeRef', pretty_print=pretty_print)
        for CategorySchemeRef_ in self.CategorySchemeRef:
            CategorySchemeRef_.export(outfile, level, namespace_, name_='CategorySchemeRef', pretty_print=pretty_print)
        for OrganisationSchemeRef_ in self.OrganisationSchemeRef:
            OrganisationSchemeRef_.export(outfile, level, namespace_, name_='OrganisationSchemeRef', pretty_print=pretty_print)
        for HierarchicalCodelistRef_ in self.HierarchicalCodelistRef:
            HierarchicalCodelistRef_.export(outfile, level, namespace_, name_='HierarchicalCodelistRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RelatedStructuresType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('KeyFamilyRef=[\n')
        level += 1
        for KeyFamilyRef_ in self.KeyFamilyRef:
            showIndent(outfile, level)
            outfile.write('model_.KeyFamilyRefType(\n')
            KeyFamilyRef_.exportLiteral(outfile, level, name_='KeyFamilyRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructureRef=[\n')
        level += 1
        for MetadataStructureRef_ in self.MetadataStructureRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataStructureRefType(\n')
            MetadataStructureRef_.exportLiteral(outfile, level, name_='MetadataStructureRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptSchemeRef=[\n')
        level += 1
        for ConceptSchemeRef_ in self.ConceptSchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.ConceptSchemeRefType(\n')
            ConceptSchemeRef_.exportLiteral(outfile, level, name_='ConceptSchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeRef=[\n')
        level += 1
        for CategorySchemeRef_ in self.CategorySchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.CategorySchemeRefType(\n')
            CategorySchemeRef_.exportLiteral(outfile, level, name_='CategorySchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OrganisationSchemeRef=[\n')
        level += 1
        for OrganisationSchemeRef_ in self.OrganisationSchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationSchemeRefType(\n')
            OrganisationSchemeRef_.exportLiteral(outfile, level, name_='OrganisationSchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HierarchicalCodelistRef=[\n')
        level += 1
        for HierarchicalCodelistRef_ in self.HierarchicalCodelistRef:
            showIndent(outfile, level)
            outfile.write('model_.HierarchicalCodelistRefType(\n')
            HierarchicalCodelistRef_.exportLiteral(outfile, level, name_='HierarchicalCodelistRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.KeyFamilyRef.append(obj_)
            obj_.original_tagname_ = 'KeyFamilyRef'
        elif nodeName_ == 'MetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.MetadataStructureRef.append(obj_)
            obj_.original_tagname_ = 'MetadataStructureRef'
        elif nodeName_ == 'ConceptSchemeRef':
            obj_ = ConceptSchemeRefType.factory()
            obj_.build(child_)
            self.ConceptSchemeRef.append(obj_)
            obj_.original_tagname_ = 'ConceptSchemeRef'
        elif nodeName_ == 'CategorySchemeRef':
            obj_ = CategorySchemeRefType.factory()
            obj_.build(child_)
            self.CategorySchemeRef.append(obj_)
            obj_.original_tagname_ = 'CategorySchemeRef'
        elif nodeName_ == 'OrganisationSchemeRef':
            obj_ = OrganisationSchemeRefType.factory()
            obj_.build(child_)
            self.OrganisationSchemeRef.append(obj_)
            obj_.original_tagname_ = 'OrganisationSchemeRef'
        elif nodeName_ == 'HierarchicalCodelistRef':
            obj_ = HierarchicalCodelistRefType.factory()
            obj_.build(child_)
            self.HierarchicalCodelistRef.append(obj_)
            obj_.original_tagname_ = 'HierarchicalCodelistRef'
# end class RelatedStructuresType


class CategorySchemeRefType(GeneratedsSuper):
    """CategorySchemeRef allows for references to specific category
    schemes. At a minimum, either the URN - which contains a valid
    Registry/Repository URN - or the rest of the child elements must
    be supplied."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, CategorySchemeID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.CategorySchemeID = CategorySchemeID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if CategorySchemeRefType.subclass:
            return CategorySchemeRefType.subclass(*args_, **kwargs_)
        else:
            return CategorySchemeRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_CategorySchemeID(self): return self.CategorySchemeID
    def set_CategorySchemeID(self, CategorySchemeID): self.CategorySchemeID = CategorySchemeID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.CategorySchemeID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategorySchemeRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategorySchemeRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategorySchemeRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategorySchemeRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategorySchemeRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.CategorySchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeID>%s</%sCategorySchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.CategorySchemeID).encode(ExternalEncoding), input_name='CategorySchemeID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CategorySchemeRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.CategorySchemeID is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeID=%s,\n' % quote_python(self.CategorySchemeID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'CategorySchemeID':
            CategorySchemeID_ = child_.text
            CategorySchemeID_ = self.gds_validate_string(CategorySchemeID_, node, 'CategorySchemeID')
            self.CategorySchemeID = CategorySchemeID_
            self.validate_IDType(self.CategorySchemeID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class CategorySchemeRefType


class ConceptSchemeRefType(GeneratedsSuper):
    """ConceptSchemeRef allows for references to specific concept schemes.
    At a minimum, either the URN - which contains a valid
    Registry/Repository URN - or the rest of the child elements must
    be supplied."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, ConceptSchemeID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.ConceptSchemeID = ConceptSchemeID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ConceptSchemeRefType.subclass:
            return ConceptSchemeRefType.subclass(*args_, **kwargs_)
        else:
            return ConceptSchemeRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ConceptSchemeID(self): return self.ConceptSchemeID
    def set_ConceptSchemeID(self, ConceptSchemeID): self.ConceptSchemeID = ConceptSchemeID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.ConceptSchemeID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptSchemeRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptSchemeRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptSchemeRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptSchemeRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptSchemeRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ConceptSchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConceptSchemeID>%s</%sConceptSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConceptSchemeID).encode(ExternalEncoding), input_name='ConceptSchemeID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConceptSchemeRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ConceptSchemeID is not None:
            showIndent(outfile, level)
            outfile.write('ConceptSchemeID=%s,\n' % quote_python(self.ConceptSchemeID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'ConceptSchemeID':
            ConceptSchemeID_ = child_.text
            ConceptSchemeID_ = self.gds_validate_string(ConceptSchemeID_, node, 'ConceptSchemeID')
            self.ConceptSchemeID = ConceptSchemeID_
            self.validate_IDType(self.ConceptSchemeID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ConceptSchemeRefType


class OrganisationSchemeRefType(GeneratedsSuper):
    """OrganisationSchemeRef allows for references to specific organisation
    schemes. At a minimum, either the URN - which contains a valid
    Registry/Repository URN - or the rest of the child elements must
    be supplied."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, OrganisationSchemeID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.OrganisationSchemeID = OrganisationSchemeID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if OrganisationSchemeRefType.subclass:
            return OrganisationSchemeRefType.subclass(*args_, **kwargs_)
        else:
            return OrganisationSchemeRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_OrganisationSchemeID(self): return self.OrganisationSchemeID
    def set_OrganisationSchemeID(self, OrganisationSchemeID): self.OrganisationSchemeID = OrganisationSchemeID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.OrganisationSchemeID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationSchemeRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationSchemeRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationSchemeRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationSchemeRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationSchemeRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeID>%s</%sOrganisationSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeID).encode(ExternalEncoding), input_name='OrganisationSchemeID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrganisationSchemeRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeID=%s,\n' % quote_python(self.OrganisationSchemeID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'OrganisationSchemeID':
            OrganisationSchemeID_ = child_.text
            OrganisationSchemeID_ = self.gds_validate_string(OrganisationSchemeID_, node, 'OrganisationSchemeID')
            self.OrganisationSchemeID = OrganisationSchemeID_
            self.validate_IDType(self.OrganisationSchemeID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class OrganisationSchemeRefType


class HierarchicalCodelistRefType(GeneratedsSuper):
    """HierarchicalCodelistRef allows for references to specific
    hierarchical codelists. At a minimum, either the URN - which
    contains a valid Registry/Repository URN - or the rest of the
    child elements must be supplied."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, HierarchicalCodelistID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.HierarchicalCodelistID = HierarchicalCodelistID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if HierarchicalCodelistRefType.subclass:
            return HierarchicalCodelistRefType.subclass(*args_, **kwargs_)
        else:
            return HierarchicalCodelistRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_HierarchicalCodelistID(self): return self.HierarchicalCodelistID
    def set_HierarchicalCodelistID(self, HierarchicalCodelistID): self.HierarchicalCodelistID = HierarchicalCodelistID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.HierarchicalCodelistID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HierarchicalCodelistRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HierarchicalCodelistRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HierarchicalCodelistRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.HierarchicalCodelistID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHierarchicalCodelistID>%s</%sHierarchicalCodelistID>%s' % (namespace_, self.gds_format_string(quote_xml(self.HierarchicalCodelistID).encode(ExternalEncoding), input_name='HierarchicalCodelistID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HierarchicalCodelistRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.HierarchicalCodelistID is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelistID=%s,\n' % quote_python(self.HierarchicalCodelistID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'HierarchicalCodelistID':
            HierarchicalCodelistID_ = child_.text
            HierarchicalCodelistID_ = self.gds_validate_string(HierarchicalCodelistID_, node, 'HierarchicalCodelistID')
            self.HierarchicalCodelistID = HierarchicalCodelistID_
            self.validate_IDType(self.HierarchicalCodelistID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class HierarchicalCodelistRefType


class StructureMapType(GeneratedsSuper):
    """StructureMapType describes the structure of the mapping of
    components between a referenced key family or metadata structure
    and a target key family or metadata structure. Components
    include any dimension, attribute, or reported concept. The Name
    element is used to provide a human-readable name for the
    component map; the Description element is used to provide a
    longer human-readable description. Both of these elements may be
    provided in multiple, language-specific variations. The
    StructureMapType provides for Annotations with the Annotations
    element. Either a KeyFamilyRef or a MetadataStructureRef must be
    provided; and also a TargetKeyFamilyRef or a
    TargetMetadataStructureRef. A series of map components are then
    specified using the ComponentMap element, each of which
    specifies the equivalence of a concept in the referenced
    straucture definition to one in the target structure definition.
    If the isExtension attribute has a value of true, then the
    target structure definition inherits all properties of the
    referenced structure definition, and may have additional
    components. Note that this attribute may only be set to true if
    the component map has as a referenced structure definition and a
    target structure definition either two key families or two
    metadata structure definition. You cannot inherit concepts
    between the two type of structure definitions using this
    mechanism. The id attribute allows for an id to be assigned to
    the component map - it must be unique within its StructureSet."""
    subclass = None
    superclass = None
    def __init__(self, isExtension=None, id=None, Name=None, Description=None, KeyFamilyRef=None, MetadataStructureRef=None, TargetKeyFamilyRef=None, TargetMetadataStructureRef=None, ComponentMap=None, Annotations=None):
        self.original_tagname_ = None
        self.isExtension = _cast(bool, isExtension)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.KeyFamilyRef = KeyFamilyRef
        self.MetadataStructureRef = MetadataStructureRef
        self.TargetKeyFamilyRef = TargetKeyFamilyRef
        self.TargetMetadataStructureRef = TargetMetadataStructureRef
        if ComponentMap is None:
            self.ComponentMap = []
        else:
            self.ComponentMap = ComponentMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if StructureMapType.subclass:
            return StructureMapType.subclass(*args_, **kwargs_)
        else:
            return StructureMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def get_TargetKeyFamilyRef(self): return self.TargetKeyFamilyRef
    def set_TargetKeyFamilyRef(self, TargetKeyFamilyRef): self.TargetKeyFamilyRef = TargetKeyFamilyRef
    def get_TargetMetadataStructureRef(self): return self.TargetMetadataStructureRef
    def set_TargetMetadataStructureRef(self, TargetMetadataStructureRef): self.TargetMetadataStructureRef = TargetMetadataStructureRef
    def get_ComponentMap(self): return self.ComponentMap
    def set_ComponentMap(self, ComponentMap): self.ComponentMap = ComponentMap
    def add_ComponentMap(self, value): self.ComponentMap.append(value)
    def insert_ComponentMap_at(self, index, value): self.ComponentMap.insert(index, value)
    def replace_ComponentMap_at(self, index, value): self.ComponentMap[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_isExtension(self): return self.isExtension
    def set_isExtension(self, isExtension): self.isExtension = isExtension
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.KeyFamilyRef is not None or
            self.MetadataStructureRef is not None or
            self.TargetKeyFamilyRef is not None or
            self.TargetMetadataStructureRef is not None or
            self.ComponentMap or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureMapType'):
        if self.isExtension is not None and 'isExtension' not in already_processed:
            already_processed.add('isExtension')
            outfile.write(' isExtension="%s"' % self.gds_format_boolean(self.isExtension, input_name='isExtension'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.KeyFamilyRef is not None:
            self.KeyFamilyRef.export(outfile, level, namespace_, name_='KeyFamilyRef', pretty_print=pretty_print)
        if self.MetadataStructureRef is not None:
            self.MetadataStructureRef.export(outfile, level, namespace_, name_='MetadataStructureRef', pretty_print=pretty_print)
        if self.TargetKeyFamilyRef is not None:
            self.TargetKeyFamilyRef.export(outfile, level, namespace_, name_='TargetKeyFamilyRef', pretty_print=pretty_print)
        if self.TargetMetadataStructureRef is not None:
            self.TargetMetadataStructureRef.export(outfile, level, namespace_, name_='TargetMetadataStructureRef', pretty_print=pretty_print)
        for ComponentMap_ in self.ComponentMap:
            ComponentMap_.export(outfile, level, namespace_, name_='ComponentMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StructureMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isExtension is not None and 'isExtension' not in already_processed:
            already_processed.add('isExtension')
            showIndent(outfile, level)
            outfile.write('isExtension=%s,\n' % (self.isExtension,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyRef=model_.KeyFamilyRefType(\n')
            self.KeyFamilyRef.exportLiteral(outfile, level, name_='KeyFamilyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataStructureRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureRef=model_.MetadataStructureRefType(\n')
            self.MetadataStructureRef.exportLiteral(outfile, level, name_='MetadataStructureRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetKeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetKeyFamilyRef=model_.KeyFamilyRefType(\n')
            self.TargetKeyFamilyRef.exportLiteral(outfile, level, name_='TargetKeyFamilyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetMetadataStructureRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetMetadataStructureRef=model_.MetadataStructureRefType(\n')
            self.TargetMetadataStructureRef.exportLiteral(outfile, level, name_='TargetMetadataStructureRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ComponentMap=[\n')
        level += 1
        for ComponentMap_ in self.ComponentMap:
            showIndent(outfile, level)
            outfile.write('model_.ComponentMapType(\n')
            ComponentMap_.exportLiteral(outfile, level, name_='ComponentMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isExtension', node)
        if value is not None and 'isExtension' not in already_processed:
            already_processed.add('isExtension')
            if value in ('true', '1'):
                self.isExtension = True
            elif value in ('false', '0'):
                self.isExtension = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'KeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.KeyFamilyRef = obj_
            obj_.original_tagname_ = 'KeyFamilyRef'
        elif nodeName_ == 'MetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.MetadataStructureRef = obj_
            obj_.original_tagname_ = 'MetadataStructureRef'
        elif nodeName_ == 'TargetKeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.TargetKeyFamilyRef = obj_
            obj_.original_tagname_ = 'TargetKeyFamilyRef'
        elif nodeName_ == 'TargetMetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.TargetMetadataStructureRef = obj_
            obj_.original_tagname_ = 'TargetMetadataStructureRef'
        elif nodeName_ == 'ComponentMap':
            obj_ = ComponentMapType.factory()
            obj_.build(child_)
            self.ComponentMap.append(obj_)
            obj_.original_tagname_ = 'ComponentMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class StructureMapType


class CodelistMapType(GeneratedsSuper):
    """CodelistMap allows the description of how the codes in a codelist
    are represented in a target codelist or associated hierarchical
    codelist. A human-readable Name is provided, and a longer,
    human-readable description may be provided as well, in the Name
    and Description elements respectively. These may be supplied in
    multiple, language-specific versions.CodelistRef references the
    codelist or hierarchical codelist being mapped;
    TargetCodelistRef indicates the codelist to which it will be
    mapped. CodeMap is the element which indicates the equivalence
    of codes in the referenced codelist to those in the target
    codelist. Any codes not mapped are assumed to lack equivalence.
    The CodelistMap may be annotated using the Annotations element.
    The id attribute is used to assign an identifier which is unique
    within the StructureSet for all CodelistMaps."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Description=None, CodelistRef=None, HierarchicalCodelistRef=None, TargetCodelistRef=None, TargetHierarchicalCodelistRef=None, CodeMap=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.CodelistRef = CodelistRef
        self.HierarchicalCodelistRef = HierarchicalCodelistRef
        self.TargetCodelistRef = TargetCodelistRef
        self.TargetHierarchicalCodelistRef = TargetHierarchicalCodelistRef
        if CodeMap is None:
            self.CodeMap = []
        else:
            self.CodeMap = CodeMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CodelistMapType.subclass:
            return CodelistMapType.subclass(*args_, **kwargs_)
        else:
            return CodelistMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_CodelistRef(self): return self.CodelistRef
    def set_CodelistRef(self, CodelistRef): self.CodelistRef = CodelistRef
    def get_HierarchicalCodelistRef(self): return self.HierarchicalCodelistRef
    def set_HierarchicalCodelistRef(self, HierarchicalCodelistRef): self.HierarchicalCodelistRef = HierarchicalCodelistRef
    def get_TargetCodelistRef(self): return self.TargetCodelistRef
    def set_TargetCodelistRef(self, TargetCodelistRef): self.TargetCodelistRef = TargetCodelistRef
    def get_TargetHierarchicalCodelistRef(self): return self.TargetHierarchicalCodelistRef
    def set_TargetHierarchicalCodelistRef(self, TargetHierarchicalCodelistRef): self.TargetHierarchicalCodelistRef = TargetHierarchicalCodelistRef
    def get_CodeMap(self): return self.CodeMap
    def set_CodeMap(self, CodeMap): self.CodeMap = CodeMap
    def add_CodeMap(self, value): self.CodeMap.append(value)
    def insert_CodeMap_at(self, index, value): self.CodeMap.insert(index, value)
    def replace_CodeMap_at(self, index, value): self.CodeMap[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.CodelistRef is not None or
            self.HierarchicalCodelistRef is not None or
            self.TargetCodelistRef is not None or
            self.TargetHierarchicalCodelistRef is not None or
            self.CodeMap or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodelistMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodelistMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodelistMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodelistMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodelistMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.CodelistRef is not None:
            self.CodelistRef.export(outfile, level, namespace_, name_='CodelistRef', pretty_print=pretty_print)
        if self.HierarchicalCodelistRef is not None:
            self.HierarchicalCodelistRef.export(outfile, level, namespace_, name_='HierarchicalCodelistRef', pretty_print=pretty_print)
        if self.TargetCodelistRef is not None:
            self.TargetCodelistRef.export(outfile, level, namespace_, name_='TargetCodelistRef', pretty_print=pretty_print)
        if self.TargetHierarchicalCodelistRef is not None:
            self.TargetHierarchicalCodelistRef.export(outfile, level, namespace_, name_='TargetHierarchicalCodelistRef', pretty_print=pretty_print)
        for CodeMap_ in self.CodeMap:
            CodeMap_.export(outfile, level, namespace_, name_='CodeMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodelistMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('CodelistRef=model_.CodelistRefType(\n')
            self.CodelistRef.exportLiteral(outfile, level, name_='CodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HierarchicalCodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelistRef=model_.HierarchicalCodelistRefType(\n')
            self.HierarchicalCodelistRef.exportLiteral(outfile, level, name_='HierarchicalCodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetCodelistRef=model_.CodelistRefType(\n')
            self.TargetCodelistRef.exportLiteral(outfile, level, name_='TargetCodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetHierarchicalCodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetHierarchicalCodelistRef=model_.HierarchicalCodelistRefType(\n')
            self.TargetHierarchicalCodelistRef.exportLiteral(outfile, level, name_='TargetHierarchicalCodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CodeMap=[\n')
        level += 1
        for CodeMap_ in self.CodeMap:
            showIndent(outfile, level)
            outfile.write('model_.CodeMapType(\n')
            CodeMap_.exportLiteral(outfile, level, name_='CodeMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'CodelistRef':
            obj_ = CodelistRefType.factory()
            obj_.build(child_)
            self.CodelistRef = obj_
            obj_.original_tagname_ = 'CodelistRef'
        elif nodeName_ == 'HierarchicalCodelistRef':
            obj_ = HierarchicalCodelistRefType.factory()
            obj_.build(child_)
            self.HierarchicalCodelistRef = obj_
            obj_.original_tagname_ = 'HierarchicalCodelistRef'
        elif nodeName_ == 'TargetCodelistRef':
            obj_ = CodelistRefType.factory()
            obj_.build(child_)
            self.TargetCodelistRef = obj_
            obj_.original_tagname_ = 'TargetCodelistRef'
        elif nodeName_ == 'TargetHierarchicalCodelistRef':
            obj_ = HierarchicalCodelistRefType.factory()
            obj_.build(child_)
            self.TargetHierarchicalCodelistRef = obj_
            obj_.original_tagname_ = 'TargetHierarchicalCodelistRef'
        elif nodeName_ == 'CodeMap':
            obj_ = CodeMapType.factory()
            obj_.build(child_)
            self.CodeMap.append(obj_)
            obj_.original_tagname_ = 'CodeMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CodelistMapType


class CodeMapType(GeneratedsSuper):
    """CodeMap describes the equivalence of the codes in the referenced
    codelist or hierarchical codelist indicated in the CodelistRef
    element of the containing CodelistMap to those in the referenced
    TargetCodelist in the containing CodelistMap. The CodeAlias
    attribute is used to assign an alias code to the equivalence for
    querying the structure set."""
    subclass = None
    superclass = None
    def __init__(self, CodeAlias=None, MapCodeRef=None, MapTargetCodeRef=None):
        self.original_tagname_ = None
        self.CodeAlias = _cast(None, CodeAlias)
        self.MapCodeRef = MapCodeRef
        self.MapTargetCodeRef = MapTargetCodeRef
    def factory(*args_, **kwargs_):
        if CodeMapType.subclass:
            return CodeMapType.subclass(*args_, **kwargs_)
        else:
            return CodeMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MapCodeRef(self): return self.MapCodeRef
    def set_MapCodeRef(self, MapCodeRef): self.MapCodeRef = MapCodeRef
    def get_MapTargetCodeRef(self): return self.MapTargetCodeRef
    def set_MapTargetCodeRef(self, MapTargetCodeRef): self.MapTargetCodeRef = MapTargetCodeRef
    def get_CodeAlias(self): return self.CodeAlias
    def set_CodeAlias(self, CodeAlias): self.CodeAlias = CodeAlias
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.MapCodeRef is not None or
            self.MapTargetCodeRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodeMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodeMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodeMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodeMapType'):
        if self.CodeAlias is not None and 'CodeAlias' not in already_processed:
            already_processed.add('CodeAlias')
            outfile.write(' CodeAlias=%s' % (quote_attrib(self.CodeAlias), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodeMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MapCodeRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapCodeRef>%s</%sMapCodeRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MapCodeRef).encode(ExternalEncoding), input_name='MapCodeRef'), namespace_, eol_))
        if self.MapTargetCodeRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapTargetCodeRef>%s</%sMapTargetCodeRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MapTargetCodeRef).encode(ExternalEncoding), input_name='MapTargetCodeRef'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CodeMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.CodeAlias is not None and 'CodeAlias' not in already_processed:
            already_processed.add('CodeAlias')
            showIndent(outfile, level)
            outfile.write('CodeAlias=%s,\n' % (self.CodeAlias,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MapCodeRef is not None:
            showIndent(outfile, level)
            outfile.write('MapCodeRef=%s,\n' % quote_python(self.MapCodeRef).encode(ExternalEncoding))
        if self.MapTargetCodeRef is not None:
            showIndent(outfile, level)
            outfile.write('MapTargetCodeRef=%s,\n' % quote_python(self.MapTargetCodeRef).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('CodeAlias', node)
        if value is not None and 'CodeAlias' not in already_processed:
            already_processed.add('CodeAlias')
            self.CodeAlias = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MapCodeRef':
            MapCodeRef_ = child_.text
            MapCodeRef_ = self.gds_validate_string(MapCodeRef_, node, 'MapCodeRef')
            self.MapCodeRef = MapCodeRef_
            self.validate_IDType(self.MapCodeRef)    # validate type IDType
        elif nodeName_ == 'MapTargetCodeRef':
            MapTargetCodeRef_ = child_.text
            MapTargetCodeRef_ = self.gds_validate_string(MapTargetCodeRef_, node, 'MapTargetCodeRef')
            self.MapTargetCodeRef = MapTargetCodeRef_
            self.validate_IDType(self.MapTargetCodeRef)    # validate type IDType
# end class CodeMapType


class ComponentMapType(GeneratedsSuper):
    """ComponentMapType describes how a component (that is, dimension,
    attribute, or reported concept) in a referenced metadata
    structure definition or key family maps to a component in a
    referenced "target" metadata structure definition or key family.
    The MapConceptRef contains the id of the concept in the metadata
    structure definition or key family referenced in the
    KeyFamilyRef or MetadataStructureRef element of the containing
    ComponentMap element. The MapTargetConceptRef contains the id of
    the concept in the metadata structure definition or key family
    referenced in the TargetKeyFamilyRef or
    TargetMetadataStructureRef element of the containing
    ComponentMap element. The RepresentationMapRef element contains
    a reference to the CodelistMap which describes how the coded
    representation of the referenced component maps to the coded
    representation of the target component. If the target component
    has an uncoded representation, then ToTextFormat is used to
    describe the un-coded representation to which the code of the
    referenced component should be transformed. The ToValueType
    element tells you whether the value, name, or description of the
    source value should be used in the resulting text field. The
    componentAlias attribute assigns a new ID to the relationship
    between these components. Note that of three components from
    different key families and/or metadata structure definitions are
    all equivalent, the two component maps can share a single alias.
    Note also that for metadata concepts which are represented not
    by codelists but rather by other types of item schemes
    (OrganisationSchemes or CategorySchemes), these can also be
    referenced using the RepresentationMapRef element. The
    preferredLanguage attribute specifies the language to use when
    translating coded values into their names or descriptions, if
    available, in the same form as xml:lang."""
    subclass = None
    superclass = None
    def __init__(self, preferredLanguage='en', componentAlias=None, MapConceptRef=None, MapTargetConceptRef=None, RepresentationMapRef=None, ToTextFormat=None, ToValueType=None):
        self.original_tagname_ = None
        self.preferredLanguage = _cast(None, preferredLanguage)
        self.componentAlias = _cast(None, componentAlias)
        self.MapConceptRef = MapConceptRef
        self.MapTargetConceptRef = MapTargetConceptRef
        self.RepresentationMapRef = RepresentationMapRef
        self.ToTextFormat = ToTextFormat
        self.ToValueType = ToValueType
    def factory(*args_, **kwargs_):
        if ComponentMapType.subclass:
            return ComponentMapType.subclass(*args_, **kwargs_)
        else:
            return ComponentMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MapConceptRef(self): return self.MapConceptRef
    def set_MapConceptRef(self, MapConceptRef): self.MapConceptRef = MapConceptRef
    def get_MapTargetConceptRef(self): return self.MapTargetConceptRef
    def set_MapTargetConceptRef(self, MapTargetConceptRef): self.MapTargetConceptRef = MapTargetConceptRef
    def get_RepresentationMapRef(self): return self.RepresentationMapRef
    def set_RepresentationMapRef(self, RepresentationMapRef): self.RepresentationMapRef = RepresentationMapRef
    def get_ToTextFormat(self): return self.ToTextFormat
    def set_ToTextFormat(self, ToTextFormat): self.ToTextFormat = ToTextFormat
    def get_ToValueType(self): return self.ToValueType
    def set_ToValueType(self, ToValueType): self.ToValueType = ToValueType
    def get_preferredLanguage(self): return self.preferredLanguage
    def set_preferredLanguage(self, preferredLanguage): self.preferredLanguage = preferredLanguage
    def get_componentAlias(self): return self.componentAlias
    def set_componentAlias(self, componentAlias): self.componentAlias = componentAlias
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_ToValueTypeType(self, value):
        # Validate type ToValueTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.MapConceptRef is not None or
            self.MapTargetConceptRef is not None or
            self.RepresentationMapRef is not None or
            self.ToTextFormat is not None or
            self.ToValueType is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ComponentMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComponentMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ComponentMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ComponentMapType'):
        if self.preferredLanguage is not None and 'preferredLanguage' not in already_processed:
            already_processed.add('preferredLanguage')
            outfile.write(' preferredLanguage=%s' % (self.gds_format_string(quote_attrib(self.preferredLanguage).encode(ExternalEncoding), input_name='preferredLanguage'), ))
        if self.componentAlias is not None and 'componentAlias' not in already_processed:
            already_processed.add('componentAlias')
            outfile.write(' componentAlias=%s' % (quote_attrib(self.componentAlias), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ComponentMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MapConceptRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapConceptRef>%s</%sMapConceptRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MapConceptRef).encode(ExternalEncoding), input_name='MapConceptRef'), namespace_, eol_))
        if self.MapTargetConceptRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMapTargetConceptRef>%s</%sMapTargetConceptRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MapTargetConceptRef).encode(ExternalEncoding), input_name='MapTargetConceptRef'), namespace_, eol_))
        if self.RepresentationMapRef is not None:
            self.RepresentationMapRef.export(outfile, level, namespace_, name_='RepresentationMapRef', pretty_print=pretty_print)
        if self.ToTextFormat is not None:
            self.ToTextFormat.export(outfile, level, namespace_, name_='ToTextFormat', pretty_print=pretty_print)
        if self.ToValueType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sToValueType>%s</%sToValueType>%s' % (namespace_, self.gds_format_string(quote_xml(self.ToValueType).encode(ExternalEncoding), input_name='ToValueType'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ComponentMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.preferredLanguage is not None and 'preferredLanguage' not in already_processed:
            already_processed.add('preferredLanguage')
            showIndent(outfile, level)
            outfile.write('preferredLanguage="%s",\n' % (self.preferredLanguage,))
        if self.componentAlias is not None and 'componentAlias' not in already_processed:
            already_processed.add('componentAlias')
            showIndent(outfile, level)
            outfile.write('componentAlias=%s,\n' % (self.componentAlias,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MapConceptRef is not None:
            showIndent(outfile, level)
            outfile.write('MapConceptRef=%s,\n' % quote_python(self.MapConceptRef).encode(ExternalEncoding))
        if self.MapTargetConceptRef is not None:
            showIndent(outfile, level)
            outfile.write('MapTargetConceptRef=%s,\n' % quote_python(self.MapTargetConceptRef).encode(ExternalEncoding))
        if self.RepresentationMapRef is not None:
            showIndent(outfile, level)
            outfile.write('RepresentationMapRef=model_.RepresentationMapRefType(\n')
            self.RepresentationMapRef.exportLiteral(outfile, level, name_='RepresentationMapRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ToTextFormat is not None:
            showIndent(outfile, level)
            outfile.write('ToTextFormat=model_.TextFormatType(\n')
            self.ToTextFormat.exportLiteral(outfile, level, name_='ToTextFormat')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ToValueType is not None:
            showIndent(outfile, level)
            outfile.write('ToValueType=%s,\n' % quote_python(self.ToValueType).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('preferredLanguage', node)
        if value is not None and 'preferredLanguage' not in already_processed:
            already_processed.add('preferredLanguage')
            self.preferredLanguage = value
        value = find_attr_value_('componentAlias', node)
        if value is not None and 'componentAlias' not in already_processed:
            already_processed.add('componentAlias')
            self.componentAlias = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MapConceptRef':
            MapConceptRef_ = child_.text
            MapConceptRef_ = self.gds_validate_string(MapConceptRef_, node, 'MapConceptRef')
            self.MapConceptRef = MapConceptRef_
            self.validate_IDType(self.MapConceptRef)    # validate type IDType
        elif nodeName_ == 'MapTargetConceptRef':
            MapTargetConceptRef_ = child_.text
            MapTargetConceptRef_ = self.gds_validate_string(MapTargetConceptRef_, node, 'MapTargetConceptRef')
            self.MapTargetConceptRef = MapTargetConceptRef_
            self.validate_IDType(self.MapTargetConceptRef)    # validate type IDType
        elif nodeName_ == 'RepresentationMapRef':
            obj_ = RepresentationMapRefType.factory()
            obj_.build(child_)
            self.RepresentationMapRef = obj_
            obj_.original_tagname_ = 'RepresentationMapRef'
        elif nodeName_ == 'ToTextFormat':
            obj_ = TextFormatType.factory()
            obj_.build(child_)
            self.ToTextFormat = obj_
            obj_.original_tagname_ = 'ToTextFormat'
        elif nodeName_ == 'ToValueType':
            ToValueType_ = child_.text
            ToValueType_ = self.gds_validate_string(ToValueType_, node, 'ToValueType')
            self.ToValueType = ToValueType_
            self.validate_ToValueTypeType(self.ToValueType)    # validate type ToValueTypeType
# end class ComponentMapType


class RepresentationMapRefType(GeneratedsSuper):
    """RepresentationMapRefType describes the structure of a reference to a
    codelist, category scheme, or organisation scheme map.
    RepresentationMapAgencyID takes the id value of the maintenance
    agency of the codelist, category scheme, or organisation scheme
    map; RepresentationMapID takes the id attribute value of the
    codelist, category scheme, or organisation scheme map."""
    subclass = None
    superclass = None
    def __init__(self, representationType='Codelist', RepresentationMapAgencyID=None, RepresentationMapID=None):
        self.original_tagname_ = None
        self.representationType = _cast(None, representationType)
        self.RepresentationMapAgencyID = RepresentationMapAgencyID
        self.RepresentationMapID = RepresentationMapID
    def factory(*args_, **kwargs_):
        if RepresentationMapRefType.subclass:
            return RepresentationMapRefType.subclass(*args_, **kwargs_)
        else:
            return RepresentationMapRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RepresentationMapAgencyID(self): return self.RepresentationMapAgencyID
    def set_RepresentationMapAgencyID(self, RepresentationMapAgencyID): self.RepresentationMapAgencyID = RepresentationMapAgencyID
    def get_RepresentationMapID(self): return self.RepresentationMapID
    def set_RepresentationMapID(self, RepresentationMapID): self.RepresentationMapID = RepresentationMapID
    def get_representationType(self): return self.representationType
    def set_representationType(self, representationType): self.representationType = representationType
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_RepresentationTypeType(self, value):
        # Validate type RepresentationTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.RepresentationMapAgencyID is not None or
            self.RepresentationMapID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RepresentationMapRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RepresentationMapRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RepresentationMapRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RepresentationMapRefType'):
        if self.representationType is not None and 'representationType' not in already_processed:
            already_processed.add('representationType')
            outfile.write(' representationType=%s' % (quote_attrib(self.representationType), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='RepresentationMapRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.RepresentationMapAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRepresentationMapAgencyID>%s</%sRepresentationMapAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.RepresentationMapAgencyID).encode(ExternalEncoding), input_name='RepresentationMapAgencyID'), namespace_, eol_))
        if self.RepresentationMapID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRepresentationMapID>%s</%sRepresentationMapID>%s' % (namespace_, self.gds_format_string(quote_xml(self.RepresentationMapID).encode(ExternalEncoding), input_name='RepresentationMapID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='RepresentationMapRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.representationType is not None and 'representationType' not in already_processed:
            already_processed.add('representationType')
            showIndent(outfile, level)
            outfile.write('representationType="%s",\n' % (self.representationType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.RepresentationMapAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('RepresentationMapAgencyID=%s,\n' % quote_python(self.RepresentationMapAgencyID).encode(ExternalEncoding))
        if self.RepresentationMapID is not None:
            showIndent(outfile, level)
            outfile.write('RepresentationMapID=%s,\n' % quote_python(self.RepresentationMapID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('representationType', node)
        if value is not None and 'representationType' not in already_processed:
            already_processed.add('representationType')
            self.representationType = value
            self.validate_RepresentationTypeType(self.representationType)    # validate type RepresentationTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RepresentationMapAgencyID':
            RepresentationMapAgencyID_ = child_.text
            RepresentationMapAgencyID_ = self.gds_validate_string(RepresentationMapAgencyID_, node, 'RepresentationMapAgencyID')
            self.RepresentationMapAgencyID = RepresentationMapAgencyID_
            self.validate_IDType(self.RepresentationMapAgencyID)    # validate type IDType
        elif nodeName_ == 'RepresentationMapID':
            RepresentationMapID_ = child_.text
            RepresentationMapID_ = self.gds_validate_string(RepresentationMapID_, node, 'RepresentationMapID')
            self.RepresentationMapID = RepresentationMapID_
            self.validate_IDType(self.RepresentationMapID)    # validate type IDType
# end class RepresentationMapRefType


class CategorySchemeMapType(GeneratedsSuper):
    """CategorySchemeMap provides for the mapping of categories in one
    scheme against those in another. It requires a human-readable
    Name, and can have a longer human-readable Description, both of
    which can be supplied in multiple, parallel-language form. It
    may be annotated using Annotations. The id attribute carries a
    unique ID for CategorySchemeMaps within the StructureSet.
    CategorySchemeRef identifies the source CategoryScheme;
    TargetCategorySchemeRef identifies the target CategoryScheme."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Description=None, CategorySchemeRef=None, TargetCategorySchemeRef=None, CategoryMap=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.CategorySchemeRef = CategorySchemeRef
        self.TargetCategorySchemeRef = TargetCategorySchemeRef
        if CategoryMap is None:
            self.CategoryMap = []
        else:
            self.CategoryMap = CategoryMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if CategorySchemeMapType.subclass:
            return CategorySchemeMapType.subclass(*args_, **kwargs_)
        else:
            return CategorySchemeMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_CategorySchemeRef(self): return self.CategorySchemeRef
    def set_CategorySchemeRef(self, CategorySchemeRef): self.CategorySchemeRef = CategorySchemeRef
    def get_TargetCategorySchemeRef(self): return self.TargetCategorySchemeRef
    def set_TargetCategorySchemeRef(self, TargetCategorySchemeRef): self.TargetCategorySchemeRef = TargetCategorySchemeRef
    def get_CategoryMap(self): return self.CategoryMap
    def set_CategoryMap(self, CategoryMap): self.CategoryMap = CategoryMap
    def add_CategoryMap(self, value): self.CategoryMap.append(value)
    def insert_CategoryMap_at(self, index, value): self.CategoryMap.insert(index, value)
    def replace_CategoryMap_at(self, index, value): self.CategoryMap[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.CategorySchemeRef is not None or
            self.TargetCategorySchemeRef is not None or
            self.CategoryMap or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategorySchemeMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategorySchemeMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategorySchemeMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategorySchemeMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategorySchemeMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.CategorySchemeRef is not None:
            self.CategorySchemeRef.export(outfile, level, namespace_, name_='CategorySchemeRef', pretty_print=pretty_print)
        if self.TargetCategorySchemeRef is not None:
            self.TargetCategorySchemeRef.export(outfile, level, namespace_, name_='TargetCategorySchemeRef', pretty_print=pretty_print)
        for CategoryMap_ in self.CategoryMap:
            CategoryMap_.export(outfile, level, namespace_, name_='CategoryMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategorySchemeMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.CategorySchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeRef=model_.CategorySchemeRefType(\n')
            self.CategorySchemeRef.exportLiteral(outfile, level, name_='CategorySchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCategorySchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetCategorySchemeRef=model_.CategorySchemeRefType(\n')
            self.TargetCategorySchemeRef.exportLiteral(outfile, level, name_='TargetCategorySchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('CategoryMap=[\n')
        level += 1
        for CategoryMap_ in self.CategoryMap:
            showIndent(outfile, level)
            outfile.write('model_.CategoryMapType(\n')
            CategoryMap_.exportLiteral(outfile, level, name_='CategoryMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'CategorySchemeRef':
            obj_ = CategorySchemeRefType.factory()
            obj_.build(child_)
            self.CategorySchemeRef = obj_
            obj_.original_tagname_ = 'CategorySchemeRef'
        elif nodeName_ == 'TargetCategorySchemeRef':
            obj_ = CategorySchemeRefType.factory()
            obj_.build(child_)
            self.TargetCategorySchemeRef = obj_
            obj_.original_tagname_ = 'TargetCategorySchemeRef'
        elif nodeName_ == 'CategoryMap':
            obj_ = CategoryMapType.factory()
            obj_.build(child_)
            self.CategoryMap.append(obj_)
            obj_.original_tagname_ = 'CategoryMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class CategorySchemeMapType


class CategoryMapType(GeneratedsSuper):
    """CategoryMap allows for the mapping of a category in one scheme
    against a category in another, target scheme. The categoryAlias
    attribute allows for an alias to be assigned to the mapping for
    searching across the set of mapped categories. Note that the
    Category IDs are recursive, and can therefore describe a path
    through a category scheme."""
    subclass = None
    superclass = None
    def __init__(self, categoryAlias=None, CategoryID=None, TargetCategoryID=None):
        self.original_tagname_ = None
        self.categoryAlias = _cast(None, categoryAlias)
        self.CategoryID = CategoryID
        self.TargetCategoryID = TargetCategoryID
    def factory(*args_, **kwargs_):
        if CategoryMapType.subclass:
            return CategoryMapType.subclass(*args_, **kwargs_)
        else:
            return CategoryMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_CategoryID(self): return self.CategoryID
    def set_CategoryID(self, CategoryID): self.CategoryID = CategoryID
    def get_TargetCategoryID(self): return self.TargetCategoryID
    def set_TargetCategoryID(self, TargetCategoryID): self.TargetCategoryID = TargetCategoryID
    def get_categoryAlias(self): return self.categoryAlias
    def set_categoryAlias(self, categoryAlias): self.categoryAlias = categoryAlias
    def hasContent_(self):
        if (
            self.CategoryID is not None or
            self.TargetCategoryID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategoryMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategoryMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategoryMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategoryMapType'):
        if self.categoryAlias is not None and 'categoryAlias' not in already_processed:
            already_processed.add('categoryAlias')
            outfile.write(' categoryAlias=%s' % (quote_attrib(self.categoryAlias), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategoryMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.CategoryID is not None:
            self.CategoryID.export(outfile, level, namespace_, name_='CategoryID', pretty_print=pretty_print)
        if self.TargetCategoryID is not None:
            self.TargetCategoryID.export(outfile, level, namespace_, name_='TargetCategoryID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CategoryMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.categoryAlias is not None and 'categoryAlias' not in already_processed:
            already_processed.add('categoryAlias')
            showIndent(outfile, level)
            outfile.write('categoryAlias=%s,\n' % (self.categoryAlias,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.CategoryID is not None:
            showIndent(outfile, level)
            outfile.write('CategoryID=model_.CategoryIDType(\n')
            self.CategoryID.exportLiteral(outfile, level, name_='CategoryID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetCategoryID is not None:
            showIndent(outfile, level)
            outfile.write('TargetCategoryID=model_.CategoryIDType(\n')
            self.TargetCategoryID.exportLiteral(outfile, level, name_='TargetCategoryID')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('categoryAlias', node)
        if value is not None and 'categoryAlias' not in already_processed:
            already_processed.add('categoryAlias')
            self.categoryAlias = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'CategoryID':
            obj_ = CategoryIDType.factory()
            obj_.build(child_)
            self.CategoryID = obj_
            obj_.original_tagname_ = 'CategoryID'
        elif nodeName_ == 'TargetCategoryID':
            obj_ = CategoryIDType.factory()
            obj_.build(child_)
            self.TargetCategoryID = obj_
            obj_.original_tagname_ = 'TargetCategoryID'
# end class CategoryMapType


class ConceptSchemeMapType(GeneratedsSuper):
    """ConceptSchemeMap provides for the mapping of concepts in one scheme
    against those in another. It requires a human-readable Name, and
    can have a longer human-readable Description, both of which can
    be supplied in multiple, parallel-language form. It may be
    annotated using Annotations. The id attribute carries a unique
    ID for ConceptSchemeMaps within the StructureSet.
    ConceptSchemeRef identifies the source ConceptScheme;
    TargetConceptSchemeRef identifies the target ConceptScheme."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Description=None, ConceptSchemeRef=None, TargetConceptSchemeRef=None, ConceptMap=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.ConceptSchemeRef = ConceptSchemeRef
        self.TargetConceptSchemeRef = TargetConceptSchemeRef
        if ConceptMap is None:
            self.ConceptMap = []
        else:
            self.ConceptMap = ConceptMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ConceptSchemeMapType.subclass:
            return ConceptSchemeMapType.subclass(*args_, **kwargs_)
        else:
            return ConceptSchemeMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_ConceptSchemeRef(self): return self.ConceptSchemeRef
    def set_ConceptSchemeRef(self, ConceptSchemeRef): self.ConceptSchemeRef = ConceptSchemeRef
    def get_TargetConceptSchemeRef(self): return self.TargetConceptSchemeRef
    def set_TargetConceptSchemeRef(self, TargetConceptSchemeRef): self.TargetConceptSchemeRef = TargetConceptSchemeRef
    def get_ConceptMap(self): return self.ConceptMap
    def set_ConceptMap(self, ConceptMap): self.ConceptMap = ConceptMap
    def add_ConceptMap(self, value): self.ConceptMap.append(value)
    def insert_ConceptMap_at(self, index, value): self.ConceptMap.insert(index, value)
    def replace_ConceptMap_at(self, index, value): self.ConceptMap[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.ConceptSchemeRef is not None or
            self.TargetConceptSchemeRef is not None or
            self.ConceptMap or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptSchemeMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptSchemeMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptSchemeMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptSchemeMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptSchemeMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.ConceptSchemeRef is not None:
            self.ConceptSchemeRef.export(outfile, level, namespace_, name_='ConceptSchemeRef', pretty_print=pretty_print)
        if self.TargetConceptSchemeRef is not None:
            self.TargetConceptSchemeRef.export(outfile, level, namespace_, name_='TargetConceptSchemeRef', pretty_print=pretty_print)
        for ConceptMap_ in self.ConceptMap:
            ConceptMap_.export(outfile, level, namespace_, name_='ConceptMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConceptSchemeMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ConceptSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('ConceptSchemeRef=model_.ConceptSchemeRefType(\n')
            self.ConceptSchemeRef.exportLiteral(outfile, level, name_='ConceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetConceptSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetConceptSchemeRef=model_.ConceptSchemeRefType(\n')
            self.TargetConceptSchemeRef.exportLiteral(outfile, level, name_='TargetConceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ConceptMap=[\n')
        level += 1
        for ConceptMap_ in self.ConceptMap:
            showIndent(outfile, level)
            outfile.write('model_.ConceptMapType(\n')
            ConceptMap_.exportLiteral(outfile, level, name_='ConceptMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ConceptSchemeRef':
            obj_ = ConceptSchemeRefType.factory()
            obj_.build(child_)
            self.ConceptSchemeRef = obj_
            obj_.original_tagname_ = 'ConceptSchemeRef'
        elif nodeName_ == 'TargetConceptSchemeRef':
            obj_ = ConceptSchemeRefType.factory()
            obj_.build(child_)
            self.TargetConceptSchemeRef = obj_
            obj_.original_tagname_ = 'TargetConceptSchemeRef'
        elif nodeName_ == 'ConceptMap':
            obj_ = ConceptMapType.factory()
            obj_.build(child_)
            self.ConceptMap.append(obj_)
            obj_.original_tagname_ = 'ConceptMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ConceptSchemeMapType


class ConceptMapType(GeneratedsSuper):
    """ConceptMap allows for the mapping of a concept in one scheme against
    a concept in another, target scheme. The conceptAlias attribute
    allows for an alias to be assigned to the mapping for searching
    across the set of mapped concepts."""
    subclass = None
    superclass = None
    def __init__(self, conceptAlias=None, ConceptID=None, TargetConceptID=None):
        self.original_tagname_ = None
        self.conceptAlias = _cast(None, conceptAlias)
        self.ConceptID = ConceptID
        self.TargetConceptID = TargetConceptID
    def factory(*args_, **kwargs_):
        if ConceptMapType.subclass:
            return ConceptMapType.subclass(*args_, **kwargs_)
        else:
            return ConceptMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConceptID(self): return self.ConceptID
    def set_ConceptID(self, ConceptID): self.ConceptID = ConceptID
    def get_TargetConceptID(self): return self.TargetConceptID
    def set_TargetConceptID(self, TargetConceptID): self.TargetConceptID = TargetConceptID
    def get_conceptAlias(self): return self.conceptAlias
    def set_conceptAlias(self, conceptAlias): self.conceptAlias = conceptAlias
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ConceptID is not None or
            self.TargetConceptID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptMapType'):
        if self.conceptAlias is not None and 'conceptAlias' not in already_processed:
            already_processed.add('conceptAlias')
            outfile.write(' conceptAlias=%s' % (quote_attrib(self.conceptAlias), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConceptID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConceptID>%s</%sConceptID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConceptID).encode(ExternalEncoding), input_name='ConceptID'), namespace_, eol_))
        if self.TargetConceptID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargetConceptID>%s</%sTargetConceptID>%s' % (namespace_, self.gds_format_string(quote_xml(self.TargetConceptID).encode(ExternalEncoding), input_name='TargetConceptID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConceptMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conceptAlias is not None and 'conceptAlias' not in already_processed:
            already_processed.add('conceptAlias')
            showIndent(outfile, level)
            outfile.write('conceptAlias=%s,\n' % (self.conceptAlias,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConceptID is not None:
            showIndent(outfile, level)
            outfile.write('ConceptID=%s,\n' % quote_python(self.ConceptID).encode(ExternalEncoding))
        if self.TargetConceptID is not None:
            showIndent(outfile, level)
            outfile.write('TargetConceptID=%s,\n' % quote_python(self.TargetConceptID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conceptAlias', node)
        if value is not None and 'conceptAlias' not in already_processed:
            already_processed.add('conceptAlias')
            self.conceptAlias = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConceptID':
            ConceptID_ = child_.text
            ConceptID_ = self.gds_validate_string(ConceptID_, node, 'ConceptID')
            self.ConceptID = ConceptID_
            self.validate_IDType(self.ConceptID)    # validate type IDType
        elif nodeName_ == 'TargetConceptID':
            TargetConceptID_ = child_.text
            TargetConceptID_ = self.gds_validate_string(TargetConceptID_, node, 'TargetConceptID')
            self.TargetConceptID = TargetConceptID_
            self.validate_IDType(self.TargetConceptID)    # validate type IDType
# end class ConceptMapType


class OrganisationSchemeMapType(GeneratedsSuper):
    """OrganisationSchemeMap provides for the mapping of Organisations in
    one scheme against those in another. It requires a human-
    readable Name, and can have a longer human-readable Description,
    both of which can be supplied in multiple, parallel-language
    form. It may be annotated using Annotations. The id attribute
    carries a unique ID for OrganisationSchemeMaps within the
    StructureSet. OrganisationSchemeRef identifies the source
    OrganisationScheme; TargetOrganisationSchemeRef identifies the
    target OrganisationScheme."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Description=None, OrganisationSchemeRef=None, TargetOrganisationSchemeRef=None, OrganisationMap=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.OrganisationSchemeRef = OrganisationSchemeRef
        self.TargetOrganisationSchemeRef = TargetOrganisationSchemeRef
        if OrganisationMap is None:
            self.OrganisationMap = []
        else:
            self.OrganisationMap = OrganisationMap
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if OrganisationSchemeMapType.subclass:
            return OrganisationSchemeMapType.subclass(*args_, **kwargs_)
        else:
            return OrganisationSchemeMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_OrganisationSchemeRef(self): return self.OrganisationSchemeRef
    def set_OrganisationSchemeRef(self, OrganisationSchemeRef): self.OrganisationSchemeRef = OrganisationSchemeRef
    def get_TargetOrganisationSchemeRef(self): return self.TargetOrganisationSchemeRef
    def set_TargetOrganisationSchemeRef(self, TargetOrganisationSchemeRef): self.TargetOrganisationSchemeRef = TargetOrganisationSchemeRef
    def get_OrganisationMap(self): return self.OrganisationMap
    def set_OrganisationMap(self, OrganisationMap): self.OrganisationMap = OrganisationMap
    def add_OrganisationMap(self, value): self.OrganisationMap.append(value)
    def insert_OrganisationMap_at(self, index, value): self.OrganisationMap.insert(index, value)
    def replace_OrganisationMap_at(self, index, value): self.OrganisationMap[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.OrganisationSchemeRef is not None or
            self.TargetOrganisationSchemeRef is not None or
            self.OrganisationMap or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationSchemeMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationSchemeMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationSchemeMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationSchemeMapType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationSchemeMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.OrganisationSchemeRef is not None:
            self.OrganisationSchemeRef.export(outfile, level, namespace_, name_='OrganisationSchemeRef', pretty_print=pretty_print)
        if self.TargetOrganisationSchemeRef is not None:
            self.TargetOrganisationSchemeRef.export(outfile, level, namespace_, name_='TargetOrganisationSchemeRef', pretty_print=pretty_print)
        for OrganisationMap_ in self.OrganisationMap:
            OrganisationMap_.export(outfile, level, namespace_, name_='OrganisationMap', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrganisationSchemeMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.OrganisationSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeRef=model_.OrganisationSchemeRefType(\n')
            self.OrganisationSchemeRef.exportLiteral(outfile, level, name_='OrganisationSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TargetOrganisationSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetOrganisationSchemeRef=model_.OrganisationSchemeRefType(\n')
            self.TargetOrganisationSchemeRef.exportLiteral(outfile, level, name_='TargetOrganisationSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('OrganisationMap=[\n')
        level += 1
        for OrganisationMap_ in self.OrganisationMap:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationMapType(\n')
            OrganisationMap_.exportLiteral(outfile, level, name_='OrganisationMapType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'OrganisationSchemeRef':
            obj_ = OrganisationSchemeRefType.factory()
            obj_.build(child_)
            self.OrganisationSchemeRef = obj_
            obj_.original_tagname_ = 'OrganisationSchemeRef'
        elif nodeName_ == 'TargetOrganisationSchemeRef':
            obj_ = OrganisationSchemeRefType.factory()
            obj_.build(child_)
            self.TargetOrganisationSchemeRef = obj_
            obj_.original_tagname_ = 'TargetOrganisationSchemeRef'
        elif nodeName_ == 'OrganisationMap':
            obj_ = OrganisationMapType.factory()
            obj_.build(child_)
            self.OrganisationMap.append(obj_)
            obj_.original_tagname_ = 'OrganisationMap'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class OrganisationSchemeMapType


class OrganisationMapType(GeneratedsSuper):
    """OrganisationMap allows for the mapping of an organisation in one
    scheme against an organisation in another, target scheme. The
    organisationAlias attribute allows for an alias to be assigned
    to the mapping for searching across the set of mapped
    organisations."""
    subclass = None
    superclass = None
    def __init__(self, organisationAlias=None, OrganisationID=None, TargetOrganisationID=None):
        self.original_tagname_ = None
        self.organisationAlias = _cast(None, organisationAlias)
        self.OrganisationID = OrganisationID
        self.TargetOrganisationID = TargetOrganisationID
    def factory(*args_, **kwargs_):
        if OrganisationMapType.subclass:
            return OrganisationMapType.subclass(*args_, **kwargs_)
        else:
            return OrganisationMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrganisationID(self): return self.OrganisationID
    def set_OrganisationID(self, OrganisationID): self.OrganisationID = OrganisationID
    def get_TargetOrganisationID(self): return self.TargetOrganisationID
    def set_TargetOrganisationID(self, TargetOrganisationID): self.TargetOrganisationID = TargetOrganisationID
    def get_organisationAlias(self): return self.organisationAlias
    def set_organisationAlias(self, organisationAlias): self.organisationAlias = organisationAlias
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.OrganisationID is not None or
            self.TargetOrganisationID is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationMapType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationMapType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationMapType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationMapType'):
        if self.organisationAlias is not None and 'organisationAlias' not in already_processed:
            already_processed.add('organisationAlias')
            outfile.write(' organisationAlias=%s' % (quote_attrib(self.organisationAlias), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationMapType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganisationID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationID>%s</%sOrganisationID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationID).encode(ExternalEncoding), input_name='OrganisationID'), namespace_, eol_))
        if self.TargetOrganisationID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargetOrganisationID>%s</%sTargetOrganisationID>%s' % (namespace_, self.gds_format_string(quote_xml(self.TargetOrganisationID).encode(ExternalEncoding), input_name='TargetOrganisationID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrganisationMapType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.organisationAlias is not None and 'organisationAlias' not in already_processed:
            already_processed.add('organisationAlias')
            showIndent(outfile, level)
            outfile.write('organisationAlias=%s,\n' % (self.organisationAlias,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OrganisationID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationID=%s,\n' % quote_python(self.OrganisationID).encode(ExternalEncoding))
        if self.TargetOrganisationID is not None:
            showIndent(outfile, level)
            outfile.write('TargetOrganisationID=%s,\n' % quote_python(self.TargetOrganisationID).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('organisationAlias', node)
        if value is not None and 'organisationAlias' not in already_processed:
            already_processed.add('organisationAlias')
            self.organisationAlias = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrganisationID':
            OrganisationID_ = child_.text
            OrganisationID_ = self.gds_validate_string(OrganisationID_, node, 'OrganisationID')
            self.OrganisationID = OrganisationID_
            self.validate_IDType(self.OrganisationID)    # validate type IDType
        elif nodeName_ == 'TargetOrganisationID':
            TargetOrganisationID_ = child_.text
            TargetOrganisationID_ = self.gds_validate_string(TargetOrganisationID_, node, 'TargetOrganisationID')
            self.TargetOrganisationID = TargetOrganisationID_
            self.validate_IDType(self.TargetOrganisationID)    # validate type IDType
# end class OrganisationMapType


class ReportingTaxonomiesType(GeneratedsSuper):
    """ReportingTaxonomiesType holds on or more ReportingTaxonomy elements."""
    subclass = None
    superclass = None
    def __init__(self, ReportingTaxonomy=None):
        self.original_tagname_ = None
        if ReportingTaxonomy is None:
            self.ReportingTaxonomy = []
        else:
            self.ReportingTaxonomy = ReportingTaxonomy
    def factory(*args_, **kwargs_):
        if ReportingTaxonomiesType.subclass:
            return ReportingTaxonomiesType.subclass(*args_, **kwargs_)
        else:
            return ReportingTaxonomiesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ReportingTaxonomy(self): return self.ReportingTaxonomy
    def set_ReportingTaxonomy(self, ReportingTaxonomy): self.ReportingTaxonomy = ReportingTaxonomy
    def add_ReportingTaxonomy(self, value): self.ReportingTaxonomy.append(value)
    def insert_ReportingTaxonomy_at(self, index, value): self.ReportingTaxonomy.insert(index, value)
    def replace_ReportingTaxonomy_at(self, index, value): self.ReportingTaxonomy[index] = value
    def hasContent_(self):
        if (
            self.ReportingTaxonomy
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportingTaxonomiesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingTaxonomiesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportingTaxonomiesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportingTaxonomiesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportingTaxonomiesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ReportingTaxonomy_ in self.ReportingTaxonomy:
            ReportingTaxonomy_.export(outfile, level, namespace_, name_='ReportingTaxonomy', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReportingTaxonomiesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ReportingTaxonomy=[\n')
        level += 1
        for ReportingTaxonomy_ in self.ReportingTaxonomy:
            showIndent(outfile, level)
            outfile.write('model_.ReportingTaxonomyType(\n')
            ReportingTaxonomy_.exportLiteral(outfile, level, name_='ReportingTaxonomyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ReportingTaxonomy':
            obj_ = ReportingTaxonomyType.factory()
            obj_.build(child_)
            self.ReportingTaxonomy.append(obj_)
            obj_.original_tagname_ = 'ReportingTaxonomy'
# end class ReportingTaxonomiesType


class ReportingTaxonomyType(GeneratedsSuper):
    """ReportingTaxonomyType groups data flows and/or metadata flows for
    the purposes of assembling "reports" made up of data from
    disparate sources. It is a maintainable object, and thus has a
    mandatory human-readable Name and optional Description
    containing a longer human-readable description. Annotations may
    be included. All of these fields may be provided in multiple,
    parallel languages. The id attribute assignes a unique ID to the
    Reporting Taxonomy, version provides a version number, uri
    contains a URL where the SDMX-ML expression of the Reporting
    taxonomy can be found, and must be included if the
    isExternalReference attribute has a value of true. The urn
    attribute holds the value of a valid SDMX Registry URN as per
    the SDMX Registry specification. The isExternalReference
    attribute, if set to true, indicates that the uri attribute
    points to an external location for the ReportingTaxonomy, with
    only the id, Name element, and version supplied in addition. The
    agencyID attribute holds the ID of the Reporting Taxonomies'
    maintenance agency. Also, if the Reporting Taxonomy is final,
    the isFinal attribute must`have a value of true - otherwise, it
    will be assumed to be non-final. (All production versions must
    be made final - that is, unchangeable without versioning.) The
    sub-element Category may be used to group dataflows and
    metadataflows into useful sub-packages. DataflowRef and
    MetadataFlowRef are references to the flows which make up the
    reporting taxonomy at the top level. The validFrom and validTo
    attributes provide inclusive dates for providing supplemental
    validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, DataflowRef=None, MetadataflowRef=None, Category=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if DataflowRef is None:
            self.DataflowRef = []
        else:
            self.DataflowRef = DataflowRef
        if MetadataflowRef is None:
            self.MetadataflowRef = []
        else:
            self.MetadataflowRef = MetadataflowRef
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ReportingTaxonomyType.subclass:
            return ReportingTaxonomyType.subclass(*args_, **kwargs_)
        else:
            return ReportingTaxonomyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def add_DataflowRef(self, value): self.DataflowRef.append(value)
    def insert_DataflowRef_at(self, index, value): self.DataflowRef.insert(index, value)
    def replace_DataflowRef_at(self, index, value): self.DataflowRef[index] = value
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def add_MetadataflowRef(self, value): self.MetadataflowRef.append(value)
    def insert_MetadataflowRef_at(self, index, value): self.MetadataflowRef.insert(index, value)
    def replace_MetadataflowRef_at(self, index, value): self.MetadataflowRef[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.DataflowRef or
            self.MetadataflowRef or
            self.Category or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingTaxonomyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportingTaxonomyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportingTaxonomyType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for DataflowRef_ in self.DataflowRef:
            DataflowRef_.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        for MetadataflowRef_ in self.MetadataflowRef:
            MetadataflowRef_.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReportingTaxonomyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowRef=[\n')
        level += 1
        for DataflowRef_ in self.DataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.DataflowRefType(\n')
            DataflowRef_.exportLiteral(outfile, level, name_='DataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowRef=[\n')
        level += 1
        for MetadataflowRef_ in self.MetadataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowRefType(\n')
            MetadataflowRef_.exportLiteral(outfile, level, name_='MetadataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef.append(obj_)
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef.append(obj_)
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ReportingTaxonomyType


class MetadataflowRefType(GeneratedsSuper):
    """The MetadataflowRef type structures a reference to a metadataflow
    definition. This requires that ID are provided for a pre-
    existing Agency and Metadataflow Definition in the registry. The
    Version element may be used to specify the version of the
    indicated dataflow. If absent, the most recent version is
    assumed. The URN element is used to provide the registry-
    specific URN as an alternate means of identification. When used
    in a response document of any type, the URN must always be
    provided. At a minimum, either the URN element or AgencyID,
    MetadataflowID, and (optionally) version must be supplied.
    Datasource may be used to specify a datasource. Constraint can
    be used to provide constraints associated with the metadataflow.
    Note that this is similar, but not identical to the
    MetadataflowRefType found in the SDMX-ML registry namespace
    package - it lacks references to the datasource and the
    constraints."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, MetadataflowID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.MetadataflowID = MetadataflowID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if MetadataflowRefType.subclass:
            return MetadataflowRefType.subclass(*args_, **kwargs_)
        else:
            return MetadataflowRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_MetadataflowID(self): return self.MetadataflowID
    def set_MetadataflowID(self, MetadataflowID): self.MetadataflowID = MetadataflowID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.MetadataflowID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataflowRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataflowRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataflowRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataflowRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataflowRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.MetadataflowID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflowID>%s</%sMetadataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataflowID).encode(ExternalEncoding), input_name='MetadataflowID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataflowRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.MetadataflowID is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowID=%s,\n' % quote_python(self.MetadataflowID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'MetadataflowID':
            MetadataflowID_ = child_.text
            MetadataflowID_ = self.gds_validate_string(MetadataflowID_, node, 'MetadataflowID')
            self.MetadataflowID = MetadataflowID_
            self.validate_IDType(self.MetadataflowID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class MetadataflowRefType


class DataflowRefType(GeneratedsSuper):
    """The DataflowRef type structures a reference to a dataflow
    definition. This requires that ID are provided for a pre-
    existing Agency and Dataflow Definition in the registry. The
    Version element may be used to specify the version of the
    indicated dataflow. If absent, the most recent version is
    assumed. The URN element is used to provide the registry-
    specific URN as an alternate means of identification. At a
    minimum, either the URN element or AgencyID, DataflowID, and
    (optionally) version must be supplied. When used in a response
    document of any type, the URN must always be provided.
    Datasource may be used to specify a datasource. Constraints can
    be used to specify constraints associated with the dataflow.
    Note that this is similar, but not identical to the
    DataflowRefType found in the SDMX-ML registry namespace package
    - it lacks references to the datasource and the constraints."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, DataflowID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.DataflowID = DataflowID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if DataflowRefType.subclass:
            return DataflowRefType.subclass(*args_, **kwargs_)
        else:
            return DataflowRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_DataflowID(self): return self.DataflowID
    def set_DataflowID(self, DataflowID): self.DataflowID = DataflowID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.DataflowID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataflowRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataflowRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataflowRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataflowRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataflowRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.DataflowID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowID>%s</%sDataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataflowID).encode(ExternalEncoding), input_name='DataflowID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DataflowRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.DataflowID is not None:
            showIndent(outfile, level)
            outfile.write('DataflowID=%s,\n' % quote_python(self.DataflowID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'DataflowID':
            DataflowID_ = child_.text
            DataflowID_ = self.gds_validate_string(DataflowID_, node, 'DataflowID')
            self.DataflowID = DataflowID_
            self.validate_IDType(self.DataflowID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class DataflowRefType


class ProcessesType(GeneratedsSuper):
    """ProcessesType describes a list of Processes."""
    subclass = None
    superclass = None
    def __init__(self, Process=None):
        self.original_tagname_ = None
        if Process is None:
            self.Process = []
        else:
            self.Process = Process
    def factory(*args_, **kwargs_):
        if ProcessesType.subclass:
            return ProcessesType.subclass(*args_, **kwargs_)
        else:
            return ProcessesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Process(self): return self.Process
    def set_Process(self, Process): self.Process = Process
    def add_Process(self, value): self.Process.append(value)
    def insert_Process_at(self, index, value): self.Process.insert(index, value)
    def replace_Process_at(self, index, value): self.Process[index] = value
    def hasContent_(self):
        if (
            self.Process
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProcessesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProcessesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProcessesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProcessesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Process_ in self.Process:
            Process_.export(outfile, level, namespace_, name_='Process', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Process=[\n')
        level += 1
        for Process_ in self.Process:
            showIndent(outfile, level)
            outfile.write('model_.ProcessType(\n')
            Process_.exportLiteral(outfile, level, name_='ProcessType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Process':
            obj_ = ProcessType.factory()
            obj_.build(child_)
            self.Process.append(obj_)
            obj_.original_tagname_ = 'Process'
# end class ProcessesType


class ProcessType(GeneratedsSuper):
    """ProcessType generically describes a statistical process. In this
    version of the SDMX Technical Specifications, it is not meant to
    support process automation, but serves as a description of how
    processes occur. The primary use for this structural mechanism
    is the attachment of reference metadata regarding statistical
    processing. A process has a human-readable Name, which may be
    provided in multiple, parallel-language versions. It also has an
    optional human-readable Description, which also may be provided
    with multiple, parallel-language versions. The Annotations
    element allows for it to be annotated. The id attribute takes a
    unique id within the set of processes maintained by the agency
    identified in the agencyID attribute. The version attribute
    indicated the version of teh process description. The uri value
    is a URL where a complete description of the Process may be
    found; the urn attribute takes the valid registry URN of the
    Process, as described in the SDMX Registry Specification. If
    isFinal is set to true, the process description cannot be
    changed without versioning. If isExternalReference is true, then
    only the id, agency, Name, and uri (or URN) need be supplied -
    all other fields are assumed to be found in a valid SDMX
    Structure message found at the uri attribute location. The
    validFrom and validTo attributes provide inclusive dates for
    providing supplemental validity information about the version."""
    subclass = None
    superclass = None
    def __init__(self, agencyID=None, isFinal=None, urn=None, uri=None, validTo=None, version=None, isExternalReference=None, validFrom=None, id=None, Name=None, Description=None, ProcessStep=None, Annotations=None):
        self.original_tagname_ = None
        self.agencyID = _cast(None, agencyID)
        self.isFinal = _cast(bool, isFinal)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.version = _cast(None, version)
        self.isExternalReference = _cast(bool, isExternalReference)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if ProcessStep is None:
            self.ProcessStep = []
        else:
            self.ProcessStep = ProcessStep
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ProcessType.subclass:
            return ProcessType.subclass(*args_, **kwargs_)
        else:
            return ProcessType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_ProcessStep(self): return self.ProcessStep
    def set_ProcessStep(self, ProcessStep): self.ProcessStep = ProcessStep
    def add_ProcessStep(self, value): self.ProcessStep.append(value)
    def insert_ProcessStep_at(self, index, value): self.ProcessStep.insert(index, value)
    def replace_ProcessStep_at(self, index, value): self.ProcessStep[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_agencyID(self): return self.agencyID
    def set_agencyID(self, agencyID): self.agencyID = agencyID
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_isExternalReference(self): return self.isExternalReference
    def set_isExternalReference(self, isExternalReference): self.isExternalReference = isExternalReference
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.ProcessStep or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProcessType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProcessType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProcessType'):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            outfile.write(' agencyID=%s' % (quote_attrib(self.agencyID), ))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            outfile.write(' version=%s' % (self.gds_format_string(quote_attrib(self.version).encode(ExternalEncoding), input_name='version'), ))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            outfile.write(' isExternalReference="%s"' % self.gds_format_boolean(self.isExternalReference, input_name='isExternalReference'))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProcessType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for ProcessStep_ in self.ProcessStep:
            ProcessStep_.export(outfile, level, namespace_, name_='ProcessStep', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.agencyID is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            showIndent(outfile, level)
            outfile.write('agencyID=%s,\n' % (self.agencyID,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.version is not None and 'version' not in already_processed:
            already_processed.add('version')
            showIndent(outfile, level)
            outfile.write('version="%s",\n' % (self.version,))
        if self.isExternalReference is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            showIndent(outfile, level)
            outfile.write('isExternalReference=%s,\n' % (self.isExternalReference,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProcessStep=[\n')
        level += 1
        for ProcessStep_ in self.ProcessStep:
            showIndent(outfile, level)
            outfile.write('model_.ProcessStepType(\n')
            ProcessStep_.exportLiteral(outfile, level, name_='ProcessStepType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('agencyID', node)
        if value is not None and 'agencyID' not in already_processed:
            already_processed.add('agencyID')
            self.agencyID = value
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('version', node)
        if value is not None and 'version' not in already_processed:
            already_processed.add('version')
            self.version = value
        value = find_attr_value_('isExternalReference', node)
        if value is not None and 'isExternalReference' not in already_processed:
            already_processed.add('isExternalReference')
            if value in ('true', '1'):
                self.isExternalReference = True
            elif value in ('false', '0'):
                self.isExternalReference = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'ProcessStep':
            obj_ = ProcessStepType.factory()
            obj_.build(child_)
            self.ProcessStep.append(obj_)
            obj_.original_tagname_ = 'ProcessStep'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ProcessType


class ProcessStepType(GeneratedsSuper):
    """ProcessStepType describes a single step in a statistical process.
    ProcessSteps may be recursive. The Input element specifies the
    type of object(s) which serve as inputs to the process; the
    Output element specifies the type of objects which are the
    result of the process. Computation elements describe the
    computations involved in the process, in any form desired by the
    user (these are informational rather than machine-actionable),
    and so may be supplied in multiple, parallel-language versions.
    Transitions describe the process steps to which a process is
    connected - that is, which processes happen next. The process
    step maust be given a Name, and may be given a Description.
    These are human-readable, and may be supplied in multiple,
    parallel-language versions. Annotations may be supplied. The id
    attribute takes the unique identifier of the process step within
    the parent process."""
    subclass = None
    superclass = None
    def __init__(self, id=None, Name=None, Description=None, Input=None, Output=None, Computation=None, Transition=None, ProcessStep=None, Annotations=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        if Input is None:
            self.Input = []
        else:
            self.Input = Input
        if Output is None:
            self.Output = []
        else:
            self.Output = Output
        if Computation is None:
            self.Computation = []
        else:
            self.Computation = Computation
        if Transition is None:
            self.Transition = []
        else:
            self.Transition = Transition
        if ProcessStep is None:
            self.ProcessStep = []
        else:
            self.ProcessStep = ProcessStep
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ProcessStepType.subclass:
            return ProcessStepType.subclass(*args_, **kwargs_)
        else:
            return ProcessStepType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_Input(self): return self.Input
    def set_Input(self, Input): self.Input = Input
    def add_Input(self, value): self.Input.append(value)
    def insert_Input_at(self, index, value): self.Input.insert(index, value)
    def replace_Input_at(self, index, value): self.Input[index] = value
    def get_Output(self): return self.Output
    def set_Output(self, Output): self.Output = Output
    def add_Output(self, value): self.Output.append(value)
    def insert_Output_at(self, index, value): self.Output.insert(index, value)
    def replace_Output_at(self, index, value): self.Output[index] = value
    def get_Computation(self): return self.Computation
    def set_Computation(self, Computation): self.Computation = Computation
    def add_Computation(self, value): self.Computation.append(value)
    def insert_Computation_at(self, index, value): self.Computation.insert(index, value)
    def replace_Computation_at(self, index, value): self.Computation[index] = value
    def get_Transition(self): return self.Transition
    def set_Transition(self, Transition): self.Transition = Transition
    def add_Transition(self, value): self.Transition.append(value)
    def insert_Transition_at(self, index, value): self.Transition.insert(index, value)
    def replace_Transition_at(self, index, value): self.Transition[index] = value
    def get_ProcessStep(self): return self.ProcessStep
    def set_ProcessStep(self, ProcessStep): self.ProcessStep = ProcessStep
    def add_ProcessStep(self, value): self.ProcessStep.append(value)
    def insert_ProcessStep_at(self, index, value): self.ProcessStep.insert(index, value)
    def replace_ProcessStep_at(self, index, value): self.ProcessStep[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_ObjectIDType(self, value):
        # Validate type ObjectIDType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.Input or
            self.Output or
            self.Computation or
            self.Transition or
            self.ProcessStep or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProcessStepType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessStepType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProcessStepType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProcessStepType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProcessStepType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        for Input_ in self.Input:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sInput>%s</%sInput>%s' % (namespace_, self.gds_format_string(quote_xml(Input_).encode(ExternalEncoding), input_name='Input'), namespace_, eol_))
        for Output_ in self.Output:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOutput>%s</%sOutput>%s' % (namespace_, self.gds_format_string(quote_xml(Output_).encode(ExternalEncoding), input_name='Output'), namespace_, eol_))
        for Computation_ in self.Computation:
            Computation_.export(outfile, level, namespace_, name_='Computation', pretty_print=pretty_print)
        for Transition_ in self.Transition:
            Transition_.export(outfile, level, namespace_, name_='Transition', pretty_print=pretty_print)
        for ProcessStep_ in self.ProcessStep:
            ProcessStep_.export(outfile, level, namespace_, name_='ProcessStep', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessStepType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Input=[\n')
        level += 1
        for Input_ in self.Input:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Input_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Output=[\n')
        level += 1
        for Output_ in self.Output:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Output_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Computation=[\n')
        level += 1
        for Computation_ in self.Computation:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Computation_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Transition=[\n')
        level += 1
        for Transition_ in self.Transition:
            showIndent(outfile, level)
            outfile.write('model_.TransitionType(\n')
            Transition_.exportLiteral(outfile, level, name_='TransitionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProcessStep=[\n')
        level += 1
        for ProcessStep_ in self.ProcessStep:
            showIndent(outfile, level)
            outfile.write('model_.ProcessStepType(\n')
            ProcessStep_.exportLiteral(outfile, level, name_='ProcessStepType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'Input':
            Input_ = child_.text
            Input_ = self.gds_validate_string(Input_, node, 'Input')
            self.Input.append(Input_)
            self.validate_ObjectIDType(self.Input)    # validate type ObjectIDType
        elif nodeName_ == 'Output':
            Output_ = child_.text
            Output_ = self.gds_validate_string(Output_, node, 'Output')
            self.Output.append(Output_)
            self.validate_ObjectIDType(self.Output)    # validate type ObjectIDType
        elif nodeName_ == 'Computation':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Computation.append(obj_)
            obj_.original_tagname_ = 'Computation'
        elif nodeName_ == 'Transition':
            obj_ = TransitionType.factory()
            obj_.build(child_)
            self.Transition.append(obj_)
            obj_.original_tagname_ = 'Transition'
        elif nodeName_ == 'ProcessStep':
            obj_ = ProcessStepType.factory()
            obj_.build(child_)
            self.ProcessStep.append(obj_)
            obj_.original_tagname_ = 'ProcessStep'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ProcessStepType


class TransitionType(GeneratedsSuper):
    """TransitionType describes the Condition and next step in a
    transition. The Condition text is informational, and may be
    supplied in multiple, parallel-language form. The TargetStep
    holds the id of the next step in the process if the condition is
    met."""
    subclass = None
    superclass = None
    def __init__(self, TargetStep=None, Condition=None):
        self.original_tagname_ = None
        self.TargetStep = TargetStep
        self.Condition = Condition
    def factory(*args_, **kwargs_):
        if TransitionType.subclass:
            return TransitionType.subclass(*args_, **kwargs_)
        else:
            return TransitionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TargetStep(self): return self.TargetStep
    def set_TargetStep(self, TargetStep): self.TargetStep = TargetStep
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TargetStep is not None or
            self.Condition is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TransitionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TransitionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TransitionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TransitionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='TransitionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TargetStep is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargetStep>%s</%sTargetStep>%s' % (namespace_, self.gds_format_string(quote_xml(self.TargetStep).encode(ExternalEncoding), input_name='TargetStep'), namespace_, eol_))
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TransitionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TargetStep is not None:
            showIndent(outfile, level)
            outfile.write('TargetStep=%s,\n' % quote_python(self.TargetStep).encode(ExternalEncoding))
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.TextType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TargetStep':
            TargetStep_ = child_.text
            TargetStep_ = self.gds_validate_string(TargetStep_, node, 'TargetStep')
            self.TargetStep = TargetStep_
            self.validate_IDType(self.TargetStep)    # validate type IDType
        elif nodeName_ == 'Condition':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Condition = obj_
            obj_.original_tagname_ = 'Condition'
# end class TransitionType


class ConstraintType(GeneratedsSuper):
    """Constraint specifies the object to which constraints are attached.
    Note that if the constraint is that for a Data Provider, then
    only ReleaseCalendar information is relevant, as there is no
    reliable way of determining which key family is being used to
    frame constraints in terms of cube regions or key sets.
    ReferencePeriod is used to report start date and end date
    constraints. MetadataConceptSet allows for conten t constraints
    to be described for metadata sets."""
    subclass = None
    superclass = None
    def __init__(self, ConstraintType=None, ConstraintID=None, CubeRegion=None, MetadataConceptSet=None, KeySet=None, ReleaseCalendar=None, ReferencePeriod=None):
        self.original_tagname_ = None
        self.ConstraintType = _cast(None, ConstraintType)
        self.ConstraintID = ConstraintID
        if CubeRegion is None:
            self.CubeRegion = []
        else:
            self.CubeRegion = CubeRegion
        self.MetadataConceptSet = MetadataConceptSet
        if KeySet is None:
            self.KeySet = []
        else:
            self.KeySet = KeySet
        self.ReleaseCalendar = ReleaseCalendar
        self.ReferencePeriod = ReferencePeriod
    def factory(*args_, **kwargs_):
        if ConstraintType.subclass:
            return ConstraintType.subclass(*args_, **kwargs_)
        else:
            return ConstraintType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ConstraintID(self): return self.ConstraintID
    def set_ConstraintID(self, ConstraintID): self.ConstraintID = ConstraintID
    def get_CubeRegion(self): return self.CubeRegion
    def set_CubeRegion(self, CubeRegion): self.CubeRegion = CubeRegion
    def add_CubeRegion(self, value): self.CubeRegion.append(value)
    def insert_CubeRegion_at(self, index, value): self.CubeRegion.insert(index, value)
    def replace_CubeRegion_at(self, index, value): self.CubeRegion[index] = value
    def get_MetadataConceptSet(self): return self.MetadataConceptSet
    def set_MetadataConceptSet(self, MetadataConceptSet): self.MetadataConceptSet = MetadataConceptSet
    def get_KeySet(self): return self.KeySet
    def set_KeySet(self, KeySet): self.KeySet = KeySet
    def add_KeySet(self, value): self.KeySet.append(value)
    def insert_KeySet_at(self, index, value): self.KeySet.insert(index, value)
    def replace_KeySet_at(self, index, value): self.KeySet[index] = value
    def get_ReleaseCalendar(self): return self.ReleaseCalendar
    def set_ReleaseCalendar(self, ReleaseCalendar): self.ReleaseCalendar = ReleaseCalendar
    def get_ReferencePeriod(self): return self.ReferencePeriod
    def set_ReferencePeriod(self, ReferencePeriod): self.ReferencePeriod = ReferencePeriod
    def get_ConstraintType(self): return self.ConstraintType
    def set_ConstraintType(self, ConstraintType): self.ConstraintType = ConstraintType
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def validate_ConstraintTypeType(self, value):
        # Validate type ConstraintTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.ConstraintID is not None or
            self.CubeRegion or
            self.MetadataConceptSet is not None or
            self.KeySet or
            self.ReleaseCalendar is not None or
            self.ReferencePeriod is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConstraintType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConstraintType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConstraintType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConstraintType'):
        if self.ConstraintType is not None and 'ConstraintType' not in already_processed:
            already_processed.add('ConstraintType')
            outfile.write(' ConstraintType=%s' % (quote_attrib(self.ConstraintType), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConstraintType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ConstraintID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConstraintID>%s</%sConstraintID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ConstraintID).encode(ExternalEncoding), input_name='ConstraintID'), namespace_, eol_))
        for CubeRegion_ in self.CubeRegion:
            CubeRegion_.export(outfile, level, namespace_, name_='CubeRegion', pretty_print=pretty_print)
        if self.MetadataConceptSet is not None:
            self.MetadataConceptSet.export(outfile, level, namespace_, name_='MetadataConceptSet', pretty_print=pretty_print)
        for KeySet_ in self.KeySet:
            KeySet_.export(outfile, level, namespace_, name_='KeySet', pretty_print=pretty_print)
        if self.ReleaseCalendar is not None:
            self.ReleaseCalendar.export(outfile, level, namespace_, name_='ReleaseCalendar', pretty_print=pretty_print)
        if self.ReferencePeriod is not None:
            self.ReferencePeriod.export(outfile, level, namespace_, name_='ReferencePeriod', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConstraintType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.ConstraintType is not None and 'ConstraintType' not in already_processed:
            already_processed.add('ConstraintType')
            showIndent(outfile, level)
            outfile.write('ConstraintType="%s",\n' % (self.ConstraintType,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ConstraintID is not None:
            showIndent(outfile, level)
            outfile.write('ConstraintID=%s,\n' % quote_python(self.ConstraintID).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('CubeRegion=[\n')
        level += 1
        for CubeRegion_ in self.CubeRegion:
            showIndent(outfile, level)
            outfile.write('model_.CubeRegionType(\n')
            CubeRegion_.exportLiteral(outfile, level, name_='CubeRegionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MetadataConceptSet is not None:
            showIndent(outfile, level)
            outfile.write('MetadataConceptSet=model_.MetadataConceptSetType(\n')
            self.MetadataConceptSet.exportLiteral(outfile, level, name_='MetadataConceptSet')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('KeySet=[\n')
        level += 1
        for KeySet_ in self.KeySet:
            showIndent(outfile, level)
            outfile.write('model_.KeySetType(\n')
            KeySet_.exportLiteral(outfile, level, name_='KeySetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.ReleaseCalendar is not None:
            showIndent(outfile, level)
            outfile.write('ReleaseCalendar=model_.ReleaseCalendarType(\n')
            self.ReleaseCalendar.exportLiteral(outfile, level, name_='ReleaseCalendar')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReferencePeriod is not None:
            showIndent(outfile, level)
            outfile.write('ReferencePeriod=model_.ReferencePeriodType(\n')
            self.ReferencePeriod.exportLiteral(outfile, level, name_='ReferencePeriod')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('ConstraintType', node)
        if value is not None and 'ConstraintType' not in already_processed:
            already_processed.add('ConstraintType')
            self.ConstraintType = value
            self.validate_ConstraintTypeType(self.ConstraintType)    # validate type ConstraintTypeType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ConstraintID':
            ConstraintID_ = child_.text
            ConstraintID_ = self.gds_validate_string(ConstraintID_, node, 'ConstraintID')
            self.ConstraintID = ConstraintID_
            self.validate_IDType(self.ConstraintID)    # validate type IDType
        elif nodeName_ == 'CubeRegion':
            obj_ = CubeRegionType.factory()
            obj_.build(child_)
            self.CubeRegion.append(obj_)
            obj_.original_tagname_ = 'CubeRegion'
        elif nodeName_ == 'MetadataConceptSet':
            obj_ = MetadataConceptSetType.factory()
            obj_.build(child_)
            self.MetadataConceptSet = obj_
            obj_.original_tagname_ = 'MetadataConceptSet'
        elif nodeName_ == 'KeySet':
            obj_ = KeySetType.factory()
            obj_.build(child_)
            self.KeySet.append(obj_)
            obj_.original_tagname_ = 'KeySet'
        elif nodeName_ == 'ReleaseCalendar':
            obj_ = ReleaseCalendarType.factory()
            obj_.build(child_)
            self.ReleaseCalendar = obj_
            obj_.original_tagname_ = 'ReleaseCalendar'
        elif nodeName_ == 'ReferencePeriod':
            obj_ = ReferencePeriodType.factory()
            obj_.build(child_)
            self.ReferencePeriod = obj_
            obj_.original_tagname_ = 'ReferencePeriod'
# end class ConstraintType


class CubeRegionType(GeneratedsSuper):
    """CubeRegion describes the portion(s) of the possible combinations of
    all components within a key family or metadata structure
    definition by providing valid values on a per-component basis.
    This does not guarantee that data will be available for all
    possible combinations, but describes the portion of the cube in
    which it is useful to query for data. The isIncluded attribute,
    if true, indicates that the described area is the one in which
    it is useful to search/expect to find data. If false, this means
    that the portions of the cube outside the described region are
    useful to search/where you may expect to find data."""
    subclass = None
    superclass = None
    def __init__(self, isIncluded=None, Member=None):
        self.original_tagname_ = None
        self.isIncluded = _cast(bool, isIncluded)
        if Member is None:
            self.Member = []
        else:
            self.Member = Member
    def factory(*args_, **kwargs_):
        if CubeRegionType.subclass:
            return CubeRegionType.subclass(*args_, **kwargs_)
        else:
            return CubeRegionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Member(self): return self.Member
    def set_Member(self, Member): self.Member = Member
    def add_Member(self, value): self.Member.append(value)
    def insert_Member_at(self, index, value): self.Member.insert(index, value)
    def replace_Member_at(self, index, value): self.Member[index] = value
    def get_isIncluded(self): return self.isIncluded
    def set_isIncluded(self, isIncluded): self.isIncluded = isIncluded
    def hasContent_(self):
        if (
            self.Member
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CubeRegionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CubeRegionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CubeRegionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CubeRegionType'):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            outfile.write(' isIncluded="%s"' % self.gds_format_boolean(self.isIncluded, input_name='isIncluded'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CubeRegionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Member_ in self.Member:
            Member_.export(outfile, level, namespace_, name_='Member', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CubeRegionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            showIndent(outfile, level)
            outfile.write('isIncluded=%s,\n' % (self.isIncluded,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Member=[\n')
        level += 1
        for Member_ in self.Member:
            showIndent(outfile, level)
            outfile.write('model_.MemberType(\n')
            Member_.exportLiteral(outfile, level, name_='MemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isIncluded', node)
        if value is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            if value in ('true', '1'):
                self.isIncluded = True
            elif value in ('false', '0'):
                self.isIncluded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Member':
            obj_ = MemberType.factory()
            obj_.build(child_)
            self.Member.append(obj_)
            obj_.original_tagname_ = 'Member'
# end class CubeRegionType


class MetadataConceptSetType(GeneratedsSuper):
    """The isIncluded attribute, if true, indicates that the described
    concepts - of those described as possibilities in the relevant
    metadata structure definition - are reported. If the value is
    false, then the specified concepts are not reported."""
    subclass = None
    superclass = None
    def __init__(self, isIncluded=None, Member=None):
        self.original_tagname_ = None
        self.isIncluded = _cast(bool, isIncluded)
        if Member is None:
            self.Member = []
        else:
            self.Member = Member
    def factory(*args_, **kwargs_):
        if MetadataConceptSetType.subclass:
            return MetadataConceptSetType.subclass(*args_, **kwargs_)
        else:
            return MetadataConceptSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Member(self): return self.Member
    def set_Member(self, Member): self.Member = Member
    def add_Member(self, value): self.Member.append(value)
    def insert_Member_at(self, index, value): self.Member.insert(index, value)
    def replace_Member_at(self, index, value): self.Member[index] = value
    def get_isIncluded(self): return self.isIncluded
    def set_isIncluded(self, isIncluded): self.isIncluded = isIncluded
    def hasContent_(self):
        if (
            self.Member
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataConceptSetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataConceptSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataConceptSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataConceptSetType'):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            outfile.write(' isIncluded="%s"' % self.gds_format_boolean(self.isIncluded, input_name='isIncluded'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataConceptSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Member_ in self.Member:
            Member_.export(outfile, level, namespace_, name_='Member', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataConceptSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            showIndent(outfile, level)
            outfile.write('isIncluded=%s,\n' % (self.isIncluded,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Member=[\n')
        level += 1
        for Member_ in self.Member:
            showIndent(outfile, level)
            outfile.write('model_.MemberType(\n')
            Member_.exportLiteral(outfile, level, name_='MemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isIncluded', node)
        if value is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            if value in ('true', '1'):
                self.isIncluded = True
            elif value in ('false', '0'):
                self.isIncluded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Member':
            obj_ = MemberType.factory()
            obj_.build(child_)
            self.Member.append(obj_)
            obj_.original_tagname_ = 'Member'
# end class MetadataConceptSetType


class MemberType(GeneratedsSuper):
    """Member describes the constrained component - which can be a
    dimension, an attribute, a metadata attribute, or a measure.
    This must agree with the metadata structure definition or key
    family referenced by the Provision Agreement's Dataflow or
    Metadataflow. The isIncluded attribute indicates whether the
    Member is listing included or excluded values for each
    component, as seen against the full valid set described in the
    key family. When used to describe reported metadata, the
    MemberValue may be omitted in cases where no specification is
    made regarding the representation of the concept (as is the case
    with un-coded metadata attributes). Otherwise, MemberValue must
    be included."""
    subclass = None
    superclass = None
    def __init__(self, isIncluded=None, ComponentRef=None, MemberValue=None):
        self.original_tagname_ = None
        self.isIncluded = _cast(bool, isIncluded)
        self.ComponentRef = ComponentRef
        if MemberValue is None:
            self.MemberValue = []
        else:
            self.MemberValue = MemberValue
    def factory(*args_, **kwargs_):
        if MemberType.subclass:
            return MemberType.subclass(*args_, **kwargs_)
        else:
            return MemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComponentRef(self): return self.ComponentRef
    def set_ComponentRef(self, ComponentRef): self.ComponentRef = ComponentRef
    def get_MemberValue(self): return self.MemberValue
    def set_MemberValue(self, MemberValue): self.MemberValue = MemberValue
    def add_MemberValue(self, value): self.MemberValue.append(value)
    def insert_MemberValue_at(self, index, value): self.MemberValue.insert(index, value)
    def replace_MemberValue_at(self, index, value): self.MemberValue[index] = value
    def get_isIncluded(self): return self.isIncluded
    def set_isIncluded(self, isIncluded): self.isIncluded = isIncluded
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ComponentRef is not None or
            self.MemberValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MemberType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MemberType'):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            outfile.write(' isIncluded="%s"' % self.gds_format_boolean(self.isIncluded, input_name='isIncluded'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MemberType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ComponentRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComponentRef>%s</%sComponentRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.ComponentRef).encode(ExternalEncoding), input_name='ComponentRef'), namespace_, eol_))
        for MemberValue_ in self.MemberValue:
            MemberValue_.export(outfile, level, namespace_, name_='MemberValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MemberType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            showIndent(outfile, level)
            outfile.write('isIncluded=%s,\n' % (self.isIncluded,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ComponentRef is not None:
            showIndent(outfile, level)
            outfile.write('ComponentRef=%s,\n' % quote_python(self.ComponentRef).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('MemberValue=[\n')
        level += 1
        for MemberValue_ in self.MemberValue:
            showIndent(outfile, level)
            outfile.write('model_.MemberValueType(\n')
            MemberValue_.exportLiteral(outfile, level, name_='MemberValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isIncluded', node)
        if value is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            if value in ('true', '1'):
                self.isIncluded = True
            elif value in ('false', '0'):
                self.isIncluded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComponentRef':
            ComponentRef_ = child_.text
            ComponentRef_ = self.gds_validate_string(ComponentRef_, node, 'ComponentRef')
            self.ComponentRef = ComponentRef_
            self.validate_IDType(self.ComponentRef)    # validate type IDType
        elif nodeName_ == 'MemberValue':
            obj_ = MemberValueType.factory()
            obj_.build(child_)
            self.MemberValue.append(obj_)
            obj_.original_tagname_ = 'MemberValue'
# end class MemberType


class MemberValueType(GeneratedsSuper):
    """MemberValue specifies the value of the specified component, which
    must be a valid value as described in the appropriate structure
    definition (key family)."""
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        self.original_tagname_ = None
        self.Value = Value
    def factory(*args_, **kwargs_):
        if MemberValueType.subclass:
            return MemberValueType.subclass(*args_, **kwargs_)
        else:
            return MemberValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def hasContent_(self):
        if (
            self.Value is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MemberValueType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MemberValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MemberValueType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MemberValueType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MemberValueType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Value is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(self.Value).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MemberValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Value is not None:
            showIndent(outfile, level)
            outfile.write('Value=%s,\n' % quote_python(self.Value).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value = Value_
# end class MemberValueType


class KeySetType(GeneratedsSuper):
    """KeySet describes a set of keys. The isIncluded attribute, if true,
    indicates that the specified keys are valid keys within the
    constraint. If false, the set of keys described are not valid -
    all other possible keys are the valid ones."""
    subclass = None
    superclass = None
    def __init__(self, isIncluded=None, Key=None):
        self.original_tagname_ = None
        self.isIncluded = _cast(bool, isIncluded)
        self.Key = Key
    def factory(*args_, **kwargs_):
        if KeySetType.subclass:
            return KeySetType.subclass(*args_, **kwargs_)
        else:
            return KeySetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Key(self): return self.Key
    def set_Key(self, Key): self.Key = Key
    def get_isIncluded(self): return self.isIncluded
    def set_isIncluded(self, isIncluded): self.isIncluded = isIncluded
    def hasContent_(self):
        if (
            self.Key is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeySetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeySetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeySetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeySetType'):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            outfile.write(' isIncluded="%s"' % self.gds_format_boolean(self.isIncluded, input_name='isIncluded'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeySetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Key is not None:
            self.Key.export(outfile, level, namespace_, name_='Key', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='KeySetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isIncluded is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            showIndent(outfile, level)
            outfile.write('isIncluded=%s,\n' % (self.isIncluded,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeyType is not None:
            showIndent(outfile, level)
            outfile.write('KeyType=model_.KeyType(\n')
            self.KeyType.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isIncluded', node)
        if value is not None and 'isIncluded' not in already_processed:
            already_processed.add('isIncluded')
            if value in ('true', '1'):
                self.isIncluded = True
            elif value in ('false', '0'):
                self.isIncluded = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Key':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Key> element')
            self.Key = obj_
            obj_.original_tagname_ = 'Key'
# end class KeySetType


class KeyType(GeneratedsSuper):
    """Key allows for sets of component references - holding the name of
    the component's concept - and a permitted value for that
    component. This conctruct can be repeated as many times as
    dessired, but must describe complete keys according to teh
    relevant structure definition (key family)."""
    subclass = None
    superclass = None
    def __init__(self, ComponentRef=None, Value=None):
        self.original_tagname_ = None
        if ComponentRef is None:
            self.ComponentRef = []
        else:
            self.ComponentRef = ComponentRef
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if KeyType.subclass:
            return KeyType.subclass(*args_, **kwargs_)
        else:
            return KeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComponentRef(self): return self.ComponentRef
    def set_ComponentRef(self, ComponentRef): self.ComponentRef = ComponentRef
    def add_ComponentRef(self, value): self.ComponentRef.append(value)
    def insert_ComponentRef_at(self, index, value): self.ComponentRef.insert(index, value)
    def replace_ComponentRef_at(self, index, value): self.ComponentRef[index] = value
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ComponentRef or
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ComponentRef_ in self.ComponentRef:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sComponentRef>%s</%sComponentRef>%s' % (namespace_, self.gds_format_string(quote_xml(ComponentRef_).encode(ExternalEncoding), input_name='ComponentRef'), namespace_, eol_))
        for Value_ in self.Value:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValue>%s</%sValue>%s' % (namespace_, self.gds_format_string(quote_xml(Value_).encode(ExternalEncoding), input_name='Value'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='KeyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ComponentRef=[\n')
        level += 1
        for ComponentRef_ in self.ComponentRef:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ComponentRef_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Value_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComponentRef':
            ComponentRef_ = child_.text
            ComponentRef_ = self.gds_validate_string(ComponentRef_, node, 'ComponentRef')
            self.ComponentRef.append(ComponentRef_)
            self.validate_IDType(self.ComponentRef)    # validate type IDType
        elif nodeName_ == 'Value':
            Value_ = child_.text
            Value_ = self.gds_validate_string(Value_, node, 'Value')
            self.Value.append(Value_)
# end class KeyType


class ReleaseCalendarType(GeneratedsSuper):
    """The ReleaseCalendar holds information about the timing of releases
    of the constrained data. Periodicity is the period between
    releases of the data set. Offset is the interval between January
    first and the first release of data within the year. Tolerance
    is the period after which the release of data may be deemed
    late. All of these values use the standard "P7D"-style format."""
    subclass = None
    superclass = None
    def __init__(self, Periodicity=None, Offset=None, Tolerance=None):
        self.original_tagname_ = None
        self.Periodicity = Periodicity
        self.Offset = Offset
        self.Tolerance = Tolerance
    def factory(*args_, **kwargs_):
        if ReleaseCalendarType.subclass:
            return ReleaseCalendarType.subclass(*args_, **kwargs_)
        else:
            return ReleaseCalendarType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Periodicity(self): return self.Periodicity
    def set_Periodicity(self, Periodicity): self.Periodicity = Periodicity
    def get_Offset(self): return self.Offset
    def set_Offset(self, Offset): self.Offset = Offset
    def get_Tolerance(self): return self.Tolerance
    def set_Tolerance(self, Tolerance): self.Tolerance = Tolerance
    def hasContent_(self):
        if (
            self.Periodicity is not None or
            self.Offset is not None or
            self.Tolerance is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReleaseCalendarType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReleaseCalendarType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReleaseCalendarType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReleaseCalendarType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReleaseCalendarType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Periodicity is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPeriodicity>%s</%sPeriodicity>%s' % (namespace_, self.gds_format_string(quote_xml(self.Periodicity).encode(ExternalEncoding), input_name='Periodicity'), namespace_, eol_))
        if self.Offset is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOffset>%s</%sOffset>%s' % (namespace_, self.gds_format_string(quote_xml(self.Offset).encode(ExternalEncoding), input_name='Offset'), namespace_, eol_))
        if self.Tolerance is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTolerance>%s</%sTolerance>%s' % (namespace_, self.gds_format_string(quote_xml(self.Tolerance).encode(ExternalEncoding), input_name='Tolerance'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReleaseCalendarType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Periodicity is not None:
            showIndent(outfile, level)
            outfile.write('Periodicity=%s,\n' % quote_python(self.Periodicity).encode(ExternalEncoding))
        if self.Offset is not None:
            showIndent(outfile, level)
            outfile.write('Offset=%s,\n' % quote_python(self.Offset).encode(ExternalEncoding))
        if self.Tolerance is not None:
            showIndent(outfile, level)
            outfile.write('Tolerance=%s,\n' % quote_python(self.Tolerance).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Periodicity':
            Periodicity_ = child_.text
            Periodicity_ = self.gds_validate_string(Periodicity_, node, 'Periodicity')
            self.Periodicity = Periodicity_
        elif nodeName_ == 'Offset':
            Offset_ = child_.text
            Offset_ = self.gds_validate_string(Offset_, node, 'Offset')
            self.Offset = Offset_
        elif nodeName_ == 'Tolerance':
            Tolerance_ = child_.text
            Tolerance_ = self.gds_validate_string(Tolerance_, node, 'Tolerance')
            self.Tolerance = Tolerance_
# end class ReleaseCalendarType


class ReferencePeriodType(GeneratedsSuper):
    """Specifies the inclusive start and end times for a registry query."""
    subclass = None
    superclass = None
    def __init__(self, endTime=None, startTime=None):
        self.original_tagname_ = None
        if isinstance(endTime, basestring):
            initvalue_ = datetime_.datetime.strptime(endTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = endTime
        self.endTime = initvalue_
        if isinstance(startTime, basestring):
            initvalue_ = datetime_.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startTime
        self.startTime = initvalue_
    def factory(*args_, **kwargs_):
        if ReferencePeriodType.subclass:
            return ReferencePeriodType.subclass(*args_, **kwargs_)
        else:
            return ReferencePeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_endTime(self): return self.endTime
    def set_endTime(self, endTime): self.endTime = endTime
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReferencePeriodType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferencePeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReferencePeriodType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReferencePeriodType'):
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            outfile.write(' endTime="%s"' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_datetime(self.startTime, input_name='startTime'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReferencePeriodType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ReferencePeriodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.endTime is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            showIndent(outfile, level)
            outfile.write('endTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.endTime, input_name='endTime'))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('endTime', node)
        if value is not None and 'endTime' not in already_processed:
            already_processed.add('endTime')
            try:
                self.endTime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (endTime): %s' % exp)
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (startTime): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ReferencePeriodType


class TextType(GeneratedsSuper):
    """TextType provides for a set of language-specific alternates to be
    provided for any human-readable construct in the instance."""
    subclass = None
    superclass = None
    def __init__(self, lang='en', valueOf_=None):
        self.original_tagname_ = None
        self.lang = _cast(None, lang)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if TextType.subclass:
            return TextType.subclass(*args_, **kwargs_)
        else:
            return TextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lang(self): return self.lang
    def set_lang(self, lang): self.lang = lang
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TextType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TextType'):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            outfile.write(' lang=%s' % (self.gds_format_string(quote_attrib(self.lang).encode(ExternalEncoding), input_name='lang'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='TextType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='TextType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lang is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            showIndent(outfile, level)
            outfile.write('lang="%s",\n' % (self.lang,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lang', node)
        if value is not None and 'lang' not in already_processed:
            already_processed.add('lang')
            self.lang = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class TextType


class AnnotationType(GeneratedsSuper):
    """AnnotationType provides for non-documentation notes and annotations
    to be embedded in data and structure messages. It provides
    optional fields for providing a title, a type description, a
    URI, and the text of the annotation."""
    subclass = None
    superclass = None
    def __init__(self, AnnotationTitle=None, AnnotationType=None, AnnotationURL=None, AnnotationText=None):
        self.original_tagname_ = None
        self.AnnotationTitle = AnnotationTitle
        self.AnnotationType = AnnotationType
        self.AnnotationURL = AnnotationURL
        if AnnotationText is None:
            self.AnnotationText = []
        else:
            self.AnnotationText = AnnotationText
    def factory(*args_, **kwargs_):
        if AnnotationType.subclass:
            return AnnotationType.subclass(*args_, **kwargs_)
        else:
            return AnnotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AnnotationTitle(self): return self.AnnotationTitle
    def set_AnnotationTitle(self, AnnotationTitle): self.AnnotationTitle = AnnotationTitle
    def get_AnnotationType(self): return self.AnnotationType
    def set_AnnotationType(self, AnnotationType): self.AnnotationType = AnnotationType
    def get_AnnotationURL(self): return self.AnnotationURL
    def set_AnnotationURL(self, AnnotationURL): self.AnnotationURL = AnnotationURL
    def get_AnnotationText(self): return self.AnnotationText
    def set_AnnotationText(self, AnnotationText): self.AnnotationText = AnnotationText
    def add_AnnotationText(self, value): self.AnnotationText.append(value)
    def insert_AnnotationText_at(self, index, value): self.AnnotationText.insert(index, value)
    def replace_AnnotationText_at(self, index, value): self.AnnotationText[index] = value
    def hasContent_(self):
        if (
            self.AnnotationTitle is not None or
            self.AnnotationType is not None or
            self.AnnotationURL is not None or
            self.AnnotationText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AnnotationType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AnnotationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AnnotationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AnnotationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AnnotationTitle is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnotationTitle>%s</%sAnnotationTitle>%s' % (namespace_, self.gds_format_string(quote_xml(self.AnnotationTitle).encode(ExternalEncoding), input_name='AnnotationTitle'), namespace_, eol_))
        if self.AnnotationType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnotationType>%s</%sAnnotationType>%s' % (namespace_, self.gds_format_string(quote_xml(self.AnnotationType).encode(ExternalEncoding), input_name='AnnotationType'), namespace_, eol_))
        if self.AnnotationURL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAnnotationURL>%s</%sAnnotationURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.AnnotationURL).encode(ExternalEncoding), input_name='AnnotationURL'), namespace_, eol_))
        for AnnotationText_ in self.AnnotationText:
            AnnotationText_.export(outfile, level, namespace_, name_='AnnotationText', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AnnotationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AnnotationTitle is not None:
            showIndent(outfile, level)
            outfile.write('AnnotationTitle=%s,\n' % quote_python(self.AnnotationTitle).encode(ExternalEncoding))
        if self.AnnotationType is not None:
            showIndent(outfile, level)
            outfile.write('AnnotationType=%s,\n' % quote_python(self.AnnotationType).encode(ExternalEncoding))
        if self.AnnotationURL is not None:
            showIndent(outfile, level)
            outfile.write('AnnotationURL=%s,\n' % quote_python(self.AnnotationURL).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AnnotationText=[\n')
        level += 1
        for AnnotationText_ in self.AnnotationText:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            AnnotationText_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AnnotationTitle':
            AnnotationTitle_ = child_.text
            AnnotationTitle_ = self.gds_validate_string(AnnotationTitle_, node, 'AnnotationTitle')
            self.AnnotationTitle = AnnotationTitle_
        elif nodeName_ == 'AnnotationType':
            AnnotationType_ = child_.text
            AnnotationType_ = self.gds_validate_string(AnnotationType_, node, 'AnnotationType')
            self.AnnotationType = AnnotationType_
        elif nodeName_ == 'AnnotationURL':
            AnnotationURL_ = child_.text
            AnnotationURL_ = self.gds_validate_string(AnnotationURL_, node, 'AnnotationURL')
            self.AnnotationURL = AnnotationURL_
        elif nodeName_ == 'AnnotationText':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.AnnotationText.append(obj_)
            obj_.original_tagname_ = 'AnnotationText'
# end class AnnotationType


class AnnotationsType(GeneratedsSuper):
    """AnnotationsType provides for a list of annotations to be attached to
    data and structure messages."""
    subclass = None
    superclass = None
    def __init__(self, Annotation=None):
        self.original_tagname_ = None
        if Annotation is None:
            self.Annotation = []
        else:
            self.Annotation = Annotation
    def factory(*args_, **kwargs_):
        if AnnotationsType.subclass:
            return AnnotationsType.subclass(*args_, **kwargs_)
        else:
            return AnnotationsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Annotation(self): return self.Annotation
    def set_Annotation(self, Annotation): self.Annotation = Annotation
    def add_Annotation(self, value): self.Annotation.append(value)
    def insert_Annotation_at(self, index, value): self.Annotation.insert(index, value)
    def replace_Annotation_at(self, index, value): self.Annotation[index] = value
    def hasContent_(self):
        if (
            self.Annotation
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AnnotationsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AnnotationsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AnnotationsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AnnotationsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AnnotationsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Annotation_ in self.Annotation:
            Annotation_.export(outfile, level, namespace_, name_='Annotation', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AnnotationsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Annotation=[\n')
        level += 1
        for Annotation_ in self.Annotation:
            showIndent(outfile, level)
            outfile.write('model_.AnnotationType(\n')
            Annotation_.exportLiteral(outfile, level, name_='AnnotationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Annotation':
            obj_ = AnnotationType.factory()
            obj_.build(child_)
            self.Annotation.append(obj_)
            obj_.original_tagname_ = 'Annotation'
# end class AnnotationsType


class DataSetType(GeneratedsSuper):
    """DataSetType defines the structure of a data set. This consists of a
    key family reference which contains the ID of the key family,
    and the attribute values attached at the data set level. A
    DataSet may be used to transmit documentation (that is, only
    attribute values), data, or a combination of both. If providing
    only documentation, you need not send the complete set of
    attributes. If transmitting only data, the Group may be omitted
    if desired. Uniqueness constraints are defined for the
    attributes of the data set. If dataset-level attributes are sent
    in a delete message, then any valid attribute value will
    indicate that the current attribute value should be deleted. The
    keyFamilyURI attribute is provided to allow a URI (typically a
    URL) to be provided, pointing to an SDMX-ML Structure message
    describing the key family. Attributes are provided for
    describing the contents of a data or metadata set, which are
    particularly important for interactions with the SDMX Registry:
    datasetID, dataProviderSchemeAgencyID, dataProviderSchemeID,
    dataflowAgencyID, and dataflowID all take the IDs specified by
    the attribute names. The action attribute indicates whether the
    file is appending, replacing, or deleting. Attributes
    reportingBeginDate, reportingEndDate, validFromDate, and
    validToDate are inclusive. publicationYear holds the ISO 8601
    four-digit year, and publicationPeriod specifies the period of
    publication of the data in terms of whatever provisioning
    agreements might be in force (ie, "Q1 2005" if that is the time
    of publication for a data set published on a quarterly basis)."""
    subclass = None
    superclass = None
    def __init__(self, dataProviderSchemeId=None, publicationYear=None, reportingBeginDate=None, publicationPeriod=None, keyFamilyURI=None, validToDate=None, dataProviderID=None, datasetID=None, action=None, dataProviderSchemeAgencyId=None, validFromDate=None, reportingEndDate=None, dataflowAgencyID=None, dataflowID=None, KeyFamilyRef=None, Attributes=None, Group=None, Series=None, Annotations=None):
        self.original_tagname_ = None
        self.dataProviderSchemeId = _cast(None, dataProviderSchemeId)
        self.publicationYear = _cast(None, publicationYear)
        self.reportingBeginDate = _cast(None, reportingBeginDate)
        self.publicationPeriod = _cast(None, publicationPeriod)
        self.keyFamilyURI = _cast(None, keyFamilyURI)
        self.validToDate = _cast(None, validToDate)
        self.dataProviderID = _cast(None, dataProviderID)
        self.datasetID = _cast(None, datasetID)
        self.action = _cast(None, action)
        self.dataProviderSchemeAgencyId = _cast(None, dataProviderSchemeAgencyId)
        self.validFromDate = _cast(None, validFromDate)
        self.reportingEndDate = _cast(None, reportingEndDate)
        self.dataflowAgencyID = _cast(None, dataflowAgencyID)
        self.dataflowID = _cast(None, dataflowID)
        self.KeyFamilyRef = KeyFamilyRef
        self.Attributes = Attributes
        if Group is None:
            self.Group = []
        else:
            self.Group = Group
        if Series is None:
            self.Series = []
        else:
            self.Series = Series
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if DataSetType.subclass:
            return DataSetType.subclass(*args_, **kwargs_)
        else:
            return DataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def get_Attributes(self): return self.Attributes
    def set_Attributes(self, Attributes): self.Attributes = Attributes
    def get_Group(self): return self.Group
    def set_Group(self, Group): self.Group = Group
    def add_Group(self, value): self.Group.append(value)
    def insert_Group_at(self, index, value): self.Group.insert(index, value)
    def replace_Group_at(self, index, value): self.Group[index] = value
    def get_Series(self): return self.Series
    def set_Series(self, Series): self.Series = Series
    def add_Series(self, value): self.Series.append(value)
    def insert_Series_at(self, index, value): self.Series.insert(index, value)
    def replace_Series_at(self, index, value): self.Series[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_dataProviderSchemeId(self): return self.dataProviderSchemeId
    def set_dataProviderSchemeId(self, dataProviderSchemeId): self.dataProviderSchemeId = dataProviderSchemeId
    def get_publicationYear(self): return self.publicationYear
    def set_publicationYear(self, publicationYear): self.publicationYear = publicationYear
    def get_reportingBeginDate(self): return self.reportingBeginDate
    def set_reportingBeginDate(self, reportingBeginDate): self.reportingBeginDate = reportingBeginDate
    def get_publicationPeriod(self): return self.publicationPeriod
    def set_publicationPeriod(self, publicationPeriod): self.publicationPeriod = publicationPeriod
    def get_keyFamilyURI(self): return self.keyFamilyURI
    def set_keyFamilyURI(self, keyFamilyURI): self.keyFamilyURI = keyFamilyURI
    def get_validToDate(self): return self.validToDate
    def set_validToDate(self, validToDate): self.validToDate = validToDate
    def get_dataProviderID(self): return self.dataProviderID
    def set_dataProviderID(self, dataProviderID): self.dataProviderID = dataProviderID
    def get_datasetID(self): return self.datasetID
    def set_datasetID(self, datasetID): self.datasetID = datasetID
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_dataProviderSchemeAgencyId(self): return self.dataProviderSchemeAgencyId
    def set_dataProviderSchemeAgencyId(self, dataProviderSchemeAgencyId): self.dataProviderSchemeAgencyId = dataProviderSchemeAgencyId
    def get_validFromDate(self): return self.validFromDate
    def set_validFromDate(self, validFromDate): self.validFromDate = validFromDate
    def get_reportingEndDate(self): return self.reportingEndDate
    def set_reportingEndDate(self, reportingEndDate): self.reportingEndDate = reportingEndDate
    def get_dataflowAgencyID(self): return self.dataflowAgencyID
    def set_dataflowAgencyID(self, dataflowAgencyID): self.dataflowAgencyID = dataflowAgencyID
    def get_dataflowID(self): return self.dataflowID
    def set_dataflowID(self, dataflowID): self.dataflowID = dataflowID
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.KeyFamilyRef is not None or
            self.Attributes is not None or
            self.Group or
            self.Series or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataSetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataSetType'):
        if self.dataProviderSchemeId is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            outfile.write(' dataProviderSchemeId=%s' % (quote_attrib(self.dataProviderSchemeId), ))
        if self.publicationYear is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            outfile.write(' publicationYear=%s' % (self.gds_format_string(quote_attrib(self.publicationYear).encode(ExternalEncoding), input_name='publicationYear'), ))
        if self.reportingBeginDate is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            outfile.write(' reportingBeginDate=%s' % (quote_attrib(self.reportingBeginDate), ))
        if self.publicationPeriod is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            outfile.write(' publicationPeriod=%s' % (quote_attrib(self.publicationPeriod), ))
        if self.keyFamilyURI is not None and 'keyFamilyURI' not in already_processed:
            already_processed.add('keyFamilyURI')
            outfile.write(' keyFamilyURI=%s' % (self.gds_format_string(quote_attrib(self.keyFamilyURI).encode(ExternalEncoding), input_name='keyFamilyURI'), ))
        if self.validToDate is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            outfile.write(' validToDate=%s' % (quote_attrib(self.validToDate), ))
        if self.dataProviderID is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            outfile.write(' dataProviderID=%s' % (quote_attrib(self.dataProviderID), ))
        if self.datasetID is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            outfile.write(' datasetID=%s' % (quote_attrib(self.datasetID), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.dataProviderSchemeAgencyId is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            outfile.write(' dataProviderSchemeAgencyId=%s' % (quote_attrib(self.dataProviderSchemeAgencyId), ))
        if self.validFromDate is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            outfile.write(' validFromDate=%s' % (quote_attrib(self.validFromDate), ))
        if self.reportingEndDate is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            outfile.write(' reportingEndDate=%s' % (quote_attrib(self.reportingEndDate), ))
        if self.dataflowAgencyID is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            outfile.write(' dataflowAgencyID=%s' % (quote_attrib(self.dataflowAgencyID), ))
        if self.dataflowID is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            outfile.write(' dataflowID=%s' % (quote_attrib(self.dataflowID), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyRef>%s</%sKeyFamilyRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamilyRef).encode(ExternalEncoding), input_name='KeyFamilyRef'), namespace_, eol_))
        if self.Attributes is not None:
            self.Attributes.export(outfile, level, namespace_, name_='Attributes', pretty_print=pretty_print)
        for Group_ in self.Group:
            Group_.export(outfile, level, namespace_, name_='Group', pretty_print=pretty_print)
        for Series_ in self.Series:
            Series_.export(outfile, level, namespace_, name_='Series', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataProviderSchemeId is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            showIndent(outfile, level)
            outfile.write('dataProviderSchemeId=%s,\n' % (self.dataProviderSchemeId,))
        if self.publicationYear is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            showIndent(outfile, level)
            outfile.write('publicationYear=%s,\n' % (self.publicationYear,))
        if self.reportingBeginDate is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            showIndent(outfile, level)
            outfile.write('reportingBeginDate=%s,\n' % (self.reportingBeginDate,))
        if self.publicationPeriod is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            showIndent(outfile, level)
            outfile.write('publicationPeriod=%s,\n' % (self.publicationPeriod,))
        if self.keyFamilyURI is not None and 'keyFamilyURI' not in already_processed:
            already_processed.add('keyFamilyURI')
            showIndent(outfile, level)
            outfile.write('keyFamilyURI="%s",\n' % (self.keyFamilyURI,))
        if self.validToDate is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            showIndent(outfile, level)
            outfile.write('validToDate=%s,\n' % (self.validToDate,))
        if self.dataProviderID is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            showIndent(outfile, level)
            outfile.write('dataProviderID=%s,\n' % (self.dataProviderID,))
        if self.datasetID is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            showIndent(outfile, level)
            outfile.write('datasetID=%s,\n' % (self.datasetID,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % (self.action,))
        if self.dataProviderSchemeAgencyId is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            showIndent(outfile, level)
            outfile.write('dataProviderSchemeAgencyId=%s,\n' % (self.dataProviderSchemeAgencyId,))
        if self.validFromDate is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            showIndent(outfile, level)
            outfile.write('validFromDate=%s,\n' % (self.validFromDate,))
        if self.reportingEndDate is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            showIndent(outfile, level)
            outfile.write('reportingEndDate=%s,\n' % (self.reportingEndDate,))
        if self.dataflowAgencyID is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            showIndent(outfile, level)
            outfile.write('dataflowAgencyID=%s,\n' % (self.dataflowAgencyID,))
        if self.dataflowID is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            showIndent(outfile, level)
            outfile.write('dataflowID=%s,\n' % (self.dataflowID,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyRef=%s,\n' % quote_python(self.KeyFamilyRef).encode(ExternalEncoding))
        if self.Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Attributes=model_.ValuesType(\n')
            self.Attributes.exportLiteral(outfile, level, name_='Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Group=[\n')
        level += 1
        for Group_ in self.Group:
            showIndent(outfile, level)
            outfile.write('model_.GroupType(\n')
            Group_.exportLiteral(outfile, level, name_='GroupType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Series=[\n')
        level += 1
        for Series_ in self.Series:
            showIndent(outfile, level)
            outfile.write('model_.SeriesType(\n')
            Series_.exportLiteral(outfile, level, name_='SeriesType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataProviderSchemeId', node)
        if value is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            self.dataProviderSchemeId = value
        value = find_attr_value_('publicationYear', node)
        if value is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            self.publicationYear = value
        value = find_attr_value_('reportingBeginDate', node)
        if value is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            self.reportingBeginDate = value
        value = find_attr_value_('publicationPeriod', node)
        if value is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            self.publicationPeriod = value
        value = find_attr_value_('keyFamilyURI', node)
        if value is not None and 'keyFamilyURI' not in already_processed:
            already_processed.add('keyFamilyURI')
            self.keyFamilyURI = value
        value = find_attr_value_('validToDate', node)
        if value is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            self.validToDate = value
        value = find_attr_value_('dataProviderID', node)
        if value is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            self.dataProviderID = value
        value = find_attr_value_('datasetID', node)
        if value is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            self.datasetID = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('dataProviderSchemeAgencyId', node)
        if value is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            self.dataProviderSchemeAgencyId = value
        value = find_attr_value_('validFromDate', node)
        if value is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            self.validFromDate = value
        value = find_attr_value_('reportingEndDate', node)
        if value is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            self.reportingEndDate = value
        value = find_attr_value_('dataflowAgencyID', node)
        if value is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            self.dataflowAgencyID = value
        value = find_attr_value_('dataflowID', node)
        if value is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            self.dataflowID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamilyRef':
            KeyFamilyRef_ = child_.text
            KeyFamilyRef_ = self.gds_validate_string(KeyFamilyRef_, node, 'KeyFamilyRef')
            self.KeyFamilyRef = KeyFamilyRef_
            self.validate_IDType(self.KeyFamilyRef)    # validate type IDType
        elif nodeName_ == 'Attributes':
            obj_ = ValuesType.factory()
            obj_.build(child_)
            self.Attributes = obj_
            obj_.original_tagname_ = 'Attributes'
        elif nodeName_ == 'Group':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Group> element')
            self.Group.append(obj_)
            obj_.original_tagname_ = 'Group'
        elif nodeName_ == 'Series':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Series> element')
            self.Series.append(obj_)
            obj_.original_tagname_ = 'Series'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class DataSetType


class SeriesType(GeneratedsSuper):
    """SeriesType specifies the structure of a series. This includes all of
    the key values, values for all the attributes, and the set of
    observations making up the series content. Messages may transmit
    only attributes, only data, or both. Regardless, the series key
    is always required. Key values appear at the Series level in an
    ordered sequence which corresponds to the key sequence in the
    key family. A series in a delete message need not supply more
    than the key, indicating that the entire series identified by
    that key should be deleted. If series attributes are sent in a
    delete message, any valid value specified for an attribute
    indicates that the attribute should be deleted."""
    subclass = None
    superclass = None
    def __init__(self, SeriesKey=None, Attributes=None, Obs=None, Annotations=None):
        self.original_tagname_ = None
        self.SeriesKey = SeriesKey
        self.Attributes = Attributes
        if Obs is None:
            self.Obs = []
        else:
            self.Obs = Obs
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if SeriesType.subclass:
            return SeriesType.subclass(*args_, **kwargs_)
        else:
            return SeriesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SeriesKey(self): return self.SeriesKey
    def set_SeriesKey(self, SeriesKey): self.SeriesKey = SeriesKey
    def get_Attributes(self): return self.Attributes
    def set_Attributes(self, Attributes): self.Attributes = Attributes
    def get_Obs(self): return self.Obs
    def set_Obs(self, Obs): self.Obs = Obs
    def add_Obs(self, value): self.Obs.append(value)
    def insert_Obs_at(self, index, value): self.Obs.insert(index, value)
    def replace_Obs_at(self, index, value): self.Obs[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def hasContent_(self):
        if (
            self.SeriesKey is not None or
            self.Attributes is not None or
            self.Obs or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SeriesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeriesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SeriesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SeriesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SeriesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SeriesKey is not None:
            self.SeriesKey.export(outfile, level, namespace_, name_='SeriesKey', pretty_print=pretty_print)
        if self.Attributes is not None:
            self.Attributes.export(outfile, level, namespace_, name_='Attributes', pretty_print=pretty_print)
        for Obs_ in self.Obs:
            Obs_.export(outfile, level, namespace_, name_='Obs', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SeriesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SeriesKey is not None:
            showIndent(outfile, level)
            outfile.write('SeriesKey=model_.SeriesKeyType(\n')
            self.SeriesKey.exportLiteral(outfile, level, name_='SeriesKey')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Attributes=model_.ValuesType(\n')
            self.Attributes.exportLiteral(outfile, level, name_='Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('Obs=[\n')
        level += 1
        for Obs_ in self.Obs:
            showIndent(outfile, level)
            outfile.write('model_.ObsType(\n')
            Obs_.exportLiteral(outfile, level, name_='ObsType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SeriesKey':
            obj_ = SeriesKeyType.factory()
            obj_.build(child_)
            self.SeriesKey = obj_
            obj_.original_tagname_ = 'SeriesKey'
        elif nodeName_ == 'Attributes':
            obj_ = ValuesType.factory()
            obj_.build(child_)
            self.Attributes = obj_
            obj_.original_tagname_ = 'Attributes'
        elif nodeName_ == 'Obs':
            type_name_ = child_.attrib.get(
                '{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <Obs> element')
            self.Obs.append(obj_)
            obj_.original_tagname_ = 'Obs'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class SeriesType


class SeriesKeyType(GeneratedsSuper):
    """SeriesKeyType defines the contents of a series key. Each non-time
    dimension must have a value supplied for it, in the order in
    which the dimensions are specified in the key family."""
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        self.original_tagname_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if SeriesKeyType.subclass:
            return SeriesKeyType.subclass(*args_, **kwargs_)
        else:
            return SeriesKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def hasContent_(self):
        if (
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SeriesKeyType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SeriesKeyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SeriesKeyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SeriesKeyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SeriesKeyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SeriesKeyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.ValueType(\n')
            Value_.exportLiteral(outfile, level, name_='ValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = ValueType.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class SeriesKeyType


class ObsType(GeneratedsSuper):
    """ObsType defines the structure of an observation. This includes a
    time and observation value, as well as values for each of the
    attributes assigned at the observation level by the key family.
    In a delete message, only the time need be given, indicating
    that the observation identified by the key and time should be
    deleted. For an update message, both time and observation value
    are required. If any attributes appear in a delete message, any
    valid value supplied for an attribute indicates that the current
    value should be deleted."""
    subclass = None
    superclass = None
    def __init__(self, Time=None, ObsValue=None, Attributes=None, Annotations=None):
        self.original_tagname_ = None
        self.Time = Time
        self.ObsValue = ObsValue
        self.Attributes = Attributes
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ObsType.subclass:
            return ObsType.subclass(*args_, **kwargs_)
        else:
            return ObsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_ObsValue(self): return self.ObsValue
    def set_ObsValue(self, ObsValue): self.ObsValue = ObsValue
    def get_Attributes(self): return self.Attributes
    def set_Attributes(self, Attributes): self.Attributes = Attributes
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def validate_TimePeriodType(self, value):
        # Validate type TimePeriodType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.Time is not None or
            self.ObsValue is not None or
            self.Attributes is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ObsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ObsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ObsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ObsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.Time).encode(ExternalEncoding), input_name='Time'), namespace_, eol_))
        if self.ObsValue is not None:
            self.ObsValue.export(outfile, level, namespace_, name_='ObsValue', pretty_print=pretty_print)
        if self.Attributes is not None:
            self.Attributes.export(outfile, level, namespace_, name_='Attributes', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=%s,\n' % quote_python(self.Time).encode(ExternalEncoding))
        if self.ObsValue is not None:
            showIndent(outfile, level)
            outfile.write('ObsValue=model_.ObsValueType(\n')
            self.ObsValue.exportLiteral(outfile, level, name_='ObsValue')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attributes is not None:
            showIndent(outfile, level)
            outfile.write('Attributes=model_.ValuesType(\n')
            self.Attributes.exportLiteral(outfile, level, name_='Attributes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
            self.validate_TimePeriodType(self.Time)    # validate type TimePeriodType
        elif nodeName_ == 'ObsValue':
            obj_ = ObsValueType.factory()
            obj_.build(child_)
            self.ObsValue = obj_
            obj_.original_tagname_ = 'ObsValue'
        elif nodeName_ == 'Attributes':
            obj_ = ValuesType.factory()
            obj_.build(child_)
            self.Attributes = obj_
            obj_.original_tagname_ = 'Attributes'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ObsType


class ValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Value=None):
        self.original_tagname_ = None
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
    def factory(*args_, **kwargs_):
        if ValuesType.subclass:
            return ValuesType.subclass(*args_, **kwargs_)
        else:
            return ValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def hasContent_(self):
        if (
            self.Value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ValuesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ValuesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.ValueType(\n')
            Value_.exportLiteral(outfile, level, name_='ValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = ValueType.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
# end class ValuesType


class ValueType(GeneratedsSuper):
    """ValueType is used to assign a single value to a concept, as for
    attribute values and key values. It has no element content. The
    startTime attribute is only used if the textFormat of the
    attribute is of the Timespan type in the key family (in which
    case the value field takes a duration)."""
    subclass = None
    superclass = None
    def __init__(self, concept=None, startTime=None, value=None):
        self.original_tagname_ = None
        self.concept = _cast(None, concept)
        if isinstance(startTime, basestring):
            initvalue_ = datetime_.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startTime
        self.startTime = initvalue_
        self.value = _cast(None, value)
    def factory(*args_, **kwargs_):
        if ValueType.subclass:
            return ValueType.subclass(*args_, **kwargs_)
        else:
            return ValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_concept(self): return self.concept
    def set_concept(self, concept): self.concept = concept
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ValueType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ValueType'):
        if self.concept is not None and 'concept' not in already_processed:
            already_processed.add('concept')
            outfile.write(' concept=%s' % (quote_attrib(self.concept), ))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.concept is not None and 'concept' not in already_processed:
            already_processed.add('concept')
            showIndent(outfile, level)
            outfile.write('concept=%s,\n' % (self.concept,))
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value="%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('concept', node)
        if value is not None and 'concept' not in already_processed:
            already_processed.add('concept')
            self.concept = value
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (startTime): %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ValueType


class ObsValueType(GeneratedsSuper):
    """ObsValueType describes the information set for an observation value.
    This is associated with the primary measure concept declared in
    the key family. The startTime attribute is only used if the
    textFormat of the observation is of the Timespan type in the key
    family (in which case the value field takes a duration)."""
    subclass = None
    superclass = None
    def __init__(self, startTime=None, value=None):
        self.original_tagname_ = None
        if isinstance(startTime, basestring):
            initvalue_ = datetime_.datetime.strptime(startTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = startTime
        self.startTime = initvalue_
        self.value = _cast(float, value)
    def factory(*args_, **kwargs_):
        if ObsValueType.subclass:
            return ObsValueType.subclass(*args_, **kwargs_)
        else:
            return ObsValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_startTime(self): return self.startTime
    def set_startTime(self, startTime): self.startTime = startTime
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ObsValueType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObsValueType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ObsValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ObsValueType'):
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            outfile.write(' startTime="%s"' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            outfile.write(' value="%s"' % self.gds_format_string(self.value, input_name='value'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ObsValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ObsValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.startTime is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            showIndent(outfile, level)
            outfile.write('startTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.startTime, input_name='startTime'))
        if self.value is not None and 'value' not in already_processed:
            already_processed.add('value')
            showIndent(outfile, level)
            outfile.write('value=%e,\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('startTime', node)
        if value is not None and 'startTime' not in already_processed:
            already_processed.add('startTime')
            try:
                self.startTime = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (startTime): %s' % exp)
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.add('value')
            try:
                self.value = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (value): %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ObsValueType


class SectionType(GeneratedsSuper):
    """SectionType acts as a structural base, which is extended through the
    addition of attributes to reflect the particular needs of a
    specific key family using the xs:extends element."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if SectionType.subclass:
            return SectionType.subclass(*args_, **kwargs_)
        else:
            return SectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SectionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SectionType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SectionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SectionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SectionType


class QueryType(GeneratedsSuper):
    """The Query element is a top-level element for this namespace, which
    is referenced by the SDMX message envelope, or could be put
    inside another envelope, such as SOAP. It contains a query. The
    defaultLimit attribute is the suggested maximum response size in
    kilobytes."""
    subclass = None
    superclass = None
    def __init__(self, defaultLimit=None, DataWhere=None, MetadataWhere=None, KeyFamilyWhere=None, MetadataStructureWhere=None, CodelistWhere=None, ConceptWhere=None, AgencyWhere=None, DataProviderWhere=None, HierarchicalCodelistWhere=None, ReportingTaxonomyWhere=None, DataflowWhere=None, MetadataflowWhere=None, StructureSetWhere=None, ProcessWhere=None, OrganisationSchemeWhere=None, ConceptSchemeWhere=None, CategorySchemeWhere=None):
        self.original_tagname_ = None
        self.defaultLimit = _cast(int, defaultLimit)
        if DataWhere is None:
            self.DataWhere = []
        else:
            self.DataWhere = DataWhere
        if MetadataWhere is None:
            self.MetadataWhere = []
        else:
            self.MetadataWhere = MetadataWhere
        if KeyFamilyWhere is None:
            self.KeyFamilyWhere = []
        else:
            self.KeyFamilyWhere = KeyFamilyWhere
        if MetadataStructureWhere is None:
            self.MetadataStructureWhere = []
        else:
            self.MetadataStructureWhere = MetadataStructureWhere
        if CodelistWhere is None:
            self.CodelistWhere = []
        else:
            self.CodelistWhere = CodelistWhere
        if ConceptWhere is None:
            self.ConceptWhere = []
        else:
            self.ConceptWhere = ConceptWhere
        if AgencyWhere is None:
            self.AgencyWhere = []
        else:
            self.AgencyWhere = AgencyWhere
        if DataProviderWhere is None:
            self.DataProviderWhere = []
        else:
            self.DataProviderWhere = DataProviderWhere
        if HierarchicalCodelistWhere is None:
            self.HierarchicalCodelistWhere = []
        else:
            self.HierarchicalCodelistWhere = HierarchicalCodelistWhere
        if ReportingTaxonomyWhere is None:
            self.ReportingTaxonomyWhere = []
        else:
            self.ReportingTaxonomyWhere = ReportingTaxonomyWhere
        if DataflowWhere is None:
            self.DataflowWhere = []
        else:
            self.DataflowWhere = DataflowWhere
        if MetadataflowWhere is None:
            self.MetadataflowWhere = []
        else:
            self.MetadataflowWhere = MetadataflowWhere
        if StructureSetWhere is None:
            self.StructureSetWhere = []
        else:
            self.StructureSetWhere = StructureSetWhere
        if ProcessWhere is None:
            self.ProcessWhere = []
        else:
            self.ProcessWhere = ProcessWhere
        if OrganisationSchemeWhere is None:
            self.OrganisationSchemeWhere = []
        else:
            self.OrganisationSchemeWhere = OrganisationSchemeWhere
        if ConceptSchemeWhere is None:
            self.ConceptSchemeWhere = []
        else:
            self.ConceptSchemeWhere = ConceptSchemeWhere
        if CategorySchemeWhere is None:
            self.CategorySchemeWhere = []
        else:
            self.CategorySchemeWhere = CategorySchemeWhere
    def factory(*args_, **kwargs_):
        if QueryType.subclass:
            return QueryType.subclass(*args_, **kwargs_)
        else:
            return QueryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataWhere(self): return self.DataWhere
    def set_DataWhere(self, DataWhere): self.DataWhere = DataWhere
    def add_DataWhere(self, value): self.DataWhere.append(value)
    def insert_DataWhere_at(self, index, value): self.DataWhere.insert(index, value)
    def replace_DataWhere_at(self, index, value): self.DataWhere[index] = value
    def get_MetadataWhere(self): return self.MetadataWhere
    def set_MetadataWhere(self, MetadataWhere): self.MetadataWhere = MetadataWhere
    def add_MetadataWhere(self, value): self.MetadataWhere.append(value)
    def insert_MetadataWhere_at(self, index, value): self.MetadataWhere.insert(index, value)
    def replace_MetadataWhere_at(self, index, value): self.MetadataWhere[index] = value
    def get_KeyFamilyWhere(self): return self.KeyFamilyWhere
    def set_KeyFamilyWhere(self, KeyFamilyWhere): self.KeyFamilyWhere = KeyFamilyWhere
    def add_KeyFamilyWhere(self, value): self.KeyFamilyWhere.append(value)
    def insert_KeyFamilyWhere_at(self, index, value): self.KeyFamilyWhere.insert(index, value)
    def replace_KeyFamilyWhere_at(self, index, value): self.KeyFamilyWhere[index] = value
    def get_MetadataStructureWhere(self): return self.MetadataStructureWhere
    def set_MetadataStructureWhere(self, MetadataStructureWhere): self.MetadataStructureWhere = MetadataStructureWhere
    def add_MetadataStructureWhere(self, value): self.MetadataStructureWhere.append(value)
    def insert_MetadataStructureWhere_at(self, index, value): self.MetadataStructureWhere.insert(index, value)
    def replace_MetadataStructureWhere_at(self, index, value): self.MetadataStructureWhere[index] = value
    def get_CodelistWhere(self): return self.CodelistWhere
    def set_CodelistWhere(self, CodelistWhere): self.CodelistWhere = CodelistWhere
    def add_CodelistWhere(self, value): self.CodelistWhere.append(value)
    def insert_CodelistWhere_at(self, index, value): self.CodelistWhere.insert(index, value)
    def replace_CodelistWhere_at(self, index, value): self.CodelistWhere[index] = value
    def get_ConceptWhere(self): return self.ConceptWhere
    def set_ConceptWhere(self, ConceptWhere): self.ConceptWhere = ConceptWhere
    def add_ConceptWhere(self, value): self.ConceptWhere.append(value)
    def insert_ConceptWhere_at(self, index, value): self.ConceptWhere.insert(index, value)
    def replace_ConceptWhere_at(self, index, value): self.ConceptWhere[index] = value
    def get_AgencyWhere(self): return self.AgencyWhere
    def set_AgencyWhere(self, AgencyWhere): self.AgencyWhere = AgencyWhere
    def add_AgencyWhere(self, value): self.AgencyWhere.append(value)
    def insert_AgencyWhere_at(self, index, value): self.AgencyWhere.insert(index, value)
    def replace_AgencyWhere_at(self, index, value): self.AgencyWhere[index] = value
    def get_DataProviderWhere(self): return self.DataProviderWhere
    def set_DataProviderWhere(self, DataProviderWhere): self.DataProviderWhere = DataProviderWhere
    def add_DataProviderWhere(self, value): self.DataProviderWhere.append(value)
    def insert_DataProviderWhere_at(self, index, value): self.DataProviderWhere.insert(index, value)
    def replace_DataProviderWhere_at(self, index, value): self.DataProviderWhere[index] = value
    def get_HierarchicalCodelistWhere(self): return self.HierarchicalCodelistWhere
    def set_HierarchicalCodelistWhere(self, HierarchicalCodelistWhere): self.HierarchicalCodelistWhere = HierarchicalCodelistWhere
    def add_HierarchicalCodelistWhere(self, value): self.HierarchicalCodelistWhere.append(value)
    def insert_HierarchicalCodelistWhere_at(self, index, value): self.HierarchicalCodelistWhere.insert(index, value)
    def replace_HierarchicalCodelistWhere_at(self, index, value): self.HierarchicalCodelistWhere[index] = value
    def get_ReportingTaxonomyWhere(self): return self.ReportingTaxonomyWhere
    def set_ReportingTaxonomyWhere(self, ReportingTaxonomyWhere): self.ReportingTaxonomyWhere = ReportingTaxonomyWhere
    def add_ReportingTaxonomyWhere(self, value): self.ReportingTaxonomyWhere.append(value)
    def insert_ReportingTaxonomyWhere_at(self, index, value): self.ReportingTaxonomyWhere.insert(index, value)
    def replace_ReportingTaxonomyWhere_at(self, index, value): self.ReportingTaxonomyWhere[index] = value
    def get_DataflowWhere(self): return self.DataflowWhere
    def set_DataflowWhere(self, DataflowWhere): self.DataflowWhere = DataflowWhere
    def add_DataflowWhere(self, value): self.DataflowWhere.append(value)
    def insert_DataflowWhere_at(self, index, value): self.DataflowWhere.insert(index, value)
    def replace_DataflowWhere_at(self, index, value): self.DataflowWhere[index] = value
    def get_MetadataflowWhere(self): return self.MetadataflowWhere
    def set_MetadataflowWhere(self, MetadataflowWhere): self.MetadataflowWhere = MetadataflowWhere
    def add_MetadataflowWhere(self, value): self.MetadataflowWhere.append(value)
    def insert_MetadataflowWhere_at(self, index, value): self.MetadataflowWhere.insert(index, value)
    def replace_MetadataflowWhere_at(self, index, value): self.MetadataflowWhere[index] = value
    def get_StructureSetWhere(self): return self.StructureSetWhere
    def set_StructureSetWhere(self, StructureSetWhere): self.StructureSetWhere = StructureSetWhere
    def add_StructureSetWhere(self, value): self.StructureSetWhere.append(value)
    def insert_StructureSetWhere_at(self, index, value): self.StructureSetWhere.insert(index, value)
    def replace_StructureSetWhere_at(self, index, value): self.StructureSetWhere[index] = value
    def get_ProcessWhere(self): return self.ProcessWhere
    def set_ProcessWhere(self, ProcessWhere): self.ProcessWhere = ProcessWhere
    def add_ProcessWhere(self, value): self.ProcessWhere.append(value)
    def insert_ProcessWhere_at(self, index, value): self.ProcessWhere.insert(index, value)
    def replace_ProcessWhere_at(self, index, value): self.ProcessWhere[index] = value
    def get_OrganisationSchemeWhere(self): return self.OrganisationSchemeWhere
    def set_OrganisationSchemeWhere(self, OrganisationSchemeWhere): self.OrganisationSchemeWhere = OrganisationSchemeWhere
    def add_OrganisationSchemeWhere(self, value): self.OrganisationSchemeWhere.append(value)
    def insert_OrganisationSchemeWhere_at(self, index, value): self.OrganisationSchemeWhere.insert(index, value)
    def replace_OrganisationSchemeWhere_at(self, index, value): self.OrganisationSchemeWhere[index] = value
    def get_ConceptSchemeWhere(self): return self.ConceptSchemeWhere
    def set_ConceptSchemeWhere(self, ConceptSchemeWhere): self.ConceptSchemeWhere = ConceptSchemeWhere
    def add_ConceptSchemeWhere(self, value): self.ConceptSchemeWhere.append(value)
    def insert_ConceptSchemeWhere_at(self, index, value): self.ConceptSchemeWhere.insert(index, value)
    def replace_ConceptSchemeWhere_at(self, index, value): self.ConceptSchemeWhere[index] = value
    def get_CategorySchemeWhere(self): return self.CategorySchemeWhere
    def set_CategorySchemeWhere(self, CategorySchemeWhere): self.CategorySchemeWhere = CategorySchemeWhere
    def add_CategorySchemeWhere(self, value): self.CategorySchemeWhere.append(value)
    def insert_CategorySchemeWhere_at(self, index, value): self.CategorySchemeWhere.insert(index, value)
    def replace_CategorySchemeWhere_at(self, index, value): self.CategorySchemeWhere[index] = value
    def get_defaultLimit(self): return self.defaultLimit
    def set_defaultLimit(self, defaultLimit): self.defaultLimit = defaultLimit
    def hasContent_(self):
        if (
            self.DataWhere or
            self.MetadataWhere or
            self.KeyFamilyWhere or
            self.MetadataStructureWhere or
            self.CodelistWhere or
            self.ConceptWhere or
            self.AgencyWhere or
            self.DataProviderWhere or
            self.HierarchicalCodelistWhere or
            self.ReportingTaxonomyWhere or
            self.DataflowWhere or
            self.MetadataflowWhere or
            self.StructureSetWhere or
            self.ProcessWhere or
            self.OrganisationSchemeWhere or
            self.ConceptSchemeWhere or
            self.CategorySchemeWhere
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryType'):
        if self.defaultLimit is not None and 'defaultLimit' not in already_processed:
            already_processed.add('defaultLimit')
            outfile.write(' defaultLimit="%s"' % self.gds_format_integer(self.defaultLimit, input_name='defaultLimit'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataWhere_ in self.DataWhere:
            DataWhere_.export(outfile, level, namespace_, name_='DataWhere', pretty_print=pretty_print)
        for MetadataWhere_ in self.MetadataWhere:
            MetadataWhere_.export(outfile, level, namespace_, name_='MetadataWhere', pretty_print=pretty_print)
        for KeyFamilyWhere_ in self.KeyFamilyWhere:
            KeyFamilyWhere_.export(outfile, level, namespace_, name_='KeyFamilyWhere', pretty_print=pretty_print)
        for MetadataStructureWhere_ in self.MetadataStructureWhere:
            MetadataStructureWhere_.export(outfile, level, namespace_, name_='MetadataStructureWhere', pretty_print=pretty_print)
        for CodelistWhere_ in self.CodelistWhere:
            CodelistWhere_.export(outfile, level, namespace_, name_='CodelistWhere', pretty_print=pretty_print)
        for ConceptWhere_ in self.ConceptWhere:
            ConceptWhere_.export(outfile, level, namespace_, name_='ConceptWhere', pretty_print=pretty_print)
        for AgencyWhere_ in self.AgencyWhere:
            AgencyWhere_.export(outfile, level, namespace_, name_='AgencyWhere', pretty_print=pretty_print)
        for DataProviderWhere_ in self.DataProviderWhere:
            DataProviderWhere_.export(outfile, level, namespace_, name_='DataProviderWhere', pretty_print=pretty_print)
        for HierarchicalCodelistWhere_ in self.HierarchicalCodelistWhere:
            HierarchicalCodelistWhere_.export(outfile, level, namespace_, name_='HierarchicalCodelistWhere', pretty_print=pretty_print)
        for ReportingTaxonomyWhere_ in self.ReportingTaxonomyWhere:
            ReportingTaxonomyWhere_.export(outfile, level, namespace_, name_='ReportingTaxonomyWhere', pretty_print=pretty_print)
        for DataflowWhere_ in self.DataflowWhere:
            DataflowWhere_.export(outfile, level, namespace_, name_='DataflowWhere', pretty_print=pretty_print)
        for MetadataflowWhere_ in self.MetadataflowWhere:
            MetadataflowWhere_.export(outfile, level, namespace_, name_='MetadataflowWhere', pretty_print=pretty_print)
        for StructureSetWhere_ in self.StructureSetWhere:
            StructureSetWhere_.export(outfile, level, namespace_, name_='StructureSetWhere', pretty_print=pretty_print)
        for ProcessWhere_ in self.ProcessWhere:
            ProcessWhere_.export(outfile, level, namespace_, name_='ProcessWhere', pretty_print=pretty_print)
        for OrganisationSchemeWhere_ in self.OrganisationSchemeWhere:
            OrganisationSchemeWhere_.export(outfile, level, namespace_, name_='OrganisationSchemeWhere', pretty_print=pretty_print)
        for ConceptSchemeWhere_ in self.ConceptSchemeWhere:
            ConceptSchemeWhere_.export(outfile, level, namespace_, name_='ConceptSchemeWhere', pretty_print=pretty_print)
        for CategorySchemeWhere_ in self.CategorySchemeWhere:
            CategorySchemeWhere_.export(outfile, level, namespace_, name_='CategorySchemeWhere', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.defaultLimit is not None and 'defaultLimit' not in already_processed:
            already_processed.add('defaultLimit')
            showIndent(outfile, level)
            outfile.write('defaultLimit=%d,\n' % (self.defaultLimit,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataWhere=[\n')
        level += 1
        for DataWhere_ in self.DataWhere:
            showIndent(outfile, level)
            outfile.write('model_.DataWhereType(\n')
            DataWhere_.exportLiteral(outfile, level, name_='DataWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataWhere=[\n')
        level += 1
        for MetadataWhere_ in self.MetadataWhere:
            showIndent(outfile, level)
            outfile.write('model_.MetadataWhereType(\n')
            MetadataWhere_.exportLiteral(outfile, level, name_='MetadataWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamilyWhere=[\n')
        level += 1
        for KeyFamilyWhere_ in self.KeyFamilyWhere:
            showIndent(outfile, level)
            outfile.write('model_.KeyFamilyWhereType(\n')
            KeyFamilyWhere_.exportLiteral(outfile, level, name_='KeyFamilyWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructureWhere=[\n')
        level += 1
        for MetadataStructureWhere_ in self.MetadataStructureWhere:
            showIndent(outfile, level)
            outfile.write('model_.MetadataStructureWhereType(\n')
            MetadataStructureWhere_.exportLiteral(outfile, level, name_='MetadataStructureWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodelistWhere=[\n')
        level += 1
        for CodelistWhere_ in self.CodelistWhere:
            showIndent(outfile, level)
            outfile.write('model_.CodelistWhereType(\n')
            CodelistWhere_.exportLiteral(outfile, level, name_='CodelistWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptWhere=[\n')
        level += 1
        for ConceptWhere_ in self.ConceptWhere:
            showIndent(outfile, level)
            outfile.write('model_.ConceptWhereType(\n')
            ConceptWhere_.exportLiteral(outfile, level, name_='ConceptWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AgencyWhere=[\n')
        level += 1
        for AgencyWhere_ in self.AgencyWhere:
            showIndent(outfile, level)
            outfile.write('model_.AgencyWhereType(\n')
            AgencyWhere_.exportLiteral(outfile, level, name_='AgencyWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderWhere=[\n')
        level += 1
        for DataProviderWhere_ in self.DataProviderWhere:
            showIndent(outfile, level)
            outfile.write('model_.DataProviderWhereType(\n')
            DataProviderWhere_.exportLiteral(outfile, level, name_='DataProviderWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HierarchicalCodelistWhere=[\n')
        level += 1
        for HierarchicalCodelistWhere_ in self.HierarchicalCodelistWhere:
            showIndent(outfile, level)
            outfile.write('model_.HierarchicalCodelistWhereType(\n')
            HierarchicalCodelistWhere_.exportLiteral(outfile, level, name_='HierarchicalCodelistWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportingTaxonomyWhere=[\n')
        level += 1
        for ReportingTaxonomyWhere_ in self.ReportingTaxonomyWhere:
            showIndent(outfile, level)
            outfile.write('model_.ReportingTaxonomyWhereType(\n')
            ReportingTaxonomyWhere_.exportLiteral(outfile, level, name_='ReportingTaxonomyWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowWhere=[\n')
        level += 1
        for DataflowWhere_ in self.DataflowWhere:
            showIndent(outfile, level)
            outfile.write('model_.DataflowWhereType(\n')
            DataflowWhere_.exportLiteral(outfile, level, name_='DataflowWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowWhere=[\n')
        level += 1
        for MetadataflowWhere_ in self.MetadataflowWhere:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowWhereType(\n')
            MetadataflowWhere_.exportLiteral(outfile, level, name_='MetadataflowWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureSetWhere=[\n')
        level += 1
        for StructureSetWhere_ in self.StructureSetWhere:
            showIndent(outfile, level)
            outfile.write('model_.StructureSetWhereType(\n')
            StructureSetWhere_.exportLiteral(outfile, level, name_='StructureSetWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProcessWhere=[\n')
        level += 1
        for ProcessWhere_ in self.ProcessWhere:
            showIndent(outfile, level)
            outfile.write('model_.ProcessWhereType(\n')
            ProcessWhere_.exportLiteral(outfile, level, name_='ProcessWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OrganisationSchemeWhere=[\n')
        level += 1
        for OrganisationSchemeWhere_ in self.OrganisationSchemeWhere:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationSchemeWhereType(\n')
            OrganisationSchemeWhere_.exportLiteral(outfile, level, name_='OrganisationSchemeWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptSchemeWhere=[\n')
        level += 1
        for ConceptSchemeWhere_ in self.ConceptSchemeWhere:
            showIndent(outfile, level)
            outfile.write('model_.ConceptSchemeWhereType(\n')
            ConceptSchemeWhere_.exportLiteral(outfile, level, name_='ConceptSchemeWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeWhere=[\n')
        level += 1
        for CategorySchemeWhere_ in self.CategorySchemeWhere:
            showIndent(outfile, level)
            outfile.write('model_.CategorySchemeWhereType(\n')
            CategorySchemeWhere_.exportLiteral(outfile, level, name_='CategorySchemeWhereType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('defaultLimit', node)
        if value is not None and 'defaultLimit' not in already_processed:
            already_processed.add('defaultLimit')
            try:
                self.defaultLimit = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataWhere':
            obj_ = DataWhereType.factory()
            obj_.build(child_)
            self.DataWhere.append(obj_)
            obj_.original_tagname_ = 'DataWhere'
        elif nodeName_ == 'MetadataWhere':
            obj_ = MetadataWhereType.factory()
            obj_.build(child_)
            self.MetadataWhere.append(obj_)
            obj_.original_tagname_ = 'MetadataWhere'
        elif nodeName_ == 'KeyFamilyWhere':
            obj_ = KeyFamilyWhereType.factory()
            obj_.build(child_)
            self.KeyFamilyWhere.append(obj_)
            obj_.original_tagname_ = 'KeyFamilyWhere'
        elif nodeName_ == 'MetadataStructureWhere':
            obj_ = MetadataStructureWhereType.factory()
            obj_.build(child_)
            self.MetadataStructureWhere.append(obj_)
            obj_.original_tagname_ = 'MetadataStructureWhere'
        elif nodeName_ == 'CodelistWhere':
            obj_ = CodelistWhereType.factory()
            obj_.build(child_)
            self.CodelistWhere.append(obj_)
            obj_.original_tagname_ = 'CodelistWhere'
        elif nodeName_ == 'ConceptWhere':
            obj_ = ConceptWhereType.factory()
            obj_.build(child_)
            self.ConceptWhere.append(obj_)
            obj_.original_tagname_ = 'ConceptWhere'
        elif nodeName_ == 'AgencyWhere':
            obj_ = AgencyWhereType.factory()
            obj_.build(child_)
            self.AgencyWhere.append(obj_)
            obj_.original_tagname_ = 'AgencyWhere'
        elif nodeName_ == 'DataProviderWhere':
            obj_ = DataProviderWhereType.factory()
            obj_.build(child_)
            self.DataProviderWhere.append(obj_)
            obj_.original_tagname_ = 'DataProviderWhere'
        elif nodeName_ == 'HierarchicalCodelistWhere':
            obj_ = HierarchicalCodelistWhereType.factory()
            obj_.build(child_)
            self.HierarchicalCodelistWhere.append(obj_)
            obj_.original_tagname_ = 'HierarchicalCodelistWhere'
        elif nodeName_ == 'ReportingTaxonomyWhere':
            obj_ = ReportingTaxonomyWhereType.factory()
            obj_.build(child_)
            self.ReportingTaxonomyWhere.append(obj_)
            obj_.original_tagname_ = 'ReportingTaxonomyWhere'
        elif nodeName_ == 'DataflowWhere':
            obj_ = DataflowWhereType.factory()
            obj_.build(child_)
            self.DataflowWhere.append(obj_)
            obj_.original_tagname_ = 'DataflowWhere'
        elif nodeName_ == 'MetadataflowWhere':
            obj_ = MetadataflowWhereType.factory()
            obj_.build(child_)
            self.MetadataflowWhere.append(obj_)
            obj_.original_tagname_ = 'MetadataflowWhere'
        elif nodeName_ == 'StructureSetWhere':
            obj_ = StructureSetWhereType.factory()
            obj_.build(child_)
            self.StructureSetWhere.append(obj_)
            obj_.original_tagname_ = 'StructureSetWhere'
        elif nodeName_ == 'ProcessWhere':
            obj_ = ProcessWhereType.factory()
            obj_.build(child_)
            self.ProcessWhere.append(obj_)
            obj_.original_tagname_ = 'ProcessWhere'
        elif nodeName_ == 'OrganisationSchemeWhere':
            obj_ = OrganisationSchemeWhereType.factory()
            obj_.build(child_)
            self.OrganisationSchemeWhere.append(obj_)
            obj_.original_tagname_ = 'OrganisationSchemeWhere'
        elif nodeName_ == 'ConceptSchemeWhere':
            obj_ = ConceptSchemeWhereType.factory()
            obj_.build(child_)
            self.ConceptSchemeWhere.append(obj_)
            obj_.original_tagname_ = 'ConceptSchemeWhere'
        elif nodeName_ == 'CategorySchemeWhere':
            obj_ = CategorySchemeWhereType.factory()
            obj_.build(child_)
            self.CategorySchemeWhere.append(obj_)
            obj_.original_tagname_ = 'CategorySchemeWhere'
# end class QueryType


class DataWhereType(GeneratedsSuper):
    """The DataWhere element representes a query for data. It contains all
    of the clauses in that query, represented by its child elements.
    Values are the IDs of the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, DataSet=None, KeyFamily=None, Dimension=None, Attribute=None, Codelist=None, Time=None, Category=None, Concept=None, DataProvider=None, Dataflow=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.DataSet = DataSet
        self.KeyFamily = KeyFamily
        self.Dimension = Dimension
        self.Attribute = Attribute
        self.Codelist = Codelist
        self.Time = Time
        self.Category = Category
        self.Concept = Concept
        self.DataProvider = DataProvider
        self.Dataflow = Dataflow
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if DataWhereType.subclass:
            return DataWhereType.subclass(*args_, **kwargs_)
        else:
            return DataWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def get_Dataflow(self): return self.Dataflow
    def set_Dataflow(self, Dataflow): self.Dataflow = Dataflow
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.DataSet is not None or
            self.KeyFamily is not None or
            self.Dimension is not None or
            self.Attribute is not None or
            self.Codelist is not None or
            self.Time is not None or
            self.Category is not None or
            self.Concept is not None or
            self.DataProvider is not None or
            self.Dataflow is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSet>%s</%sDataSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataSet).encode(ExternalEncoding), input_name='DataSet'), namespace_, eol_))
        if self.KeyFamily is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamily).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        if self.Dimension is not None:
            self.Dimension.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.Codelist is not None:
            self.Codelist.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.Category is not None:
            self.Category.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Concept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(self.Concept).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        if self.DataProvider is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProvider>%s</%sDataProvider>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataProvider).encode(ExternalEncoding), input_name='DataProvider'), namespace_, eol_))
        if self.Dataflow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflow>%s</%sDataflow>%s' % (namespace_, self.gds_format_string(quote_xml(self.Dataflow).encode(ExternalEncoding), input_name='Dataflow'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataSet is not None:
            showIndent(outfile, level)
            outfile.write('DataSet=%s,\n' % quote_python(self.DataSet).encode(ExternalEncoding))
        if self.KeyFamily is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamily=%s,\n' % quote_python(self.KeyFamily).encode(ExternalEncoding))
        if self.Dimension is not None:
            showIndent(outfile, level)
            outfile.write('Dimension=model_.DimensionType(\n')
            self.Dimension.exportLiteral(outfile, level, name_='Dimension')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Codelist is not None:
            showIndent(outfile, level)
            outfile.write('Codelist=model_.CodelistType(\n')
            self.Codelist.exportLiteral(outfile, level, name_='Codelist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.TimeType(\n')
            self.Time.exportLiteral(outfile, level, name_='Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=model_.CategoryType(\n')
            self.Category.exportLiteral(outfile, level, name_='Category')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concept is not None:
            showIndent(outfile, level)
            outfile.write('Concept=%s,\n' % quote_python(self.Concept).encode(ExternalEncoding))
        if self.DataProvider is not None:
            showIndent(outfile, level)
            outfile.write('DataProvider=%s,\n' % quote_python(self.DataProvider).encode(ExternalEncoding))
        if self.Dataflow is not None:
            showIndent(outfile, level)
            outfile.write('Dataflow=%s,\n' % quote_python(self.Dataflow).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            DataSet_ = child_.text
            DataSet_ = self.gds_validate_string(DataSet_, node, 'DataSet')
            self.DataSet = DataSet_
        elif nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily = KeyFamily_
        elif nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension = obj_
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist = obj_
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Time':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category = obj_
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept = Concept_
        elif nodeName_ == 'DataProvider':
            DataProvider_ = child_.text
            DataProvider_ = self.gds_validate_string(DataProvider_, node, 'DataProvider')
            self.DataProvider = DataProvider_
        elif nodeName_ == 'Dataflow':
            Dataflow_ = child_.text
            Dataflow_ = self.gds_validate_string(Dataflow_, node, 'Dataflow')
            self.Dataflow = Dataflow_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class DataWhereType


class MetadataWhereType(GeneratedsSuper):
    """The MetadataWhere element representes a query for metadata. It
    contains all of the clauses in that query, represented by its
    child elements. Values are the IDs of the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, MetadataSet=None, MetadataStructure=None, StructureComponent=None, Attribute=None, Codelist=None, Time=None, Category=None, Concept=None, DataProvider=None, Metadataflow=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.MetadataSet = MetadataSet
        self.MetadataStructure = MetadataStructure
        self.StructureComponent = StructureComponent
        self.Attribute = Attribute
        self.Codelist = Codelist
        self.Time = Time
        self.Category = Category
        self.Concept = Concept
        self.DataProvider = DataProvider
        self.Metadataflow = Metadataflow
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if MetadataWhereType.subclass:
            return MetadataWhereType.subclass(*args_, **kwargs_)
        else:
            return MetadataWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def get_StructureComponent(self): return self.StructureComponent
    def set_StructureComponent(self, StructureComponent): self.StructureComponent = StructureComponent
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def get_Metadataflow(self): return self.Metadataflow
    def set_Metadataflow(self, Metadataflow): self.Metadataflow = Metadataflow
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.MetadataSet is not None or
            self.MetadataStructure is not None or
            self.StructureComponent is not None or
            self.Attribute is not None or
            self.Codelist is not None or
            self.Time is not None or
            self.Category is not None or
            self.Concept is not None or
            self.DataProvider is not None or
            self.Metadataflow is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.MetadataSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataSet>%s</%sMetadataSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataSet).encode(ExternalEncoding), input_name='MetadataSet'), namespace_, eol_))
        if self.MetadataStructure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructure).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        if self.StructureComponent is not None:
            self.StructureComponent.export(outfile, level, namespace_, name_='StructureComponent', pretty_print=pretty_print)
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.Codelist is not None:
            self.Codelist.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        if self.Time is not None:
            self.Time.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        if self.Category is not None:
            self.Category.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Concept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(self.Concept).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        if self.DataProvider is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProvider>%s</%sDataProvider>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataProvider).encode(ExternalEncoding), input_name='DataProvider'), namespace_, eol_))
        if self.Metadataflow is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflow>%s</%sMetadataflow>%s' % (namespace_, self.gds_format_string(quote_xml(self.Metadataflow).encode(ExternalEncoding), input_name='Metadataflow'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.MetadataSet is not None:
            showIndent(outfile, level)
            outfile.write('MetadataSet=%s,\n' % quote_python(self.MetadataSet).encode(ExternalEncoding))
        if self.MetadataStructure is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructure=%s,\n' % quote_python(self.MetadataStructure).encode(ExternalEncoding))
        if self.StructureComponent is not None:
            showIndent(outfile, level)
            outfile.write('StructureComponent=model_.StructureComponentType(\n')
            self.StructureComponent.exportLiteral(outfile, level, name_='StructureComponent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Codelist is not None:
            showIndent(outfile, level)
            outfile.write('Codelist=model_.CodelistType(\n')
            self.Codelist.exportLiteral(outfile, level, name_='Codelist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=model_.TimeType(\n')
            self.Time.exportLiteral(outfile, level, name_='Time')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=model_.CategoryType(\n')
            self.Category.exportLiteral(outfile, level, name_='Category')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concept is not None:
            showIndent(outfile, level)
            outfile.write('Concept=%s,\n' % quote_python(self.Concept).encode(ExternalEncoding))
        if self.DataProvider is not None:
            showIndent(outfile, level)
            outfile.write('DataProvider=%s,\n' % quote_python(self.DataProvider).encode(ExternalEncoding))
        if self.Metadataflow is not None:
            showIndent(outfile, level)
            outfile.write('Metadataflow=%s,\n' % quote_python(self.Metadataflow).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MetadataSet':
            MetadataSet_ = child_.text
            MetadataSet_ = self.gds_validate_string(MetadataSet_, node, 'MetadataSet')
            self.MetadataSet = MetadataSet_
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure = MetadataStructure_
        elif nodeName_ == 'StructureComponent':
            obj_ = StructureComponentType.factory()
            obj_.build(child_)
            self.StructureComponent = obj_
            obj_.original_tagname_ = 'StructureComponent'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist = obj_
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Time':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.Time = obj_
            obj_.original_tagname_ = 'Time'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category = obj_
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept = Concept_
        elif nodeName_ == 'DataProvider':
            DataProvider_ = child_.text
            DataProvider_ = self.gds_validate_string(DataProvider_, node, 'DataProvider')
            self.DataProvider = DataProvider_
        elif nodeName_ == 'Metadataflow':
            Metadataflow_ = child_.text
            Metadataflow_ = self.gds_validate_string(Metadataflow_, node, 'Metadataflow')
            self.Metadataflow = Metadataflow_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class MetadataWhereType


class AndType(GeneratedsSuper):
    """For the And element, each of its immediate child elements represent
    clauses all of which represent conditions which must be
    satisfied. If children are A, B, and C, then any legitimate
    response will meet conditions A, B, and C. Values are the IDs of
    the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, DataSet=None, MetadataSet=None, KeyFamily=None, MetadataStructure=None, Dimension=None, StructureComponent=None, Attribute=None, Codelist=None, Time=None, Category=None, Concept=None, AgencyID=None, DataProvider=None, Dataflow=None, Metadataflow=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if MetadataSet is None:
            self.MetadataSet = []
        else:
            self.MetadataSet = MetadataSet
        if KeyFamily is None:
            self.KeyFamily = []
        else:
            self.KeyFamily = KeyFamily
        if MetadataStructure is None:
            self.MetadataStructure = []
        else:
            self.MetadataStructure = MetadataStructure
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        if StructureComponent is None:
            self.StructureComponent = []
        else:
            self.StructureComponent = StructureComponent
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
        if Codelist is None:
            self.Codelist = []
        else:
            self.Codelist = Codelist
        if Time is None:
            self.Time = []
        else:
            self.Time = Time
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        if AgencyID is None:
            self.AgencyID = []
        else:
            self.AgencyID = AgencyID
        if DataProvider is None:
            self.DataProvider = []
        else:
            self.DataProvider = DataProvider
        if Dataflow is None:
            self.Dataflow = []
        else:
            self.Dataflow = Dataflow
        if Metadataflow is None:
            self.Metadataflow = []
        else:
            self.Metadataflow = Metadataflow
        if Version is None:
            self.Version = []
        else:
            self.Version = Version
        if Or is None:
            self.Or = []
        else:
            self.Or = Or
        if And is None:
            self.And = []
        else:
            self.And = And
    def factory(*args_, **kwargs_):
        if AndType.subclass:
            return AndType.subclass(*args_, **kwargs_)
        else:
            return AndType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def add_MetadataSet(self, value): self.MetadataSet.append(value)
    def insert_MetadataSet_at(self, index, value): self.MetadataSet.insert(index, value)
    def replace_MetadataSet_at(self, index, value): self.MetadataSet[index] = value
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def add_KeyFamily(self, value): self.KeyFamily.append(value)
    def insert_KeyFamily_at(self, index, value): self.KeyFamily.insert(index, value)
    def replace_KeyFamily_at(self, index, value): self.KeyFamily[index] = value
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def add_MetadataStructure(self, value): self.MetadataStructure.append(value)
    def insert_MetadataStructure_at(self, index, value): self.MetadataStructure.insert(index, value)
    def replace_MetadataStructure_at(self, index, value): self.MetadataStructure[index] = value
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def add_Dimension(self, value): self.Dimension.append(value)
    def insert_Dimension_at(self, index, value): self.Dimension.insert(index, value)
    def replace_Dimension_at(self, index, value): self.Dimension[index] = value
    def get_StructureComponent(self): return self.StructureComponent
    def set_StructureComponent(self, StructureComponent): self.StructureComponent = StructureComponent
    def add_StructureComponent(self, value): self.StructureComponent.append(value)
    def insert_StructureComponent_at(self, index, value): self.StructureComponent.insert(index, value)
    def replace_StructureComponent_at(self, index, value): self.StructureComponent[index] = value
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute_at(self, index, value): self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value): self.Attribute[index] = value
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def add_Codelist(self, value): self.Codelist.append(value)
    def insert_Codelist_at(self, index, value): self.Codelist.insert(index, value)
    def replace_Codelist_at(self, index, value): self.Codelist[index] = value
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def add_Time(self, value): self.Time.append(value)
    def insert_Time_at(self, index, value): self.Time.insert(index, value)
    def replace_Time_at(self, index, value): self.Time[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def add_AgencyID(self, value): self.AgencyID.append(value)
    def insert_AgencyID_at(self, index, value): self.AgencyID.insert(index, value)
    def replace_AgencyID_at(self, index, value): self.AgencyID[index] = value
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def add_DataProvider(self, value): self.DataProvider.append(value)
    def insert_DataProvider_at(self, index, value): self.DataProvider.insert(index, value)
    def replace_DataProvider_at(self, index, value): self.DataProvider[index] = value
    def get_Dataflow(self): return self.Dataflow
    def set_Dataflow(self, Dataflow): self.Dataflow = Dataflow
    def add_Dataflow(self, value): self.Dataflow.append(value)
    def insert_Dataflow_at(self, index, value): self.Dataflow.insert(index, value)
    def replace_Dataflow_at(self, index, value): self.Dataflow[index] = value
    def get_Metadataflow(self): return self.Metadataflow
    def set_Metadataflow(self, Metadataflow): self.Metadataflow = Metadataflow
    def add_Metadataflow(self, value): self.Metadataflow.append(value)
    def insert_Metadataflow_at(self, index, value): self.Metadataflow.insert(index, value)
    def replace_Metadataflow_at(self, index, value): self.Metadataflow[index] = value
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def add_Version(self, value): self.Version.append(value)
    def insert_Version_at(self, index, value): self.Version.insert(index, value)
    def replace_Version_at(self, index, value): self.Version[index] = value
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def add_Or(self, value): self.Or.append(value)
    def insert_Or_at(self, index, value): self.Or.insert(index, value)
    def replace_Or_at(self, index, value): self.Or[index] = value
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def add_And(self, value): self.And.append(value)
    def insert_And_at(self, index, value): self.And.insert(index, value)
    def replace_And_at(self, index, value): self.And[index] = value
    def hasContent_(self):
        if (
            self.DataSet or
            self.MetadataSet or
            self.KeyFamily or
            self.MetadataStructure or
            self.Dimension or
            self.StructureComponent or
            self.Attribute or
            self.Codelist or
            self.Time or
            self.Category or
            self.Concept or
            self.AgencyID or
            self.DataProvider or
            self.Dataflow or
            self.Metadataflow or
            self.Version or
            self.Or or
            self.And
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AndType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AndType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AndType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AndType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AndType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSet>%s</%sDataSet>%s' % (namespace_, self.gds_format_string(quote_xml(DataSet_).encode(ExternalEncoding), input_name='DataSet'), namespace_, eol_))
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataSet>%s</%sMetadataSet>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataSet_).encode(ExternalEncoding), input_name='MetadataSet'), namespace_, eol_))
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamily_).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataStructure_).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        for Dimension_ in self.Dimension:
            Dimension_.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        for StructureComponent_ in self.StructureComponent:
            StructureComponent_.export(outfile, level, namespace_, name_='StructureComponent', pretty_print=pretty_print)
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Codelist_ in self.Codelist:
            Codelist_.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        for Time_ in self.Time:
            Time_.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Concept_ in self.Concept:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(Concept_).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(AgencyID_).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProvider>%s</%sDataProvider>%s' % (namespace_, self.gds_format_string(quote_xml(DataProvider_).encode(ExternalEncoding), input_name='DataProvider'), namespace_, eol_))
        for Dataflow_ in self.Dataflow:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflow>%s</%sDataflow>%s' % (namespace_, self.gds_format_string(quote_xml(Dataflow_).encode(ExternalEncoding), input_name='Dataflow'), namespace_, eol_))
        for Metadataflow_ in self.Metadataflow:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflow>%s</%sMetadataflow>%s' % (namespace_, self.gds_format_string(quote_xml(Metadataflow_).encode(ExternalEncoding), input_name='Metadataflow'), namespace_, eol_))
        for Version_ in self.Version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(Version_).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        for Or_ in self.Or:
            Or_.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        for And_ in self.And:
            And_.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AndType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataSet=[\n')
        level += 1
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamily=[\n')
        level += 1
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamily_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructure=[\n')
        level += 1
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataStructure_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dimension=[\n')
        level += 1
        for Dimension_ in self.Dimension:
            showIndent(outfile, level)
            outfile.write('model_.DimensionType(\n')
            Dimension_.exportLiteral(outfile, level, name_='DimensionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureComponent=[\n')
        level += 1
        for StructureComponent_ in self.StructureComponent:
            showIndent(outfile, level)
            outfile.write('model_.StructureComponentType(\n')
            StructureComponent_.exportLiteral(outfile, level, name_='StructureComponentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            Attribute_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Codelist=[\n')
        level += 1
        for Codelist_ in self.Codelist:
            showIndent(outfile, level)
            outfile.write('model_.CodelistType(\n')
            Codelist_.exportLiteral(outfile, level, name_='CodelistType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Time=[\n')
        level += 1
        for Time_ in self.Time:
            showIndent(outfile, level)
            outfile.write('model_.TimeType(\n')
            Time_.exportLiteral(outfile, level, name_='TimeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Concept_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AgencyID=[\n')
        level += 1
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProvider=[\n')
        level += 1
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProvider_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dataflow=[\n')
        level += 1
        for Dataflow_ in self.Dataflow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Dataflow_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Metadataflow=[\n')
        level += 1
        for Metadataflow_ in self.Metadataflow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Metadataflow_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Version=[\n')
        level += 1
        for Version_ in self.Version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Or=[\n')
        level += 1
        for Or_ in self.Or:
            showIndent(outfile, level)
            outfile.write('model_.OrType(\n')
            Or_.exportLiteral(outfile, level, name_='OrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('And=[\n')
        level += 1
        for And_ in self.And:
            showIndent(outfile, level)
            outfile.write('model_.AndType(\n')
            And_.exportLiteral(outfile, level, name_='AndType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            DataSet_ = child_.text
            DataSet_ = self.gds_validate_string(DataSet_, node, 'DataSet')
            self.DataSet.append(DataSet_)
        elif nodeName_ == 'MetadataSet':
            MetadataSet_ = child_.text
            MetadataSet_ = self.gds_validate_string(MetadataSet_, node, 'MetadataSet')
            self.MetadataSet.append(MetadataSet_)
        elif nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily.append(KeyFamily_)
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure.append(MetadataStructure_)
        elif nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension.append(obj_)
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'StructureComponent':
            obj_ = StructureComponentType.factory()
            obj_.build(child_)
            self.StructureComponent.append(obj_)
            obj_.original_tagname_ = 'StructureComponent'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist.append(obj_)
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Time':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.Time.append(obj_)
            obj_.original_tagname_ = 'Time'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept.append(Concept_)
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID.append(AgencyID_)
        elif nodeName_ == 'DataProvider':
            DataProvider_ = child_.text
            DataProvider_ = self.gds_validate_string(DataProvider_, node, 'DataProvider')
            self.DataProvider.append(DataProvider_)
        elif nodeName_ == 'Dataflow':
            Dataflow_ = child_.text
            Dataflow_ = self.gds_validate_string(Dataflow_, node, 'Dataflow')
            self.Dataflow.append(Dataflow_)
        elif nodeName_ == 'Metadataflow':
            Metadataflow_ = child_.text
            Metadataflow_ = self.gds_validate_string(Metadataflow_, node, 'Metadataflow')
            self.Metadataflow.append(Metadataflow_)
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version.append(Version_)
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or.append(obj_)
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And.append(obj_)
            obj_.original_tagname_ = 'And'
# end class AndType


class OrType(GeneratedsSuper):
    """The Or element's immediate children represent clauses in the query
    any one of which is sufficient to satisfy the query. If these
    children are A, B, and C, then any result which meets condition
    A, or condition B, or condition C is a match for that query.
    Values are the IDs of the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, DataSet=None, MetadataSet=None, KeyFamily=None, MetadataStructure=None, Dimension=None, StructureComponent=None, Attribute=None, Codelist=None, Time=None, Category=None, Concept=None, AgencyID=None, DataProvider=None, Dataflow=None, Metadataflow=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if MetadataSet is None:
            self.MetadataSet = []
        else:
            self.MetadataSet = MetadataSet
        if KeyFamily is None:
            self.KeyFamily = []
        else:
            self.KeyFamily = KeyFamily
        if MetadataStructure is None:
            self.MetadataStructure = []
        else:
            self.MetadataStructure = MetadataStructure
        if Dimension is None:
            self.Dimension = []
        else:
            self.Dimension = Dimension
        if StructureComponent is None:
            self.StructureComponent = []
        else:
            self.StructureComponent = StructureComponent
        if Attribute is None:
            self.Attribute = []
        else:
            self.Attribute = Attribute
        if Codelist is None:
            self.Codelist = []
        else:
            self.Codelist = Codelist
        if Time is None:
            self.Time = []
        else:
            self.Time = Time
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        if AgencyID is None:
            self.AgencyID = []
        else:
            self.AgencyID = AgencyID
        if DataProvider is None:
            self.DataProvider = []
        else:
            self.DataProvider = DataProvider
        if Dataflow is None:
            self.Dataflow = []
        else:
            self.Dataflow = Dataflow
        if Metadataflow is None:
            self.Metadataflow = []
        else:
            self.Metadataflow = Metadataflow
        if Version is None:
            self.Version = []
        else:
            self.Version = Version
        if Or is None:
            self.Or = []
        else:
            self.Or = Or
        if And is None:
            self.And = []
        else:
            self.And = And
    def factory(*args_, **kwargs_):
        if OrType.subclass:
            return OrType.subclass(*args_, **kwargs_)
        else:
            return OrType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def add_MetadataSet(self, value): self.MetadataSet.append(value)
    def insert_MetadataSet_at(self, index, value): self.MetadataSet.insert(index, value)
    def replace_MetadataSet_at(self, index, value): self.MetadataSet[index] = value
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def add_KeyFamily(self, value): self.KeyFamily.append(value)
    def insert_KeyFamily_at(self, index, value): self.KeyFamily.insert(index, value)
    def replace_KeyFamily_at(self, index, value): self.KeyFamily[index] = value
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def add_MetadataStructure(self, value): self.MetadataStructure.append(value)
    def insert_MetadataStructure_at(self, index, value): self.MetadataStructure.insert(index, value)
    def replace_MetadataStructure_at(self, index, value): self.MetadataStructure[index] = value
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def add_Dimension(self, value): self.Dimension.append(value)
    def insert_Dimension_at(self, index, value): self.Dimension.insert(index, value)
    def replace_Dimension_at(self, index, value): self.Dimension[index] = value
    def get_StructureComponent(self): return self.StructureComponent
    def set_StructureComponent(self, StructureComponent): self.StructureComponent = StructureComponent
    def add_StructureComponent(self, value): self.StructureComponent.append(value)
    def insert_StructureComponent_at(self, index, value): self.StructureComponent.insert(index, value)
    def replace_StructureComponent_at(self, index, value): self.StructureComponent[index] = value
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def add_Attribute(self, value): self.Attribute.append(value)
    def insert_Attribute_at(self, index, value): self.Attribute.insert(index, value)
    def replace_Attribute_at(self, index, value): self.Attribute[index] = value
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def add_Codelist(self, value): self.Codelist.append(value)
    def insert_Codelist_at(self, index, value): self.Codelist.insert(index, value)
    def replace_Codelist_at(self, index, value): self.Codelist[index] = value
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def add_Time(self, value): self.Time.append(value)
    def insert_Time_at(self, index, value): self.Time.insert(index, value)
    def replace_Time_at(self, index, value): self.Time[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def add_AgencyID(self, value): self.AgencyID.append(value)
    def insert_AgencyID_at(self, index, value): self.AgencyID.insert(index, value)
    def replace_AgencyID_at(self, index, value): self.AgencyID[index] = value
    def get_DataProvider(self): return self.DataProvider
    def set_DataProvider(self, DataProvider): self.DataProvider = DataProvider
    def add_DataProvider(self, value): self.DataProvider.append(value)
    def insert_DataProvider_at(self, index, value): self.DataProvider.insert(index, value)
    def replace_DataProvider_at(self, index, value): self.DataProvider[index] = value
    def get_Dataflow(self): return self.Dataflow
    def set_Dataflow(self, Dataflow): self.Dataflow = Dataflow
    def add_Dataflow(self, value): self.Dataflow.append(value)
    def insert_Dataflow_at(self, index, value): self.Dataflow.insert(index, value)
    def replace_Dataflow_at(self, index, value): self.Dataflow[index] = value
    def get_Metadataflow(self): return self.Metadataflow
    def set_Metadataflow(self, Metadataflow): self.Metadataflow = Metadataflow
    def add_Metadataflow(self, value): self.Metadataflow.append(value)
    def insert_Metadataflow_at(self, index, value): self.Metadataflow.insert(index, value)
    def replace_Metadataflow_at(self, index, value): self.Metadataflow[index] = value
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def add_Version(self, value): self.Version.append(value)
    def insert_Version_at(self, index, value): self.Version.insert(index, value)
    def replace_Version_at(self, index, value): self.Version[index] = value
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def add_Or(self, value): self.Or.append(value)
    def insert_Or_at(self, index, value): self.Or.insert(index, value)
    def replace_Or_at(self, index, value): self.Or[index] = value
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def add_And(self, value): self.And.append(value)
    def insert_And_at(self, index, value): self.And.insert(index, value)
    def replace_And_at(self, index, value): self.And[index] = value
    def hasContent_(self):
        if (
            self.DataSet or
            self.MetadataSet or
            self.KeyFamily or
            self.MetadataStructure or
            self.Dimension or
            self.StructureComponent or
            self.Attribute or
            self.Codelist or
            self.Time or
            self.Category or
            self.Concept or
            self.AgencyID or
            self.DataProvider or
            self.Dataflow or
            self.Metadataflow or
            self.Version or
            self.Or or
            self.And
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSet>%s</%sDataSet>%s' % (namespace_, self.gds_format_string(quote_xml(DataSet_).encode(ExternalEncoding), input_name='DataSet'), namespace_, eol_))
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataSet>%s</%sMetadataSet>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataSet_).encode(ExternalEncoding), input_name='MetadataSet'), namespace_, eol_))
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamily_).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataStructure_).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        for Dimension_ in self.Dimension:
            Dimension_.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        for StructureComponent_ in self.StructureComponent:
            StructureComponent_.export(outfile, level, namespace_, name_='StructureComponent', pretty_print=pretty_print)
        for Attribute_ in self.Attribute:
            Attribute_.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        for Codelist_ in self.Codelist:
            Codelist_.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        for Time_ in self.Time:
            Time_.export(outfile, level, namespace_, name_='Time', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Concept_ in self.Concept:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(Concept_).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(AgencyID_).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProvider>%s</%sDataProvider>%s' % (namespace_, self.gds_format_string(quote_xml(DataProvider_).encode(ExternalEncoding), input_name='DataProvider'), namespace_, eol_))
        for Dataflow_ in self.Dataflow:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflow>%s</%sDataflow>%s' % (namespace_, self.gds_format_string(quote_xml(Dataflow_).encode(ExternalEncoding), input_name='Dataflow'), namespace_, eol_))
        for Metadataflow_ in self.Metadataflow:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflow>%s</%sMetadataflow>%s' % (namespace_, self.gds_format_string(quote_xml(Metadataflow_).encode(ExternalEncoding), input_name='Metadataflow'), namespace_, eol_))
        for Version_ in self.Version:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(Version_).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        for Or_ in self.Or:
            Or_.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        for And_ in self.And:
            And_.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='OrType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataSet=[\n')
        level += 1
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamily=[\n')
        level += 1
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamily_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructure=[\n')
        level += 1
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataStructure_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dimension=[\n')
        level += 1
        for Dimension_ in self.Dimension:
            showIndent(outfile, level)
            outfile.write('model_.DimensionType(\n')
            Dimension_.exportLiteral(outfile, level, name_='DimensionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureComponent=[\n')
        level += 1
        for StructureComponent_ in self.StructureComponent:
            showIndent(outfile, level)
            outfile.write('model_.StructureComponentType(\n')
            StructureComponent_.exportLiteral(outfile, level, name_='StructureComponentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Attribute=[\n')
        level += 1
        for Attribute_ in self.Attribute:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            Attribute_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Codelist=[\n')
        level += 1
        for Codelist_ in self.Codelist:
            showIndent(outfile, level)
            outfile.write('model_.CodelistType(\n')
            Codelist_.exportLiteral(outfile, level, name_='CodelistType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Time=[\n')
        level += 1
        for Time_ in self.Time:
            showIndent(outfile, level)
            outfile.write('model_.TimeType(\n')
            Time_.exportLiteral(outfile, level, name_='TimeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Concept_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AgencyID=[\n')
        level += 1
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProvider=[\n')
        level += 1
        for DataProvider_ in self.DataProvider:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProvider_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Dataflow=[\n')
        level += 1
        for Dataflow_ in self.Dataflow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Dataflow_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Metadataflow=[\n')
        level += 1
        for Metadataflow_ in self.Metadataflow:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Metadataflow_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Version=[\n')
        level += 1
        for Version_ in self.Version:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Version_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Or=[\n')
        level += 1
        for Or_ in self.Or:
            showIndent(outfile, level)
            outfile.write('model_.OrType(\n')
            Or_.exportLiteral(outfile, level, name_='OrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('And=[\n')
        level += 1
        for And_ in self.And:
            showIndent(outfile, level)
            outfile.write('model_.AndType(\n')
            And_.exportLiteral(outfile, level, name_='AndType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            DataSet_ = child_.text
            DataSet_ = self.gds_validate_string(DataSet_, node, 'DataSet')
            self.DataSet.append(DataSet_)
        elif nodeName_ == 'MetadataSet':
            MetadataSet_ = child_.text
            MetadataSet_ = self.gds_validate_string(MetadataSet_, node, 'MetadataSet')
            self.MetadataSet.append(MetadataSet_)
        elif nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily.append(KeyFamily_)
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure.append(MetadataStructure_)
        elif nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension.append(obj_)
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'StructureComponent':
            obj_ = StructureComponentType.factory()
            obj_.build(child_)
            self.StructureComponent.append(obj_)
            obj_.original_tagname_ = 'StructureComponent'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute.append(obj_)
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist.append(obj_)
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Time':
            obj_ = TimeType.factory()
            obj_.build(child_)
            self.Time.append(obj_)
            obj_.original_tagname_ = 'Time'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept.append(Concept_)
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID.append(AgencyID_)
        elif nodeName_ == 'DataProvider':
            DataProvider_ = child_.text
            DataProvider_ = self.gds_validate_string(DataProvider_, node, 'DataProvider')
            self.DataProvider.append(DataProvider_)
        elif nodeName_ == 'Dataflow':
            Dataflow_ = child_.text
            Dataflow_ = self.gds_validate_string(Dataflow_, node, 'Dataflow')
            self.Dataflow.append(Dataflow_)
        elif nodeName_ == 'Metadataflow':
            Metadataflow_ = child_.text
            Metadataflow_ = self.gds_validate_string(Metadataflow_, node, 'Metadataflow')
            self.Metadataflow.append(Metadataflow_)
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version.append(Version_)
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or.append(obj_)
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And.append(obj_)
            obj_.original_tagname_ = 'And'
# end class OrType


class StructureComponentType(GeneratedsSuper):
    """StructureComponent elements contain the (single) value being
    searched on within the key of data set, but this value can be
    either a code value or the alias assigned to a set of equivalent
    code values. The id attribute holds the ID of the dimension,
    attribute, or alias assigned to a component in a structure set.
    If the content is empty, then the query is for any component
    with the given name or alias. If the name attribute is not
    supplied, then the query is for the given code value or alias
    within any component or component alias."""
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if StructureComponentType.subclass:
            return StructureComponentType.subclass(*args_, **kwargs_)
        else:
            return StructureComponentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureComponentType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureComponentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureComponentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureComponentType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureComponentType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='StructureComponentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StructureComponentType


class CodelistType(GeneratedsSuper):
    """The Codelist element allows queries to specify a (single) value
    found within a codelist as the element content, and the agency-
    qualified name of the codelist being queried for in the name
    attribute. If no content is supplied, then the query is for the
    named codelist. If the id attribute is left empty, then the
    value is searched for in any codelist."""
    subclass = None
    superclass = None
    def __init__(self, id=None, valueOf_=None):
        self.original_tagname_ = None
        self.id = _cast(None, id)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CodelistType.subclass:
            return CodelistType.subclass(*args_, **kwargs_)
        else:
            return CodelistType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodelistType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodelistType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodelistType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodelistType'):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodelistType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CodelistType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CodelistType


class KeyFamilyWhereType(GeneratedsSuper):
    """The KeyFamilyWhere element representes a query for a key family or
    key families. It contains all of the clauses in that query,
    represented by its child elements. Values are the IDs of the
    referenced object."""
    subclass = None
    superclass = None
    def __init__(self, KeyFamily=None, Dimension=None, Attribute=None, Codelist=None, Category=None, Concept=None, AgencyID=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.KeyFamily = KeyFamily
        self.Dimension = Dimension
        self.Attribute = Attribute
        self.Codelist = Codelist
        self.Category = Category
        self.Concept = Concept
        self.AgencyID = AgencyID
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if KeyFamilyWhereType.subclass:
            return KeyFamilyWhereType.subclass(*args_, **kwargs_)
        else:
            return KeyFamilyWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.KeyFamily is not None or
            self.Dimension is not None or
            self.Attribute is not None or
            self.Codelist is not None or
            self.Category is not None or
            self.Concept is not None or
            self.AgencyID is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='KeyFamilyWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='KeyFamilyWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='KeyFamilyWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='KeyFamilyWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='KeyFamilyWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KeyFamily is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamily).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        if self.Dimension is not None:
            self.Dimension.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.Codelist is not None:
            self.Codelist.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        if self.Category is not None:
            self.Category.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Concept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(self.Concept).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='KeyFamilyWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeyFamily is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamily=%s,\n' % quote_python(self.KeyFamily).encode(ExternalEncoding))
        if self.Dimension is not None:
            showIndent(outfile, level)
            outfile.write('Dimension=model_.DimensionType(\n')
            self.Dimension.exportLiteral(outfile, level, name_='Dimension')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Codelist is not None:
            showIndent(outfile, level)
            outfile.write('Codelist=model_.CodelistType(\n')
            self.Codelist.exportLiteral(outfile, level, name_='Codelist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=model_.CategoryType(\n')
            self.Category.exportLiteral(outfile, level, name_='Category')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concept is not None:
            showIndent(outfile, level)
            outfile.write('Concept=%s,\n' % quote_python(self.Concept).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily = KeyFamily_
        elif nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension = obj_
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist = obj_
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category = obj_
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept = Concept_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class KeyFamilyWhereType


class MetadataStructureWhereType(GeneratedsSuper):
    """The MetadataStructureWhere element representes a query for a
    metadata structure or structures. It contains all of the clauses
    in that query, represented by its child elements. Values are the
    IDs of the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, KeyFamily=None, MetadataStructure=None, StructureSet=None, Dimension=None, StructureComponent=None, Attribute=None, Codelist=None, Category=None, Concept=None, AgencyID=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.KeyFamily = KeyFamily
        self.MetadataStructure = MetadataStructure
        self.StructureSet = StructureSet
        self.Dimension = Dimension
        self.StructureComponent = StructureComponent
        self.Attribute = Attribute
        self.Codelist = Codelist
        self.Category = Category
        self.Concept = Concept
        self.AgencyID = AgencyID
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if MetadataStructureWhereType.subclass:
            return MetadataStructureWhereType.subclass(*args_, **kwargs_)
        else:
            return MetadataStructureWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def get_StructureSet(self): return self.StructureSet
    def set_StructureSet(self, StructureSet): self.StructureSet = StructureSet
    def get_Dimension(self): return self.Dimension
    def set_Dimension(self, Dimension): self.Dimension = Dimension
    def get_StructureComponent(self): return self.StructureComponent
    def set_StructureComponent(self, StructureComponent): self.StructureComponent = StructureComponent
    def get_Attribute(self): return self.Attribute
    def set_Attribute(self, Attribute): self.Attribute = Attribute
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.KeyFamily is not None or
            self.MetadataStructure is not None or
            self.StructureSet is not None or
            self.Dimension is not None or
            self.StructureComponent is not None or
            self.Attribute is not None or
            self.Codelist is not None or
            self.Category is not None or
            self.Concept is not None or
            self.AgencyID is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataStructureWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataStructureWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataStructureWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataStructureWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataStructureWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.KeyFamily is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(self.KeyFamily).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        if self.MetadataStructure is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructure).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        if self.StructureSet is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureSet>%s</%sStructureSet>%s' % (namespace_, self.gds_format_string(quote_xml(self.StructureSet).encode(ExternalEncoding), input_name='StructureSet'), namespace_, eol_))
        if self.Dimension is not None:
            self.Dimension.export(outfile, level, namespace_, name_='Dimension', pretty_print=pretty_print)
        if self.StructureComponent is not None:
            self.StructureComponent.export(outfile, level, namespace_, name_='StructureComponent', pretty_print=pretty_print)
        if self.Attribute is not None:
            self.Attribute.export(outfile, level, namespace_, name_='Attribute', pretty_print=pretty_print)
        if self.Codelist is not None:
            self.Codelist.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        if self.Category is not None:
            self.Category.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        if self.Concept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(self.Concept).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataStructureWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.KeyFamily is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamily=%s,\n' % quote_python(self.KeyFamily).encode(ExternalEncoding))
        if self.MetadataStructure is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructure=%s,\n' % quote_python(self.MetadataStructure).encode(ExternalEncoding))
        if self.StructureSet is not None:
            showIndent(outfile, level)
            outfile.write('StructureSet=%s,\n' % quote_python(self.StructureSet).encode(ExternalEncoding))
        if self.Dimension is not None:
            showIndent(outfile, level)
            outfile.write('Dimension=model_.DimensionType(\n')
            self.Dimension.exportLiteral(outfile, level, name_='Dimension')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureComponent is not None:
            showIndent(outfile, level)
            outfile.write('StructureComponent=model_.StructureComponentType(\n')
            self.StructureComponent.exportLiteral(outfile, level, name_='StructureComponent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Attribute is not None:
            showIndent(outfile, level)
            outfile.write('Attribute=model_.AttributeType(\n')
            self.Attribute.exportLiteral(outfile, level, name_='Attribute')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Codelist is not None:
            showIndent(outfile, level)
            outfile.write('Codelist=model_.CodelistType(\n')
            self.Codelist.exportLiteral(outfile, level, name_='Codelist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Category is not None:
            showIndent(outfile, level)
            outfile.write('Category=model_.CategoryType(\n')
            self.Category.exportLiteral(outfile, level, name_='Category')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concept is not None:
            showIndent(outfile, level)
            outfile.write('Concept=%s,\n' % quote_python(self.Concept).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily = KeyFamily_
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure = MetadataStructure_
        elif nodeName_ == 'StructureSet':
            StructureSet_ = child_.text
            StructureSet_ = self.gds_validate_string(StructureSet_, node, 'StructureSet')
            self.StructureSet = StructureSet_
        elif nodeName_ == 'Dimension':
            obj_ = DimensionType.factory()
            obj_.build(child_)
            self.Dimension = obj_
            obj_.original_tagname_ = 'Dimension'
        elif nodeName_ == 'StructureComponent':
            obj_ = StructureComponentType.factory()
            obj_.build(child_)
            self.StructureComponent = obj_
            obj_.original_tagname_ = 'StructureComponent'
        elif nodeName_ == 'Attribute':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.Attribute = obj_
            obj_.original_tagname_ = 'Attribute'
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist = obj_
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category = obj_
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept = Concept_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class MetadataStructureWhereType


class CodelistWhereType(GeneratedsSuper):
    """The CodelistWhere element representes a query for a codelist or
    codelists. It contains all of the clauses in that query,
    represented by its child elements. Values are the IDs of the
    referenced object."""
    subclass = None
    superclass = None
    def __init__(self, Codelist=None, AgencyID=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.Codelist = Codelist
        self.AgencyID = AgencyID
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if CodelistWhereType.subclass:
            return CodelistWhereType.subclass(*args_, **kwargs_)
        else:
            return CodelistWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.Codelist is not None or
            self.AgencyID is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CodelistWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CodelistWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CodelistWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CodelistWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CodelistWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Codelist is not None:
            self.Codelist.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CodelistWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Codelist is not None:
            showIndent(outfile, level)
            outfile.write('Codelist=model_.CodelistType(\n')
            self.Codelist.exportLiteral(outfile, level, name_='Codelist')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist = obj_
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class CodelistWhereType


class ConceptWhereType(GeneratedsSuper):
    """The ConceptWhere element representes a query for a concept or
    concepts. It contains all of the clauses in that query,
    represented by its child elements. Values are the IDs of the
    referenced object."""
    subclass = None
    superclass = None
    def __init__(self, Concept=None, AgencyID=None, Version=None, Or=None, And=None):
        self.original_tagname_ = None
        self.Concept = Concept
        self.AgencyID = AgencyID
        self.Version = Version
        self.Or = Or
        self.And = And
    def factory(*args_, **kwargs_):
        if ConceptWhereType.subclass:
            return ConceptWhereType.subclass(*args_, **kwargs_)
        else:
            return ConceptWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def hasContent_(self):
        if (
            self.Concept is not None or
            self.AgencyID is not None or
            self.Version is not None or
            self.Or is not None or
            self.And is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Concept is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(self.Concept).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
        if self.Or is not None:
            self.Or.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        if self.And is not None:
            self.And.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ConceptWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Concept is not None:
            showIndent(outfile, level)
            outfile.write('Concept=%s,\n' % quote_python(self.Concept).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
        if self.Or is not None:
            showIndent(outfile, level)
            outfile.write('Or=model_.OrType(\n')
            self.Or.exportLiteral(outfile, level, name_='Or')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.And is not None:
            showIndent(outfile, level)
            outfile.write('And=model_.AndType(\n')
            self.And.exportLiteral(outfile, level, name_='And')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept = Concept_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or = obj_
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And = obj_
            obj_.original_tagname_ = 'And'
# end class ConceptWhereType


class AgencyWhereType(GeneratedsSuper):
    """The AgencyWhere element representes a query for details for an
    Agency. It contains all of the clauses in that query,
    represented by its child elements. Values are the IDs of the
    referenced object."""
    subclass = None
    superclass = None
    def __init__(self, KeyFamily=None, MetadataStructure=None, StructureSet=None, Codelist=None, Category=None, Concept=None, AgencyID=None, Or=None, And=None):
        self.original_tagname_ = None
        if KeyFamily is None:
            self.KeyFamily = []
        else:
            self.KeyFamily = KeyFamily
        if MetadataStructure is None:
            self.MetadataStructure = []
        else:
            self.MetadataStructure = MetadataStructure
        if StructureSet is None:
            self.StructureSet = []
        else:
            self.StructureSet = StructureSet
        if Codelist is None:
            self.Codelist = []
        else:
            self.Codelist = Codelist
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        if AgencyID is None:
            self.AgencyID = []
        else:
            self.AgencyID = AgencyID
        if Or is None:
            self.Or = []
        else:
            self.Or = Or
        if And is None:
            self.And = []
        else:
            self.And = And
    def factory(*args_, **kwargs_):
        if AgencyWhereType.subclass:
            return AgencyWhereType.subclass(*args_, **kwargs_)
        else:
            return AgencyWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def add_KeyFamily(self, value): self.KeyFamily.append(value)
    def insert_KeyFamily_at(self, index, value): self.KeyFamily.insert(index, value)
    def replace_KeyFamily_at(self, index, value): self.KeyFamily[index] = value
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def add_MetadataStructure(self, value): self.MetadataStructure.append(value)
    def insert_MetadataStructure_at(self, index, value): self.MetadataStructure.insert(index, value)
    def replace_MetadataStructure_at(self, index, value): self.MetadataStructure[index] = value
    def get_StructureSet(self): return self.StructureSet
    def set_StructureSet(self, StructureSet): self.StructureSet = StructureSet
    def add_StructureSet(self, value): self.StructureSet.append(value)
    def insert_StructureSet_at(self, index, value): self.StructureSet.insert(index, value)
    def replace_StructureSet_at(self, index, value): self.StructureSet[index] = value
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def add_Codelist(self, value): self.Codelist.append(value)
    def insert_Codelist_at(self, index, value): self.Codelist.insert(index, value)
    def replace_Codelist_at(self, index, value): self.Codelist[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def add_AgencyID(self, value): self.AgencyID.append(value)
    def insert_AgencyID_at(self, index, value): self.AgencyID.insert(index, value)
    def replace_AgencyID_at(self, index, value): self.AgencyID[index] = value
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def add_Or(self, value): self.Or.append(value)
    def insert_Or_at(self, index, value): self.Or.insert(index, value)
    def replace_Or_at(self, index, value): self.Or[index] = value
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def add_And(self, value): self.And.append(value)
    def insert_And_at(self, index, value): self.And.insert(index, value)
    def replace_And_at(self, index, value): self.And[index] = value
    def hasContent_(self):
        if (
            self.KeyFamily or
            self.MetadataStructure or
            self.StructureSet or
            self.Codelist or
            self.Category or
            self.Concept or
            self.AgencyID or
            self.Or or
            self.And
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AgencyWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgencyWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AgencyWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AgencyWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AgencyWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamily_).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataStructure_).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        for StructureSet_ in self.StructureSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureSet>%s</%sStructureSet>%s' % (namespace_, self.gds_format_string(quote_xml(StructureSet_).encode(ExternalEncoding), input_name='StructureSet'), namespace_, eol_))
        for Codelist_ in self.Codelist:
            Codelist_.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Concept_ in self.Concept:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(Concept_).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(AgencyID_).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        for Or_ in self.Or:
            Or_.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        for And_ in self.And:
            And_.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AgencyWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('KeyFamily=[\n')
        level += 1
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamily_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructure=[\n')
        level += 1
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataStructure_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureSet=[\n')
        level += 1
        for StructureSet_ in self.StructureSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StructureSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Codelist=[\n')
        level += 1
        for Codelist_ in self.Codelist:
            showIndent(outfile, level)
            outfile.write('model_.CodelistType(\n')
            Codelist_.exportLiteral(outfile, level, name_='CodelistType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Concept_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AgencyID=[\n')
        level += 1
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Or=[\n')
        level += 1
        for Or_ in self.Or:
            showIndent(outfile, level)
            outfile.write('model_.OrType(\n')
            Or_.exportLiteral(outfile, level, name_='OrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('And=[\n')
        level += 1
        for And_ in self.And:
            showIndent(outfile, level)
            outfile.write('model_.AndType(\n')
            And_.exportLiteral(outfile, level, name_='AndType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily.append(KeyFamily_)
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure.append(MetadataStructure_)
        elif nodeName_ == 'StructureSet':
            StructureSet_ = child_.text
            StructureSet_ = self.gds_validate_string(StructureSet_, node, 'StructureSet')
            self.StructureSet.append(StructureSet_)
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist.append(obj_)
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept.append(Concept_)
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID.append(AgencyID_)
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or.append(obj_)
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And.append(obj_)
            obj_.original_tagname_ = 'And'
# end class AgencyWhereType


class DataProviderWhereType(GeneratedsSuper):
    """The DataProviderWhere element representes a query for details for a
    provider of data or metadata sets. It contains all of the
    clauses in that query, represented by its child elements. Values
    are the IDs of the referenced object."""
    subclass = None
    superclass = None
    def __init__(self, DataSet=None, MetadataSet=None, KeyFamily=None, MetadataStructure=None, StructureSet=None, Codelist=None, Category=None, Concept=None, AgencyID=None, Or=None, And=None):
        self.original_tagname_ = None
        if DataSet is None:
            self.DataSet = []
        else:
            self.DataSet = DataSet
        if MetadataSet is None:
            self.MetadataSet = []
        else:
            self.MetadataSet = MetadataSet
        if KeyFamily is None:
            self.KeyFamily = []
        else:
            self.KeyFamily = KeyFamily
        if MetadataStructure is None:
            self.MetadataStructure = []
        else:
            self.MetadataStructure = MetadataStructure
        if StructureSet is None:
            self.StructureSet = []
        else:
            self.StructureSet = StructureSet
        if Codelist is None:
            self.Codelist = []
        else:
            self.Codelist = Codelist
        if Category is None:
            self.Category = []
        else:
            self.Category = Category
        if Concept is None:
            self.Concept = []
        else:
            self.Concept = Concept
        if AgencyID is None:
            self.AgencyID = []
        else:
            self.AgencyID = AgencyID
        if Or is None:
            self.Or = []
        else:
            self.Or = Or
        if And is None:
            self.And = []
        else:
            self.And = And
    def factory(*args_, **kwargs_):
        if DataProviderWhereType.subclass:
            return DataProviderWhereType.subclass(*args_, **kwargs_)
        else:
            return DataProviderWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataSet(self): return self.DataSet
    def set_DataSet(self, DataSet): self.DataSet = DataSet
    def add_DataSet(self, value): self.DataSet.append(value)
    def insert_DataSet_at(self, index, value): self.DataSet.insert(index, value)
    def replace_DataSet_at(self, index, value): self.DataSet[index] = value
    def get_MetadataSet(self): return self.MetadataSet
    def set_MetadataSet(self, MetadataSet): self.MetadataSet = MetadataSet
    def add_MetadataSet(self, value): self.MetadataSet.append(value)
    def insert_MetadataSet_at(self, index, value): self.MetadataSet.insert(index, value)
    def replace_MetadataSet_at(self, index, value): self.MetadataSet[index] = value
    def get_KeyFamily(self): return self.KeyFamily
    def set_KeyFamily(self, KeyFamily): self.KeyFamily = KeyFamily
    def add_KeyFamily(self, value): self.KeyFamily.append(value)
    def insert_KeyFamily_at(self, index, value): self.KeyFamily.insert(index, value)
    def replace_KeyFamily_at(self, index, value): self.KeyFamily[index] = value
    def get_MetadataStructure(self): return self.MetadataStructure
    def set_MetadataStructure(self, MetadataStructure): self.MetadataStructure = MetadataStructure
    def add_MetadataStructure(self, value): self.MetadataStructure.append(value)
    def insert_MetadataStructure_at(self, index, value): self.MetadataStructure.insert(index, value)
    def replace_MetadataStructure_at(self, index, value): self.MetadataStructure[index] = value
    def get_StructureSet(self): return self.StructureSet
    def set_StructureSet(self, StructureSet): self.StructureSet = StructureSet
    def add_StructureSet(self, value): self.StructureSet.append(value)
    def insert_StructureSet_at(self, index, value): self.StructureSet.insert(index, value)
    def replace_StructureSet_at(self, index, value): self.StructureSet[index] = value
    def get_Codelist(self): return self.Codelist
    def set_Codelist(self, Codelist): self.Codelist = Codelist
    def add_Codelist(self, value): self.Codelist.append(value)
    def insert_Codelist_at(self, index, value): self.Codelist.insert(index, value)
    def replace_Codelist_at(self, index, value): self.Codelist[index] = value
    def get_Category(self): return self.Category
    def set_Category(self, Category): self.Category = Category
    def add_Category(self, value): self.Category.append(value)
    def insert_Category_at(self, index, value): self.Category.insert(index, value)
    def replace_Category_at(self, index, value): self.Category[index] = value
    def get_Concept(self): return self.Concept
    def set_Concept(self, Concept): self.Concept = Concept
    def add_Concept(self, value): self.Concept.append(value)
    def insert_Concept_at(self, index, value): self.Concept.insert(index, value)
    def replace_Concept_at(self, index, value): self.Concept[index] = value
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def add_AgencyID(self, value): self.AgencyID.append(value)
    def insert_AgencyID_at(self, index, value): self.AgencyID.insert(index, value)
    def replace_AgencyID_at(self, index, value): self.AgencyID[index] = value
    def get_Or(self): return self.Or
    def set_Or(self, Or): self.Or = Or
    def add_Or(self, value): self.Or.append(value)
    def insert_Or_at(self, index, value): self.Or.insert(index, value)
    def replace_Or_at(self, index, value): self.Or[index] = value
    def get_And(self): return self.And
    def set_And(self, And): self.And = And
    def add_And(self, value): self.And.append(value)
    def insert_And_at(self, index, value): self.And.insert(index, value)
    def replace_And_at(self, index, value): self.And[index] = value
    def hasContent_(self):
        if (
            self.DataSet or
            self.MetadataSet or
            self.KeyFamily or
            self.MetadataStructure or
            self.StructureSet or
            self.Codelist or
            self.Category or
            self.Concept or
            self.AgencyID or
            self.Or or
            self.And
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataProviderWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataProviderWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataProviderWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataProviderWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataProviderWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for DataSet_ in self.DataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataSet>%s</%sDataSet>%s' % (namespace_, self.gds_format_string(quote_xml(DataSet_).encode(ExternalEncoding), input_name='DataSet'), namespace_, eol_))
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataSet>%s</%sMetadataSet>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataSet_).encode(ExternalEncoding), input_name='MetadataSet'), namespace_, eol_))
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamily>%s</%sKeyFamily>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamily_).encode(ExternalEncoding), input_name='KeyFamily'), namespace_, eol_))
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructure>%s</%sMetadataStructure>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataStructure_).encode(ExternalEncoding), input_name='MetadataStructure'), namespace_, eol_))
        for StructureSet_ in self.StructureSet:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureSet>%s</%sStructureSet>%s' % (namespace_, self.gds_format_string(quote_xml(StructureSet_).encode(ExternalEncoding), input_name='StructureSet'), namespace_, eol_))
        for Codelist_ in self.Codelist:
            Codelist_.export(outfile, level, namespace_, name_='Codelist', pretty_print=pretty_print)
        for Category_ in self.Category:
            Category_.export(outfile, level, namespace_, name_='Category', pretty_print=pretty_print)
        for Concept_ in self.Concept:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConcept>%s</%sConcept>%s' % (namespace_, self.gds_format_string(quote_xml(Concept_).encode(ExternalEncoding), input_name='Concept'), namespace_, eol_))
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(AgencyID_).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        for Or_ in self.Or:
            Or_.export(outfile, level, namespace_, name_='Or', pretty_print=pretty_print)
        for And_ in self.And:
            And_.export(outfile, level, namespace_, name_='And', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DataProviderWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('DataSet=[\n')
        level += 1
        for DataSet_ in self.DataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataSet=[\n')
        level += 1
        for MetadataSet_ in self.MetadataSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamily=[\n')
        level += 1
        for KeyFamily_ in self.KeyFamily:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamily_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructure=[\n')
        level += 1
        for MetadataStructure_ in self.MetadataStructure:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataStructure_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureSet=[\n')
        level += 1
        for StructureSet_ in self.StructureSet:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StructureSet_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Codelist=[\n')
        level += 1
        for Codelist_ in self.Codelist:
            showIndent(outfile, level)
            outfile.write('model_.CodelistType(\n')
            Codelist_.exportLiteral(outfile, level, name_='CodelistType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Category=[\n')
        level += 1
        for Category_ in self.Category:
            showIndent(outfile, level)
            outfile.write('model_.CategoryType(\n')
            Category_.exportLiteral(outfile, level, name_='CategoryType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Concept=[\n')
        level += 1
        for Concept_ in self.Concept:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(Concept_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AgencyID=[\n')
        level += 1
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Or=[\n')
        level += 1
        for Or_ in self.Or:
            showIndent(outfile, level)
            outfile.write('model_.OrType(\n')
            Or_.exportLiteral(outfile, level, name_='OrType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('And=[\n')
        level += 1
        for And_ in self.And:
            showIndent(outfile, level)
            outfile.write('model_.AndType(\n')
            And_.exportLiteral(outfile, level, name_='AndType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataSet':
            DataSet_ = child_.text
            DataSet_ = self.gds_validate_string(DataSet_, node, 'DataSet')
            self.DataSet.append(DataSet_)
        elif nodeName_ == 'MetadataSet':
            MetadataSet_ = child_.text
            MetadataSet_ = self.gds_validate_string(MetadataSet_, node, 'MetadataSet')
            self.MetadataSet.append(MetadataSet_)
        elif nodeName_ == 'KeyFamily':
            KeyFamily_ = child_.text
            KeyFamily_ = self.gds_validate_string(KeyFamily_, node, 'KeyFamily')
            self.KeyFamily.append(KeyFamily_)
        elif nodeName_ == 'MetadataStructure':
            MetadataStructure_ = child_.text
            MetadataStructure_ = self.gds_validate_string(MetadataStructure_, node, 'MetadataStructure')
            self.MetadataStructure.append(MetadataStructure_)
        elif nodeName_ == 'StructureSet':
            StructureSet_ = child_.text
            StructureSet_ = self.gds_validate_string(StructureSet_, node, 'StructureSet')
            self.StructureSet.append(StructureSet_)
        elif nodeName_ == 'Codelist':
            obj_ = CodelistType.factory()
            obj_.build(child_)
            self.Codelist.append(obj_)
            obj_.original_tagname_ = 'Codelist'
        elif nodeName_ == 'Category':
            obj_ = CategoryType.factory()
            obj_.build(child_)
            self.Category.append(obj_)
            obj_.original_tagname_ = 'Category'
        elif nodeName_ == 'Concept':
            Concept_ = child_.text
            Concept_ = self.gds_validate_string(Concept_, node, 'Concept')
            self.Concept.append(Concept_)
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID.append(AgencyID_)
        elif nodeName_ == 'Or':
            obj_ = OrType.factory()
            obj_.build(child_)
            self.Or.append(obj_)
            obj_.original_tagname_ = 'Or'
        elif nodeName_ == 'And':
            obj_ = AndType.factory()
            obj_.build(child_)
            self.And.append(obj_)
            obj_.original_tagname_ = 'And'
# end class DataProviderWhereType


class TimeType(GeneratedsSuper):
    """TimeType contains the time point or period for which results should
    be supplied. When StartTime and EndTime are used, these must be
    understood as inclusive."""
    subclass = None
    superclass = None
    def __init__(self, StartTime=None, EndTime=None, Time=None):
        self.original_tagname_ = None
        self.StartTime = StartTime
        self.EndTime = EndTime
        self.Time = Time
    def factory(*args_, **kwargs_):
        if TimeType.subclass:
            return TimeType.subclass(*args_, **kwargs_)
        else:
            return TimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_EndTime(self): return self.EndTime
    def set_EndTime(self, EndTime): self.EndTime = EndTime
    def get_Time(self): return self.Time
    def set_Time(self, Time): self.Time = Time
    def validate_TimePeriodType(self, value):
        # Validate type TimePeriodType, a restriction on None.
        pass
    def hasContent_(self):
        if (
            self.StartTime is not None or
            self.EndTime is not None or
            self.Time is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TimeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TimeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TimeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TimeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='TimeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.StartTime).encode(ExternalEncoding), input_name='StartTime'), namespace_, eol_))
        if self.EndTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndTime>%s</%sEndTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.EndTime).encode(ExternalEncoding), input_name='EndTime'), namespace_, eol_))
        if self.Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTime>%s</%sTime>%s' % (namespace_, self.gds_format_string(quote_xml(self.Time).encode(ExternalEncoding), input_name='Time'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='TimeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=%s,\n' % quote_python(self.StartTime).encode(ExternalEncoding))
        if self.EndTime is not None:
            showIndent(outfile, level)
            outfile.write('EndTime=%s,\n' % quote_python(self.EndTime).encode(ExternalEncoding))
        if self.Time is not None:
            showIndent(outfile, level)
            outfile.write('Time=%s,\n' % quote_python(self.Time).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartTime':
            StartTime_ = child_.text
            StartTime_ = self.gds_validate_string(StartTime_, node, 'StartTime')
            self.StartTime = StartTime_
            self.validate_TimePeriodType(self.StartTime)    # validate type TimePeriodType
        elif nodeName_ == 'EndTime':
            EndTime_ = child_.text
            EndTime_ = self.gds_validate_string(EndTime_, node, 'EndTime')
            self.EndTime = EndTime_
            self.validate_TimePeriodType(self.EndTime)    # validate type TimePeriodType
        elif nodeName_ == 'Time':
            Time_ = child_.text
            Time_ = self.gds_validate_string(Time_, node, 'Time')
            self.Time = Time_
            self.validate_TimePeriodType(self.Time)    # validate type TimePeriodType
# end class TimeType


class StructureSetWhereType(GeneratedsSuper):
    """The StructureSetWhere element represents a query for a structure set
    or structure sets. Like other maintainable objects, it must be
    queried for using information about its agency, ID, and/or
    version. Any field not supplied will be taken as matching all of
    that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if StructureSetWhereType.subclass:
            return StructureSetWhereType.subclass(*args_, **kwargs_)
        else:
            return StructureSetWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureSetWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureSetWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureSetWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureSetWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureSetWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='StructureSetWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class StructureSetWhereType


class HierarchicalCodelistWhereType(GeneratedsSuper):
    """The HierarchicalCodelistWhere element represents a query for a
    hierarchical codelist or codelists. Like other maintainable
    objects, it must be queried for using information about its
    agency, ID, and/or version. Any field not supplied will be taken
    as matching all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if HierarchicalCodelistWhereType.subclass:
            return HierarchicalCodelistWhereType.subclass(*args_, **kwargs_)
        else:
            return HierarchicalCodelistWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HierarchicalCodelistWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='HierarchicalCodelistWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='HierarchicalCodelistWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='HierarchicalCodelistWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HierarchicalCodelistWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class HierarchicalCodelistWhereType


class ReportingTaxonomyWhereType(GeneratedsSuper):
    """The ReportingTaxonomyWhere element represents a query for a
    reporting taxonomy or taxonomies. Like other maintainable
    objects, it must be queried for using information about its
    agency, ID, and/or version. Any field not supplied will be taken
    as matching all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ReportingTaxonomyWhereType.subclass:
            return ReportingTaxonomyWhereType.subclass(*args_, **kwargs_)
        else:
            return ReportingTaxonomyWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingTaxonomyWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportingTaxonomyWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportingTaxonomyWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReportingTaxonomyWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ReportingTaxonomyWhereType


class DataflowWhereType(GeneratedsSuper):
    """The DataflowWhereType element represents a query for a dataflow or
    dataflows. Like other maintainable objects, it must be queried
    for using information about its agency, ID, and/or version. Any
    field not supplied will be taken as matching all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if DataflowWhereType.subclass:
            return DataflowWhereType.subclass(*args_, **kwargs_)
        else:
            return DataflowWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataflowWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataflowWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataflowWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataflowWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataflowWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DataflowWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class DataflowWhereType


class MetadataflowWhereType(GeneratedsSuper):
    """The MetadataflowWhereType element represents a query for a
    metadataflow or metadataflows. Like other maintainable objects,
    it must be queried for using information about its agency, ID,
    and/or version. Any field not supplied will be taken as matching
    all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if MetadataflowWhereType.subclass:
            return MetadataflowWhereType.subclass(*args_, **kwargs_)
        else:
            return MetadataflowWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataflowWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataflowWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataflowWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataflowWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataflowWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataflowWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class MetadataflowWhereType


class ProcessWhereType(GeneratedsSuper):
    """The ProcessWhere element represents a query for a process or
    processes. Like other maintainable objects, it must be queried
    for using information about its agency, ID, and/or version. Any
    field not supplied will be taken as matching all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ProcessWhereType.subclass:
            return ProcessWhereType.subclass(*args_, **kwargs_)
        else:
            return ProcessWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProcessWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProcessWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProcessWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProcessWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ProcessWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ProcessWhereType


class OrganisationSchemeWhereType(GeneratedsSuper):
    """The OrganisationSchemeWhere element represents a query for an
    organisation scheme or schemes. Like other maintainable objects,
    it must be queried for using information about its agency, ID,
    and/or version. Any field not supplied will be taken as matching
    all of that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if OrganisationSchemeWhereType.subclass:
            return OrganisationSchemeWhereType.subclass(*args_, **kwargs_)
        else:
            return OrganisationSchemeWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='OrganisationSchemeWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OrganisationSchemeWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='OrganisationSchemeWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='OrganisationSchemeWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='OrganisationSchemeWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OrganisationSchemeWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class OrganisationSchemeWhereType


class ConceptSchemeWhereType(GeneratedsSuper):
    """The ConceptSchemeWhere element represents a query for a concept
    scheme or schemes. Like other maintainable objects, it must be
    queried for using information about its agency, ID, and/or
    version. Any field not supplied will be taken as matching all of
    that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ConceptSchemeWhereType.subclass:
            return ConceptSchemeWhereType.subclass(*args_, **kwargs_)
        else:
            return ConceptSchemeWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ConceptSchemeWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConceptSchemeWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ConceptSchemeWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ConceptSchemeWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ConceptSchemeWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ConceptSchemeWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ConceptSchemeWhereType


class CategorySchemeWhereType(GeneratedsSuper):
    """The CategorySchemeWhere element represents a query for a category
    scheme or schemes. Like other maintainable objects, it must be
    queried for using information about its agency, ID, and/or
    version. Any field not supplied will be taken as matching all of
    that type."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, ID=None, Version=None):
        self.original_tagname_ = None
        self.AgencyID = AgencyID
        self.ID = ID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if CategorySchemeWhereType.subclass:
            return CategorySchemeWhereType.subclass(*args_, **kwargs_)
        else:
            return CategorySchemeWhereType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def hasContent_(self):
        if (
            self.AgencyID is not None or
            self.ID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='CategorySchemeWhereType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CategorySchemeWhereType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='CategorySchemeWhereType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='CategorySchemeWhereType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='CategorySchemeWhereType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CategorySchemeWhereType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class CategorySchemeWhereType


class SubmitSubscriptionRequestType(GeneratedsSuper):
    """The SubmitSubscriptionRequest element is submitted to the registry
    to subscribe to registration and change events for specific
    registry resources."""
    subclass = None
    superclass = None
    def __init__(self, Subscription=None):
        self.original_tagname_ = None
        if Subscription is None:
            self.Subscription = []
        else:
            self.Subscription = Subscription
    def factory(*args_, **kwargs_):
        if SubmitSubscriptionRequestType.subclass:
            return SubmitSubscriptionRequestType.subclass(*args_, **kwargs_)
        else:
            return SubmitSubscriptionRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Subscription(self): return self.Subscription
    def set_Subscription(self, Subscription): self.Subscription = Subscription
    def add_Subscription(self, value): self.Subscription.append(value)
    def insert_Subscription_at(self, index, value): self.Subscription.insert(index, value)
    def replace_Subscription_at(self, index, value): self.Subscription[index] = value
    def hasContent_(self):
        if (
            self.Subscription
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitSubscriptionRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitSubscriptionRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitSubscriptionRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitSubscriptionRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitSubscriptionRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Subscription_ in self.Subscription:
            Subscription_.export(outfile, level, namespace_, name_='Subscription', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitSubscriptionRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Subscription=[\n')
        level += 1
        for Subscription_ in self.Subscription:
            showIndent(outfile, level)
            outfile.write('model_.SubscriptionType(\n')
            Subscription_.exportLiteral(outfile, level, name_='SubscriptionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Subscription':
            obj_ = SubscriptionType.factory()
            obj_.build(child_)
            self.Subscription.append(obj_)
            obj_.original_tagname_ = 'Subscription'
# end class SubmitSubscriptionRequestType


class SubmitSubscriptionResponseType(GeneratedsSuper):
    """The SubmitSubscriptionResponse element contains information which
    describes the success or failure of a Subscription, providing
    any error messages in the event of failure. It also returns the
    registry URN of the subscription, and the subscriber-assigned
    ID."""
    subclass = None
    superclass = None
    def __init__(self, SubscriptionURN=None, SubscriberAssignedID=None, SubscriptionStatus=None):
        self.original_tagname_ = None
        self.SubscriptionURN = SubscriptionURN
        self.SubscriberAssignedID = SubscriberAssignedID
        self.SubscriptionStatus = SubscriptionStatus
    def factory(*args_, **kwargs_):
        if SubmitSubscriptionResponseType.subclass:
            return SubmitSubscriptionResponseType.subclass(*args_, **kwargs_)
        else:
            return SubmitSubscriptionResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubscriptionURN(self): return self.SubscriptionURN
    def set_SubscriptionURN(self, SubscriptionURN): self.SubscriptionURN = SubscriptionURN
    def get_SubscriberAssignedID(self): return self.SubscriberAssignedID
    def set_SubscriberAssignedID(self, SubscriberAssignedID): self.SubscriberAssignedID = SubscriberAssignedID
    def get_SubscriptionStatus(self): return self.SubscriptionStatus
    def set_SubscriptionStatus(self, SubscriptionStatus): self.SubscriptionStatus = SubscriptionStatus
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.SubscriptionURN is not None or
            self.SubscriberAssignedID is not None or
            self.SubscriptionStatus is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitSubscriptionResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitSubscriptionResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitSubscriptionResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitSubscriptionResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitSubscriptionResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubscriptionURN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubscriptionURN>%s</%sSubscriptionURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubscriptionURN).encode(ExternalEncoding), input_name='SubscriptionURN'), namespace_, eol_))
        if self.SubscriberAssignedID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubscriberAssignedID>%s</%sSubscriberAssignedID>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubscriberAssignedID).encode(ExternalEncoding), input_name='SubscriberAssignedID'), namespace_, eol_))
        if self.SubscriptionStatus is not None:
            self.SubscriptionStatus.export(outfile, level, namespace_, name_='SubscriptionStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitSubscriptionResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SubscriptionURN is not None:
            showIndent(outfile, level)
            outfile.write('SubscriptionURN=%s,\n' % quote_python(self.SubscriptionURN).encode(ExternalEncoding))
        if self.SubscriberAssignedID is not None:
            showIndent(outfile, level)
            outfile.write('SubscriberAssignedID=%s,\n' % quote_python(self.SubscriberAssignedID).encode(ExternalEncoding))
        if self.SubscriptionStatus is not None:
            showIndent(outfile, level)
            outfile.write('SubscriptionStatus=model_.StatusMessageType(\n')
            self.SubscriptionStatus.exportLiteral(outfile, level, name_='SubscriptionStatus')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubscriptionURN':
            SubscriptionURN_ = child_.text
            SubscriptionURN_ = self.gds_validate_string(SubscriptionURN_, node, 'SubscriptionURN')
            self.SubscriptionURN = SubscriptionURN_
        elif nodeName_ == 'SubscriberAssignedID':
            SubscriberAssignedID_ = child_.text
            SubscriberAssignedID_ = self.gds_validate_string(SubscriberAssignedID_, node, 'SubscriberAssignedID')
            self.SubscriberAssignedID = SubscriberAssignedID_
            self.validate_IDType(self.SubscriberAssignedID)    # validate type IDType
        elif nodeName_ == 'SubscriptionStatus':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.SubscriptionStatus = obj_
            obj_.original_tagname_ = 'SubscriptionStatus'
# end class SubmitSubscriptionResponseType


class NotifyRegistryEventType(GeneratedsSuper):
    """The NotifyRegistryEvent element is sent by the registry services to
    subscribers, to notify them of specific registration and change
    events. EventTime specifies the time of the triggering event.
    ObjectURN provides the URN of the object on which the event
    occurred. SubscriptionURN provides the registry/repository URN
    of the subscription. EventAction indicates the nature of the
    event - whether the action was an addition, a modification, or a
    deletion."""
    subclass = None
    superclass = None
    def __init__(self, EventTime=None, ObjectURN=None, SubscriptionURN=None, EventAction=None, StructuralEvent=None, ProvisioningEvent=None, RegistrationEvent=None):
        self.original_tagname_ = None
        if isinstance(EventTime, basestring):
            initvalue_ = datetime_.datetime.strptime(EventTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = EventTime
        self.EventTime = initvalue_
        self.ObjectURN = ObjectURN
        self.SubscriptionURN = SubscriptionURN
        self.EventAction = EventAction
        self.StructuralEvent = StructuralEvent
        self.ProvisioningEvent = ProvisioningEvent
        self.RegistrationEvent = RegistrationEvent
    def factory(*args_, **kwargs_):
        if NotifyRegistryEventType.subclass:
            return NotifyRegistryEventType.subclass(*args_, **kwargs_)
        else:
            return NotifyRegistryEventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EventTime(self): return self.EventTime
    def set_EventTime(self, EventTime): self.EventTime = EventTime
    def get_ObjectURN(self): return self.ObjectURN
    def set_ObjectURN(self, ObjectURN): self.ObjectURN = ObjectURN
    def get_SubscriptionURN(self): return self.SubscriptionURN
    def set_SubscriptionURN(self, SubscriptionURN): self.SubscriptionURN = SubscriptionURN
    def get_EventAction(self): return self.EventAction
    def set_EventAction(self, EventAction): self.EventAction = EventAction
    def get_StructuralEvent(self): return self.StructuralEvent
    def set_StructuralEvent(self, StructuralEvent): self.StructuralEvent = StructuralEvent
    def get_ProvisioningEvent(self): return self.ProvisioningEvent
    def set_ProvisioningEvent(self, ProvisioningEvent): self.ProvisioningEvent = ProvisioningEvent
    def get_RegistrationEvent(self): return self.RegistrationEvent
    def set_RegistrationEvent(self, RegistrationEvent): self.RegistrationEvent = RegistrationEvent
    def validate_ActionType(self, value):
        # Validate type ActionType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.EventTime is not None or
            self.ObjectURN is not None or
            self.SubscriptionURN is not None or
            self.EventAction is not None or
            self.StructuralEvent is not None or
            self.ProvisioningEvent is not None or
            self.RegistrationEvent is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='NotifyRegistryEventType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NotifyRegistryEventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='NotifyRegistryEventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='NotifyRegistryEventType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='NotifyRegistryEventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.EventTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEventTime>%s</%sEventTime>%s' % (namespace_, self.gds_format_datetime(self.EventTime, input_name='EventTime'), namespace_, eol_))
        if self.ObjectURN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sObjectURN>%s</%sObjectURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.ObjectURN).encode(ExternalEncoding), input_name='ObjectURN'), namespace_, eol_))
        if self.SubscriptionURN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubscriptionURN>%s</%sSubscriptionURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubscriptionURN).encode(ExternalEncoding), input_name='SubscriptionURN'), namespace_, eol_))
        if self.EventAction is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEventAction>%s</%sEventAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.EventAction).encode(ExternalEncoding), input_name='EventAction'), namespace_, eol_))
        if self.StructuralEvent is not None:
            self.StructuralEvent.export(outfile, level, namespace_, name_='StructuralEvent', pretty_print=pretty_print)
        if self.ProvisioningEvent is not None:
            self.ProvisioningEvent.export(outfile, level, namespace_, name_='ProvisioningEvent', pretty_print=pretty_print)
        if self.RegistrationEvent is not None:
            self.RegistrationEvent.export(outfile, level, namespace_, name_='RegistrationEvent', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='NotifyRegistryEventType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.EventTime is not None:
            showIndent(outfile, level)
            outfile.write('EventTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.EventTime, input_name='EventTime'))
        if self.ObjectURN is not None:
            showIndent(outfile, level)
            outfile.write('ObjectURN=%s,\n' % quote_python(self.ObjectURN).encode(ExternalEncoding))
        if self.SubscriptionURN is not None:
            showIndent(outfile, level)
            outfile.write('SubscriptionURN=%s,\n' % quote_python(self.SubscriptionURN).encode(ExternalEncoding))
        if self.EventAction is not None:
            showIndent(outfile, level)
            outfile.write('EventAction=%s,\n' % quote_python(self.EventAction).encode(ExternalEncoding))
        if self.StructuralEvent is not None:
            showIndent(outfile, level)
            outfile.write('StructuralEvent=model_.StructuralEventType(\n')
            self.StructuralEvent.exportLiteral(outfile, level, name_='StructuralEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisioningEvent is not None:
            showIndent(outfile, level)
            outfile.write('ProvisioningEvent=model_.ProvisioningEventType(\n')
            self.ProvisioningEvent.exportLiteral(outfile, level, name_='ProvisioningEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RegistrationEvent is not None:
            showIndent(outfile, level)
            outfile.write('RegistrationEvent=model_.RegistrationEventType(\n')
            self.RegistrationEvent.exportLiteral(outfile, level, name_='RegistrationEvent')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EventTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.EventTime = dval_
        elif nodeName_ == 'ObjectURN':
            ObjectURN_ = child_.text
            ObjectURN_ = self.gds_validate_string(ObjectURN_, node, 'ObjectURN')
            self.ObjectURN = ObjectURN_
        elif nodeName_ == 'SubscriptionURN':
            SubscriptionURN_ = child_.text
            SubscriptionURN_ = self.gds_validate_string(SubscriptionURN_, node, 'SubscriptionURN')
            self.SubscriptionURN = SubscriptionURN_
        elif nodeName_ == 'EventAction':
            EventAction_ = child_.text
            EventAction_ = self.gds_validate_string(EventAction_, node, 'EventAction')
            self.EventAction = EventAction_
            self.validate_ActionType(self.EventAction)    # validate type ActionType
        elif nodeName_ == 'StructuralEvent':
            obj_ = StructuralEventType.factory()
            obj_.build(child_)
            self.StructuralEvent = obj_
            obj_.original_tagname_ = 'StructuralEvent'
        elif nodeName_ == 'ProvisioningEvent':
            obj_ = ProvisioningEventType.factory()
            obj_.build(child_)
            self.ProvisioningEvent = obj_
            obj_.original_tagname_ = 'ProvisioningEvent'
        elif nodeName_ == 'RegistrationEvent':
            obj_ = RegistrationEventType.factory()
            obj_.build(child_)
            self.RegistrationEvent = obj_
            obj_.original_tagname_ = 'RegistrationEvent'
# end class NotifyRegistryEventType


class SubmitRegistrationRequestType(GeneratedsSuper):
    """SubmitRegistrationRequest is sent to the registry by an agency or
    data/metadata provider to request registration for a data set or
    metadata set. The resource to be registered must be accessible
    to the registry services at an indicated URL, so that it can be
    processed by those services. This is the datasource, which may
    also have been specified for the data provider or provision
    agreement, in which case it need not appear here. Constraints
    describing the content and release calendar of the registered
    dataset (and, for metadata sets, the release calendar) may also
    be included."""
    subclass = None
    superclass = None
    def __init__(self, Registration=None):
        self.original_tagname_ = None
        if Registration is None:
            self.Registration = []
        else:
            self.Registration = Registration
    def factory(*args_, **kwargs_):
        if SubmitRegistrationRequestType.subclass:
            return SubmitRegistrationRequestType.subclass(*args_, **kwargs_)
        else:
            return SubmitRegistrationRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Registration(self): return self.Registration
    def set_Registration(self, Registration): self.Registration = Registration
    def add_Registration(self, value): self.Registration.append(value)
    def insert_Registration_at(self, index, value): self.Registration.insert(index, value)
    def replace_Registration_at(self, index, value): self.Registration[index] = value
    def hasContent_(self):
        if (
            self.Registration
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitRegistrationRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitRegistrationRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitRegistrationRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitRegistrationRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitRegistrationRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Registration_ in self.Registration:
            Registration_.export(outfile, level, namespace_, name_='Registration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitRegistrationRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Registration=[\n')
        level += 1
        for Registration_ in self.Registration:
            showIndent(outfile, level)
            outfile.write('model_.RegistrationType(\n')
            Registration_.exportLiteral(outfile, level, name_='RegistrationType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Registration':
            obj_ = RegistrationType.factory()
            obj_.build(child_)
            self.Registration.append(obj_)
            obj_.original_tagname_ = 'Registration'
# end class SubmitRegistrationRequestType


class SubmitRegistrationResponseType(GeneratedsSuper):
    """This document is sent to the agency or data/metadata provider in
    response to a registration request. It indicates the success or
    failure of the registration request, and contains any error
    messages generated by the registration service."""
    subclass = None
    superclass = None
    def __init__(self, RegistrationStatus=None):
        self.original_tagname_ = None
        if RegistrationStatus is None:
            self.RegistrationStatus = []
        else:
            self.RegistrationStatus = RegistrationStatus
    def factory(*args_, **kwargs_):
        if SubmitRegistrationResponseType.subclass:
            return SubmitRegistrationResponseType.subclass(*args_, **kwargs_)
        else:
            return SubmitRegistrationResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RegistrationStatus(self): return self.RegistrationStatus
    def set_RegistrationStatus(self, RegistrationStatus): self.RegistrationStatus = RegistrationStatus
    def add_RegistrationStatus(self, value): self.RegistrationStatus.append(value)
    def insert_RegistrationStatus_at(self, index, value): self.RegistrationStatus.insert(index, value)
    def replace_RegistrationStatus_at(self, index, value): self.RegistrationStatus[index] = value
    def hasContent_(self):
        if (
            self.RegistrationStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitRegistrationResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitRegistrationResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitRegistrationResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitRegistrationResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitRegistrationResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RegistrationStatus_ in self.RegistrationStatus:
            RegistrationStatus_.export(outfile, level, namespace_, name_='RegistrationStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitRegistrationResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RegistrationStatus=[\n')
        level += 1
        for RegistrationStatus_ in self.RegistrationStatus:
            showIndent(outfile, level)
            outfile.write('model_.RegistrationStatusType(\n')
            RegistrationStatus_.exportLiteral(outfile, level, name_='RegistrationStatusType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RegistrationStatus':
            obj_ = RegistrationStatusType.factory()
            obj_.build(child_)
            self.RegistrationStatus.append(obj_)
            obj_.original_tagname_ = 'RegistrationStatus'
# end class SubmitRegistrationResponseType


class QueryRegistrationRequestType(GeneratedsSuper):
    """The QueryRegistrationRequest is used to query the contents of a
    registry for data sets and metadata sets. The
    QueryRegistrationRequest specifies whether the result set should
    include metadata sets, data sets, or both with the QueryType
    element. The constraints which characterize the search -
    including reference period, are contained in teh Constraints
    within the child object references."""
    subclass = None
    superclass = None
    def __init__(self, QueryType=None, ProvisionAgreementRef=None, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None):
        self.original_tagname_ = None
        self.QueryType = QueryType
        self.ProvisionAgreementRef = ProvisionAgreementRef
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.DataProviderRef = DataProviderRef
    def factory(*args_, **kwargs_):
        if QueryRegistrationRequestType.subclass:
            return QueryRegistrationRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryRegistrationRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QueryType(self): return self.QueryType
    def set_QueryType(self, QueryType): self.QueryType = QueryType
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def validate_QueryTypeType(self, value):
        # Validate type QueryTypeType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.QueryType is not None or
            self.ProvisionAgreementRef is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.DataProviderRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryRegistrationRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryRegistrationRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryRegistrationRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryRegistrationRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryRegistrationRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.QueryType is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQueryType>%s</%sQueryType>%s' % (namespace_, self.gds_format_string(quote_xml(self.QueryType).encode(ExternalEncoding), input_name='QueryType'), namespace_, eol_))
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryRegistrationRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.QueryType is not None:
            showIndent(outfile, level)
            outfile.write('QueryType=%s,\n' % quote_python(self.QueryType).encode(ExternalEncoding))
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QueryType':
            QueryType_ = child_.text
            QueryType_ = self.gds_validate_string(QueryType_, node, 'QueryType')
            self.QueryType = QueryType_
            self.validate_QueryTypeType(self.QueryType)    # validate type QueryTypeType
        elif nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
# end class QueryRegistrationRequestType


class QueryRegistrationResponseType(GeneratedsSuper):
    """The QueryRegistrationResponse is sent as a response document to
    anyone querying the contents of a registry. The results set
    contains a set of links to data and/or metadata If the result
    set is null, or there is some other problem with the query, then
    appropriate error messages and statuses will be returned."""
    subclass = None
    superclass = None
    def __init__(self, QueryResult=None):
        self.original_tagname_ = None
        if QueryResult is None:
            self.QueryResult = []
        else:
            self.QueryResult = QueryResult
    def factory(*args_, **kwargs_):
        if QueryRegistrationResponseType.subclass:
            return QueryRegistrationResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryRegistrationResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_QueryResult(self): return self.QueryResult
    def set_QueryResult(self, QueryResult): self.QueryResult = QueryResult
    def add_QueryResult(self, value): self.QueryResult.append(value)
    def insert_QueryResult_at(self, index, value): self.QueryResult.insert(index, value)
    def replace_QueryResult_at(self, index, value): self.QueryResult[index] = value
    def hasContent_(self):
        if (
            self.QueryResult
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryRegistrationResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryRegistrationResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryRegistrationResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryRegistrationResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryRegistrationResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for QueryResult_ in self.QueryResult:
            QueryResult_.export(outfile, level, namespace_, name_='QueryResult', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryRegistrationResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('QueryResult=[\n')
        level += 1
        for QueryResult_ in self.QueryResult:
            showIndent(outfile, level)
            outfile.write('model_.QueryResultType(\n')
            QueryResult_.exportLiteral(outfile, level, name_='QueryResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'QueryResult':
            obj_ = QueryResultType.factory()
            obj_.build(child_)
            self.QueryResult.append(obj_)
            obj_.original_tagname_ = 'QueryResult'
# end class QueryRegistrationResponseType


class SubmitStructureRequestType(GeneratedsSuper):
    """SubmitStructureRequest is used to submit structure definitions - key
    families, metadata structures - to the repository. The structure
    resources (key families, agencies, concepts and concept schemes,
    codelists,etc.) to be submitted must be available as valid SDMX-
    ML Structure messages external to the registry, so that they can
    be retrieved by the repository submission service. A
    SubmitStructureResponse will be sent in response, and will
    indicate status and contain anyt relevant error information.
    StructureLocation holds the URL of the valid Structure Message.
    Alternately, the Structure element can contain the structural
    descriptions. The SubmittedStructureType contains a reference to
    one of the structural maintainable artefacts detailed in the
    Structure Message, which is to be submitted to the repository.
    It does not need to be used when the structures being submitted
    are included in the request message, or when all objects in the
    referenced SDMX-ML Structure message are to submitted."""
    subclass = None
    superclass = None
    def __init__(self, StructureLocation=None, Structure=None, SubmittedStructure=None):
        self.original_tagname_ = None
        self.StructureLocation = StructureLocation
        self.Structure = Structure
        if SubmittedStructure is None:
            self.SubmittedStructure = []
        else:
            self.SubmittedStructure = SubmittedStructure
    def factory(*args_, **kwargs_):
        if SubmitStructureRequestType.subclass:
            return SubmitStructureRequestType.subclass(*args_, **kwargs_)
        else:
            return SubmitStructureRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StructureLocation(self): return self.StructureLocation
    def set_StructureLocation(self, StructureLocation): self.StructureLocation = StructureLocation
    def get_Structure(self): return self.Structure
    def set_Structure(self, Structure): self.Structure = Structure
    def get_SubmittedStructure(self): return self.SubmittedStructure
    def set_SubmittedStructure(self, SubmittedStructure): self.SubmittedStructure = SubmittedStructure
    def add_SubmittedStructure(self, value): self.SubmittedStructure.append(value)
    def insert_SubmittedStructure_at(self, index, value): self.SubmittedStructure.insert(index, value)
    def replace_SubmittedStructure_at(self, index, value): self.SubmittedStructure[index] = value
    def hasContent_(self):
        if (
            self.StructureLocation is not None or
            self.Structure is not None or
            self.SubmittedStructure
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitStructureRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitStructureRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitStructureRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitStructureRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitStructureRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StructureLocation is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureLocation>%s</%sStructureLocation>%s' % (namespace_, self.gds_format_string(quote_xml(self.StructureLocation).encode(ExternalEncoding), input_name='StructureLocation'), namespace_, eol_))
        if self.Structure is not None:
            self.Structure.export(outfile, level, namespace_, name_='Structure', pretty_print=pretty_print)
        for SubmittedStructure_ in self.SubmittedStructure:
            SubmittedStructure_.export(outfile, level, namespace_, name_='SubmittedStructure', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitStructureRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StructureLocation is not None:
            showIndent(outfile, level)
            outfile.write('StructureLocation=%s,\n' % quote_python(self.StructureLocation).encode(ExternalEncoding))
        if self.Structure is not None:
            showIndent(outfile, level)
            outfile.write('Structure=model_.StructureType(\n')
            self.Structure.exportLiteral(outfile, level, name_='Structure')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SubmittedStructure=[\n')
        level += 1
        for SubmittedStructure_ in self.SubmittedStructure:
            showIndent(outfile, level)
            outfile.write('model_.SubmittedStructureType(\n')
            SubmittedStructure_.exportLiteral(outfile, level, name_='SubmittedStructureType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StructureLocation':
            StructureLocation_ = child_.text
            StructureLocation_ = self.gds_validate_string(StructureLocation_, node, 'StructureLocation')
            self.StructureLocation = StructureLocation_
        elif nodeName_ == 'Structure':
            obj_ = StructureType.factory()
            obj_.build(child_)
            self.Structure = obj_
            obj_.original_tagname_ = 'Structure'
        elif nodeName_ == 'SubmittedStructure':
            obj_ = SubmittedStructureType.factory()
            obj_.build(child_)
            self.SubmittedStructure.append(obj_)
            obj_.original_tagname_ = 'SubmittedStructure'
# end class SubmitStructureRequestType


class SubmitStructureResponseType(GeneratedsSuper):
    """SubmitStructureResponse is returned by the registry when a
    SubmitStructure is received. It indicates the status of the
    submission, and carries any error messages which are generated,
    if relevant. For each submitted structure, a SubmissionResult
    will be returned."""
    subclass = None
    superclass = None
    def __init__(self, SubmissionResult=None):
        self.original_tagname_ = None
        if SubmissionResult is None:
            self.SubmissionResult = []
        else:
            self.SubmissionResult = SubmissionResult
    def factory(*args_, **kwargs_):
        if SubmitStructureResponseType.subclass:
            return SubmitStructureResponseType.subclass(*args_, **kwargs_)
        else:
            return SubmitStructureResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubmissionResult(self): return self.SubmissionResult
    def set_SubmissionResult(self, SubmissionResult): self.SubmissionResult = SubmissionResult
    def add_SubmissionResult(self, value): self.SubmissionResult.append(value)
    def insert_SubmissionResult_at(self, index, value): self.SubmissionResult.insert(index, value)
    def replace_SubmissionResult_at(self, index, value): self.SubmissionResult[index] = value
    def hasContent_(self):
        if (
            self.SubmissionResult
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitStructureResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitStructureResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitStructureResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitStructureResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitStructureResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for SubmissionResult_ in self.SubmissionResult:
            SubmissionResult_.export(outfile, level, namespace_, name_='SubmissionResult', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitStructureResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SubmissionResult=[\n')
        level += 1
        for SubmissionResult_ in self.SubmissionResult:
            showIndent(outfile, level)
            outfile.write('model_.SubmissionResultType(\n')
            SubmissionResult_.exportLiteral(outfile, level, name_='SubmissionResultType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubmissionResult':
            obj_ = SubmissionResultType.factory()
            obj_.build(child_)
            self.SubmissionResult.append(obj_)
            obj_.original_tagname_ = 'SubmissionResult'
# end class SubmitStructureResponseType


class QueryStructureRequestType(GeneratedsSuper):
    """QueryStructureRequest is used to query the registry for any
    maintainable object within the repository. The response is a
    Structure message. In the reference elements to the queryable
    registry objects, a valid registry URN or a complete set of
    other child elements may be used to identify the objects desired
    in the result set. Any part of an element-based (that is, non-
    URN) identification of an object which is not provided will be
    understood as a wild-card value, referring to "all" possible
    values. The resolveReferences attribute is set to true if all
    dependent objects should also be returned as part of the result
    set. (For example, if you query for a key family and want to
    also have all codelists, concepts, and agencies, returned as
    well, resolveReferences should be set to true.)"""
    subclass = None
    superclass = None
    def __init__(self, resolveReferences=None, AgencyRef=None, DataProviderRef=None, DataflowRef=None, MetadataflowRef=None, CodelistRef=None, CategorySchemeRef=None, ConceptSchemeRef=None, OrganisationSchemeRef=None, KeyFamilyRef=None, MetadataStructureRef=None, HierarchicalCodelistRef=None, StructureSetRef=None, ProcessRef=None, ReportingTaxonomyRef=None):
        self.original_tagname_ = None
        self.resolveReferences = _cast(bool, resolveReferences)
        if AgencyRef is None:
            self.AgencyRef = []
        else:
            self.AgencyRef = AgencyRef
        if DataProviderRef is None:
            self.DataProviderRef = []
        else:
            self.DataProviderRef = DataProviderRef
        if DataflowRef is None:
            self.DataflowRef = []
        else:
            self.DataflowRef = DataflowRef
        if MetadataflowRef is None:
            self.MetadataflowRef = []
        else:
            self.MetadataflowRef = MetadataflowRef
        if CodelistRef is None:
            self.CodelistRef = []
        else:
            self.CodelistRef = CodelistRef
        if CategorySchemeRef is None:
            self.CategorySchemeRef = []
        else:
            self.CategorySchemeRef = CategorySchemeRef
        if ConceptSchemeRef is None:
            self.ConceptSchemeRef = []
        else:
            self.ConceptSchemeRef = ConceptSchemeRef
        if OrganisationSchemeRef is None:
            self.OrganisationSchemeRef = []
        else:
            self.OrganisationSchemeRef = OrganisationSchemeRef
        if KeyFamilyRef is None:
            self.KeyFamilyRef = []
        else:
            self.KeyFamilyRef = KeyFamilyRef
        if MetadataStructureRef is None:
            self.MetadataStructureRef = []
        else:
            self.MetadataStructureRef = MetadataStructureRef
        if HierarchicalCodelistRef is None:
            self.HierarchicalCodelistRef = []
        else:
            self.HierarchicalCodelistRef = HierarchicalCodelistRef
        if StructureSetRef is None:
            self.StructureSetRef = []
        else:
            self.StructureSetRef = StructureSetRef
        if ProcessRef is None:
            self.ProcessRef = []
        else:
            self.ProcessRef = ProcessRef
        if ReportingTaxonomyRef is None:
            self.ReportingTaxonomyRef = []
        else:
            self.ReportingTaxonomyRef = ReportingTaxonomyRef
    def factory(*args_, **kwargs_):
        if QueryStructureRequestType.subclass:
            return QueryStructureRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryStructureRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyRef(self): return self.AgencyRef
    def set_AgencyRef(self, AgencyRef): self.AgencyRef = AgencyRef
    def add_AgencyRef(self, value): self.AgencyRef.append(value)
    def insert_AgencyRef_at(self, index, value): self.AgencyRef.insert(index, value)
    def replace_AgencyRef_at(self, index, value): self.AgencyRef[index] = value
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def add_DataProviderRef(self, value): self.DataProviderRef.append(value)
    def insert_DataProviderRef_at(self, index, value): self.DataProviderRef.insert(index, value)
    def replace_DataProviderRef_at(self, index, value): self.DataProviderRef[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def add_DataflowRef(self, value): self.DataflowRef.append(value)
    def insert_DataflowRef_at(self, index, value): self.DataflowRef.insert(index, value)
    def replace_DataflowRef_at(self, index, value): self.DataflowRef[index] = value
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def add_MetadataflowRef(self, value): self.MetadataflowRef.append(value)
    def insert_MetadataflowRef_at(self, index, value): self.MetadataflowRef.insert(index, value)
    def replace_MetadataflowRef_at(self, index, value): self.MetadataflowRef[index] = value
    def get_CodelistRef(self): return self.CodelistRef
    def set_CodelistRef(self, CodelistRef): self.CodelistRef = CodelistRef
    def add_CodelistRef(self, value): self.CodelistRef.append(value)
    def insert_CodelistRef_at(self, index, value): self.CodelistRef.insert(index, value)
    def replace_CodelistRef_at(self, index, value): self.CodelistRef[index] = value
    def get_CategorySchemeRef(self): return self.CategorySchemeRef
    def set_CategorySchemeRef(self, CategorySchemeRef): self.CategorySchemeRef = CategorySchemeRef
    def add_CategorySchemeRef(self, value): self.CategorySchemeRef.append(value)
    def insert_CategorySchemeRef_at(self, index, value): self.CategorySchemeRef.insert(index, value)
    def replace_CategorySchemeRef_at(self, index, value): self.CategorySchemeRef[index] = value
    def get_ConceptSchemeRef(self): return self.ConceptSchemeRef
    def set_ConceptSchemeRef(self, ConceptSchemeRef): self.ConceptSchemeRef = ConceptSchemeRef
    def add_ConceptSchemeRef(self, value): self.ConceptSchemeRef.append(value)
    def insert_ConceptSchemeRef_at(self, index, value): self.ConceptSchemeRef.insert(index, value)
    def replace_ConceptSchemeRef_at(self, index, value): self.ConceptSchemeRef[index] = value
    def get_OrganisationSchemeRef(self): return self.OrganisationSchemeRef
    def set_OrganisationSchemeRef(self, OrganisationSchemeRef): self.OrganisationSchemeRef = OrganisationSchemeRef
    def add_OrganisationSchemeRef(self, value): self.OrganisationSchemeRef.append(value)
    def insert_OrganisationSchemeRef_at(self, index, value): self.OrganisationSchemeRef.insert(index, value)
    def replace_OrganisationSchemeRef_at(self, index, value): self.OrganisationSchemeRef[index] = value
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def add_KeyFamilyRef(self, value): self.KeyFamilyRef.append(value)
    def insert_KeyFamilyRef_at(self, index, value): self.KeyFamilyRef.insert(index, value)
    def replace_KeyFamilyRef_at(self, index, value): self.KeyFamilyRef[index] = value
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def add_MetadataStructureRef(self, value): self.MetadataStructureRef.append(value)
    def insert_MetadataStructureRef_at(self, index, value): self.MetadataStructureRef.insert(index, value)
    def replace_MetadataStructureRef_at(self, index, value): self.MetadataStructureRef[index] = value
    def get_HierarchicalCodelistRef(self): return self.HierarchicalCodelistRef
    def set_HierarchicalCodelistRef(self, HierarchicalCodelistRef): self.HierarchicalCodelistRef = HierarchicalCodelistRef
    def add_HierarchicalCodelistRef(self, value): self.HierarchicalCodelistRef.append(value)
    def insert_HierarchicalCodelistRef_at(self, index, value): self.HierarchicalCodelistRef.insert(index, value)
    def replace_HierarchicalCodelistRef_at(self, index, value): self.HierarchicalCodelistRef[index] = value
    def get_StructureSetRef(self): return self.StructureSetRef
    def set_StructureSetRef(self, StructureSetRef): self.StructureSetRef = StructureSetRef
    def add_StructureSetRef(self, value): self.StructureSetRef.append(value)
    def insert_StructureSetRef_at(self, index, value): self.StructureSetRef.insert(index, value)
    def replace_StructureSetRef_at(self, index, value): self.StructureSetRef[index] = value
    def get_ProcessRef(self): return self.ProcessRef
    def set_ProcessRef(self, ProcessRef): self.ProcessRef = ProcessRef
    def add_ProcessRef(self, value): self.ProcessRef.append(value)
    def insert_ProcessRef_at(self, index, value): self.ProcessRef.insert(index, value)
    def replace_ProcessRef_at(self, index, value): self.ProcessRef[index] = value
    def get_ReportingTaxonomyRef(self): return self.ReportingTaxonomyRef
    def set_ReportingTaxonomyRef(self, ReportingTaxonomyRef): self.ReportingTaxonomyRef = ReportingTaxonomyRef
    def add_ReportingTaxonomyRef(self, value): self.ReportingTaxonomyRef.append(value)
    def insert_ReportingTaxonomyRef_at(self, index, value): self.ReportingTaxonomyRef.insert(index, value)
    def replace_ReportingTaxonomyRef_at(self, index, value): self.ReportingTaxonomyRef[index] = value
    def get_resolveReferences(self): return self.resolveReferences
    def set_resolveReferences(self, resolveReferences): self.resolveReferences = resolveReferences
    def hasContent_(self):
        if (
            self.AgencyRef or
            self.DataProviderRef or
            self.DataflowRef or
            self.MetadataflowRef or
            self.CodelistRef or
            self.CategorySchemeRef or
            self.ConceptSchemeRef or
            self.OrganisationSchemeRef or
            self.KeyFamilyRef or
            self.MetadataStructureRef or
            self.HierarchicalCodelistRef or
            self.StructureSetRef or
            self.ProcessRef or
            self.ReportingTaxonomyRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryStructureRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryStructureRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryStructureRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryStructureRequestType'):
        if self.resolveReferences is not None and 'resolveReferences' not in already_processed:
            already_processed.add('resolveReferences')
            outfile.write(' resolveReferences="%s"' % self.gds_format_boolean(self.resolveReferences, input_name='resolveReferences'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryStructureRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AgencyRef_ in self.AgencyRef:
            AgencyRef_.export(outfile, level, namespace_, name_='AgencyRef', pretty_print=pretty_print)
        for DataProviderRef_ in self.DataProviderRef:
            DataProviderRef_.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        for DataflowRef_ in self.DataflowRef:
            DataflowRef_.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        for MetadataflowRef_ in self.MetadataflowRef:
            MetadataflowRef_.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        for CodelistRef_ in self.CodelistRef:
            CodelistRef_.export(outfile, level, namespace_, name_='CodelistRef', pretty_print=pretty_print)
        for CategorySchemeRef_ in self.CategorySchemeRef:
            CategorySchemeRef_.export(outfile, level, namespace_, name_='CategorySchemeRef', pretty_print=pretty_print)
        for ConceptSchemeRef_ in self.ConceptSchemeRef:
            ConceptSchemeRef_.export(outfile, level, namespace_, name_='ConceptSchemeRef', pretty_print=pretty_print)
        for OrganisationSchemeRef_ in self.OrganisationSchemeRef:
            OrganisationSchemeRef_.export(outfile, level, namespace_, name_='OrganisationSchemeRef', pretty_print=pretty_print)
        for KeyFamilyRef_ in self.KeyFamilyRef:
            KeyFamilyRef_.export(outfile, level, namespace_, name_='KeyFamilyRef', pretty_print=pretty_print)
        for MetadataStructureRef_ in self.MetadataStructureRef:
            MetadataStructureRef_.export(outfile, level, namespace_, name_='MetadataStructureRef', pretty_print=pretty_print)
        for HierarchicalCodelistRef_ in self.HierarchicalCodelistRef:
            HierarchicalCodelistRef_.export(outfile, level, namespace_, name_='HierarchicalCodelistRef', pretty_print=pretty_print)
        for StructureSetRef_ in self.StructureSetRef:
            StructureSetRef_.export(outfile, level, namespace_, name_='StructureSetRef', pretty_print=pretty_print)
        for ProcessRef_ in self.ProcessRef:
            ProcessRef_.export(outfile, level, namespace_, name_='ProcessRef', pretty_print=pretty_print)
        for ReportingTaxonomyRef_ in self.ReportingTaxonomyRef:
            ReportingTaxonomyRef_.export(outfile, level, namespace_, name_='ReportingTaxonomyRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryStructureRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.resolveReferences is not None and 'resolveReferences' not in already_processed:
            already_processed.add('resolveReferences')
            showIndent(outfile, level)
            outfile.write('resolveReferences=%s,\n' % (self.resolveReferences,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AgencyRef=[\n')
        level += 1
        for AgencyRef_ in self.AgencyRef:
            showIndent(outfile, level)
            outfile.write('model_.AgencyRefType(\n')
            AgencyRef_.exportLiteral(outfile, level, name_='AgencyRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderRef=[\n')
        level += 1
        for DataProviderRef_ in self.DataProviderRef:
            showIndent(outfile, level)
            outfile.write('model_.DataProviderRefType(\n')
            DataProviderRef_.exportLiteral(outfile, level, name_='DataProviderRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowRef=[\n')
        level += 1
        for DataflowRef_ in self.DataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.DataflowRefType(\n')
            DataflowRef_.exportLiteral(outfile, level, name_='DataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowRef=[\n')
        level += 1
        for MetadataflowRef_ in self.MetadataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowRefType(\n')
            MetadataflowRef_.exportLiteral(outfile, level, name_='MetadataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodelistRef=[\n')
        level += 1
        for CodelistRef_ in self.CodelistRef:
            showIndent(outfile, level)
            outfile.write('model_.CodelistRefType(\n')
            CodelistRef_.exportLiteral(outfile, level, name_='CodelistRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeRef=[\n')
        level += 1
        for CategorySchemeRef_ in self.CategorySchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.CategorySchemeRefType(\n')
            CategorySchemeRef_.exportLiteral(outfile, level, name_='CategorySchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptSchemeRef=[\n')
        level += 1
        for ConceptSchemeRef_ in self.ConceptSchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.ConceptSchemeRefType(\n')
            ConceptSchemeRef_.exportLiteral(outfile, level, name_='ConceptSchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OrganisationSchemeRef=[\n')
        level += 1
        for OrganisationSchemeRef_ in self.OrganisationSchemeRef:
            showIndent(outfile, level)
            outfile.write('model_.OrganisationSchemeRefType(\n')
            OrganisationSchemeRef_.exportLiteral(outfile, level, name_='OrganisationSchemeRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamilyRef=[\n')
        level += 1
        for KeyFamilyRef_ in self.KeyFamilyRef:
            showIndent(outfile, level)
            outfile.write('model_.KeyFamilyRefType(\n')
            KeyFamilyRef_.exportLiteral(outfile, level, name_='KeyFamilyRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructureRef=[\n')
        level += 1
        for MetadataStructureRef_ in self.MetadataStructureRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataStructureRefType(\n')
            MetadataStructureRef_.exportLiteral(outfile, level, name_='MetadataStructureRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HierarchicalCodelistRef=[\n')
        level += 1
        for HierarchicalCodelistRef_ in self.HierarchicalCodelistRef:
            showIndent(outfile, level)
            outfile.write('model_.HierarchicalCodelistRefType(\n')
            HierarchicalCodelistRef_.exportLiteral(outfile, level, name_='HierarchicalCodelistRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureSetRef=[\n')
        level += 1
        for StructureSetRef_ in self.StructureSetRef:
            showIndent(outfile, level)
            outfile.write('model_.StructureSetRefType(\n')
            StructureSetRef_.exportLiteral(outfile, level, name_='StructureSetRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProcessRef=[\n')
        level += 1
        for ProcessRef_ in self.ProcessRef:
            showIndent(outfile, level)
            outfile.write('model_.ProcessRefType(\n')
            ProcessRef_.exportLiteral(outfile, level, name_='ProcessRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportingTaxonomyRef=[\n')
        level += 1
        for ReportingTaxonomyRef_ in self.ReportingTaxonomyRef:
            showIndent(outfile, level)
            outfile.write('model_.ReportingTaxonomyRefType(\n')
            ReportingTaxonomyRef_.exportLiteral(outfile, level, name_='ReportingTaxonomyRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('resolveReferences', node)
        if value is not None and 'resolveReferences' not in already_processed:
            already_processed.add('resolveReferences')
            if value in ('true', '1'):
                self.resolveReferences = True
            elif value in ('false', '0'):
                self.resolveReferences = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyRef':
            obj_ = AgencyRefType.factory()
            obj_.build(child_)
            self.AgencyRef.append(obj_)
            obj_.original_tagname_ = 'AgencyRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef.append(obj_)
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef.append(obj_)
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef.append(obj_)
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'CodelistRef':
            obj_ = CodelistRefType.factory()
            obj_.build(child_)
            self.CodelistRef.append(obj_)
            obj_.original_tagname_ = 'CodelistRef'
        elif nodeName_ == 'CategorySchemeRef':
            obj_ = CategorySchemeRefType.factory()
            obj_.build(child_)
            self.CategorySchemeRef.append(obj_)
            obj_.original_tagname_ = 'CategorySchemeRef'
        elif nodeName_ == 'ConceptSchemeRef':
            obj_ = ConceptSchemeRefType.factory()
            obj_.build(child_)
            self.ConceptSchemeRef.append(obj_)
            obj_.original_tagname_ = 'ConceptSchemeRef'
        elif nodeName_ == 'OrganisationSchemeRef':
            obj_ = OrganisationSchemeRefType.factory()
            obj_.build(child_)
            self.OrganisationSchemeRef.append(obj_)
            obj_.original_tagname_ = 'OrganisationSchemeRef'
        elif nodeName_ == 'KeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.KeyFamilyRef.append(obj_)
            obj_.original_tagname_ = 'KeyFamilyRef'
        elif nodeName_ == 'MetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.MetadataStructureRef.append(obj_)
            obj_.original_tagname_ = 'MetadataStructureRef'
        elif nodeName_ == 'HierarchicalCodelistRef':
            obj_ = HierarchicalCodelistRefType.factory()
            obj_.build(child_)
            self.HierarchicalCodelistRef.append(obj_)
            obj_.original_tagname_ = 'HierarchicalCodelistRef'
        elif nodeName_ == 'StructureSetRef':
            obj_ = StructureSetRefType.factory()
            obj_.build(child_)
            self.StructureSetRef.append(obj_)
            obj_.original_tagname_ = 'StructureSetRef'
        elif nodeName_ == 'ProcessRef':
            obj_ = ProcessRefType.factory()
            obj_.build(child_)
            self.ProcessRef.append(obj_)
            obj_.original_tagname_ = 'ProcessRef'
        elif nodeName_ == 'ReportingTaxonomyRef':
            obj_ = ReportingTaxonomyRefType.factory()
            obj_.build(child_)
            self.ReportingTaxonomyRef.append(obj_)
            obj_.original_tagname_ = 'ReportingTaxonomyRef'
# end class QueryStructureRequestType


class QueryStructureResponseType(GeneratedsSuper):
    """QueryStructureResponse is sent in response to a
    QueryStructureRequest. It carries the status of the response,
    with any relevant error messages, and then also carries all
    information found in the rersult set."""
    subclass = None
    superclass = None
    def __init__(self, StatusMessage=None, OrganisationSchemes=None, Dataflows=None, Metadataflows=None, CategorySchemes=None, CodeLists=None, HierarchicalCodelists=None, Concepts=None, MetadataStructureDefinitions=None, KeyFamilies=None, StructureSets=None, ReportingTaxonomies=None, Processes=None):
        self.original_tagname_ = None
        self.StatusMessage = StatusMessage
        self.OrganisationSchemes = OrganisationSchemes
        self.Dataflows = Dataflows
        self.Metadataflows = Metadataflows
        self.CategorySchemes = CategorySchemes
        self.CodeLists = CodeLists
        self.HierarchicalCodelists = HierarchicalCodelists
        self.Concepts = Concepts
        self.MetadataStructureDefinitions = MetadataStructureDefinitions
        self.KeyFamilies = KeyFamilies
        self.StructureSets = StructureSets
        self.ReportingTaxonomies = ReportingTaxonomies
        self.Processes = Processes
    def factory(*args_, **kwargs_):
        if QueryStructureResponseType.subclass:
            return QueryStructureResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryStructureResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def get_OrganisationSchemes(self): return self.OrganisationSchemes
    def set_OrganisationSchemes(self, OrganisationSchemes): self.OrganisationSchemes = OrganisationSchemes
    def get_Dataflows(self): return self.Dataflows
    def set_Dataflows(self, Dataflows): self.Dataflows = Dataflows
    def get_Metadataflows(self): return self.Metadataflows
    def set_Metadataflows(self, Metadataflows): self.Metadataflows = Metadataflows
    def get_CategorySchemes(self): return self.CategorySchemes
    def set_CategorySchemes(self, CategorySchemes): self.CategorySchemes = CategorySchemes
    def get_CodeLists(self): return self.CodeLists
    def set_CodeLists(self, CodeLists): self.CodeLists = CodeLists
    def get_HierarchicalCodelists(self): return self.HierarchicalCodelists
    def set_HierarchicalCodelists(self, HierarchicalCodelists): self.HierarchicalCodelists = HierarchicalCodelists
    def get_Concepts(self): return self.Concepts
    def set_Concepts(self, Concepts): self.Concepts = Concepts
    def get_MetadataStructureDefinitions(self): return self.MetadataStructureDefinitions
    def set_MetadataStructureDefinitions(self, MetadataStructureDefinitions): self.MetadataStructureDefinitions = MetadataStructureDefinitions
    def get_KeyFamilies(self): return self.KeyFamilies
    def set_KeyFamilies(self, KeyFamilies): self.KeyFamilies = KeyFamilies
    def get_StructureSets(self): return self.StructureSets
    def set_StructureSets(self, StructureSets): self.StructureSets = StructureSets
    def get_ReportingTaxonomies(self): return self.ReportingTaxonomies
    def set_ReportingTaxonomies(self, ReportingTaxonomies): self.ReportingTaxonomies = ReportingTaxonomies
    def get_Processes(self): return self.Processes
    def set_Processes(self, Processes): self.Processes = Processes
    def hasContent_(self):
        if (
            self.StatusMessage is not None or
            self.OrganisationSchemes is not None or
            self.Dataflows is not None or
            self.Metadataflows is not None or
            self.CategorySchemes is not None or
            self.CodeLists is not None or
            self.HierarchicalCodelists is not None or
            self.Concepts is not None or
            self.MetadataStructureDefinitions is not None or
            self.KeyFamilies is not None or
            self.StructureSets is not None or
            self.ReportingTaxonomies is not None or
            self.Processes is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryStructureResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:structure="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/structure" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryStructureResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryStructureResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryStructureResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryStructureResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
        if self.OrganisationSchemes is not None:
            self.OrganisationSchemes.export(outfile, level, namespace_, name_='OrganisationSchemes', pretty_print=pretty_print)
        if self.Dataflows is not None:
            self.Dataflows.export(outfile, level, namespace_, name_='Dataflows', pretty_print=pretty_print)
        if self.Metadataflows is not None:
            self.Metadataflows.export(outfile, level, namespace_, name_='Metadataflows', pretty_print=pretty_print)
        if self.CategorySchemes is not None:
            self.CategorySchemes.export(outfile, level, namespace_, name_='CategorySchemes', pretty_print=pretty_print)
        if self.CodeLists is not None:
            self.CodeLists.export(outfile, level, namespace_, name_='CodeLists', pretty_print=pretty_print)
        if self.HierarchicalCodelists is not None:
            self.HierarchicalCodelists.export(outfile, level, namespace_, name_='HierarchicalCodelists', pretty_print=pretty_print)
        if self.Concepts is not None:
            self.Concepts.export(outfile, level, namespace_, name_='Concepts', pretty_print=pretty_print)
        if self.MetadataStructureDefinitions is not None:
            self.MetadataStructureDefinitions.export(outfile, level, namespace_, name_='MetadataStructureDefinitions', pretty_print=pretty_print)
        if self.KeyFamilies is not None:
            self.KeyFamilies.export(outfile, level, namespace_, name_='KeyFamilies', pretty_print=pretty_print)
        if self.StructureSets is not None:
            self.StructureSets.export(outfile, level, namespace_, name_='StructureSets', pretty_print=pretty_print)
        if self.ReportingTaxonomies is not None:
            self.ReportingTaxonomies.export(outfile, level, namespace_, name_='ReportingTaxonomies', pretty_print=pretty_print)
        if self.Processes is not None:
            self.Processes.export(outfile, level, namespace_, name_='Processes', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryStructureResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationSchemes is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemes=model_.OrganisationSchemesType(\n')
            self.OrganisationSchemes.exportLiteral(outfile, level, name_='OrganisationSchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dataflows is not None:
            showIndent(outfile, level)
            outfile.write('Dataflows=model_.DataflowsType(\n')
            self.Dataflows.exportLiteral(outfile, level, name_='Dataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Metadataflows is not None:
            showIndent(outfile, level)
            outfile.write('Metadataflows=model_.MetadataflowsType(\n')
            self.Metadataflows.exportLiteral(outfile, level, name_='Metadataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CategorySchemes is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemes=model_.CategorySchemesType(\n')
            self.CategorySchemes.exportLiteral(outfile, level, name_='CategorySchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CodeLists is not None:
            showIndent(outfile, level)
            outfile.write('CodeLists=model_.CodeListsType(\n')
            self.CodeLists.exportLiteral(outfile, level, name_='CodeLists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HierarchicalCodelists is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelists=model_.HierarchicalCodelistsType(\n')
            self.HierarchicalCodelists.exportLiteral(outfile, level, name_='HierarchicalCodelists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concepts is not None:
            showIndent(outfile, level)
            outfile.write('Concepts=model_.ConceptsType(\n')
            self.Concepts.exportLiteral(outfile, level, name_='Concepts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataStructureDefinitions is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureDefinitions=model_.MetadataStructureDefinitionsType(\n')
            self.MetadataStructureDefinitions.exportLiteral(outfile, level, name_='MetadataStructureDefinitions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KeyFamilies is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilies=model_.KeyFamiliesType(\n')
            self.KeyFamilies.exportLiteral(outfile, level, name_='KeyFamilies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureSets is not None:
            showIndent(outfile, level)
            outfile.write('StructureSets=model_.StructureSetsType(\n')
            self.StructureSets.exportLiteral(outfile, level, name_='StructureSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReportingTaxonomies is not None:
            showIndent(outfile, level)
            outfile.write('ReportingTaxonomies=model_.ReportingTaxonomiesType(\n')
            self.ReportingTaxonomies.exportLiteral(outfile, level, name_='ReportingTaxonomies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Processes is not None:
            showIndent(outfile, level)
            outfile.write('Processes=model_.ProcessesType(\n')
            self.Processes.exportLiteral(outfile, level, name_='Processes')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
        elif nodeName_ == 'OrganisationSchemes':
            obj_ = OrganisationSchemesType.factory()
            obj_.build(child_)
            self.OrganisationSchemes = obj_
            obj_.original_tagname_ = 'OrganisationSchemes'
        elif nodeName_ == 'Dataflows':
            obj_ = DataflowsType.factory()
            obj_.build(child_)
            self.Dataflows = obj_
            obj_.original_tagname_ = 'Dataflows'
        elif nodeName_ == 'Metadataflows':
            obj_ = MetadataflowsType.factory()
            obj_.build(child_)
            self.Metadataflows = obj_
            obj_.original_tagname_ = 'Metadataflows'
        elif nodeName_ == 'CategorySchemes':
            obj_ = CategorySchemesType.factory()
            obj_.build(child_)
            self.CategorySchemes = obj_
            obj_.original_tagname_ = 'CategorySchemes'
        elif nodeName_ == 'CodeLists':
            obj_ = CodeListsType.factory()
            obj_.build(child_)
            self.CodeLists = obj_
            obj_.original_tagname_ = 'CodeLists'
        elif nodeName_ == 'HierarchicalCodelists':
            obj_ = HierarchicalCodelistsType.factory()
            obj_.build(child_)
            self.HierarchicalCodelists = obj_
            obj_.original_tagname_ = 'HierarchicalCodelists'
        elif nodeName_ == 'Concepts':
            obj_ = ConceptsType.factory()
            obj_.build(child_)
            self.Concepts = obj_
            obj_.original_tagname_ = 'Concepts'
        elif nodeName_ == 'MetadataStructureDefinitions':
            obj_ = MetadataStructureDefinitionsType.factory()
            obj_.build(child_)
            self.MetadataStructureDefinitions = obj_
            obj_.original_tagname_ = 'MetadataStructureDefinitions'
        elif nodeName_ == 'KeyFamilies':
            obj_ = KeyFamiliesType.factory()
            obj_.build(child_)
            self.KeyFamilies = obj_
            obj_.original_tagname_ = 'KeyFamilies'
        elif nodeName_ == 'StructureSets':
            obj_ = StructureSetsType.factory()
            obj_.build(child_)
            self.StructureSets = obj_
            obj_.original_tagname_ = 'StructureSets'
        elif nodeName_ == 'ReportingTaxonomies':
            obj_ = ReportingTaxonomiesType.factory()
            obj_.build(child_)
            self.ReportingTaxonomies = obj_
            obj_.original_tagname_ = 'ReportingTaxonomies'
        elif nodeName_ == 'Processes':
            obj_ = ProcessesType.factory()
            obj_.build(child_)
            self.Processes = obj_
            obj_.original_tagname_ = 'Processes'
# end class QueryStructureResponseType


class SubmitProvisioningRequestType(GeneratedsSuper):
    """This document is sent to the registry services to submit
    provisioning information. A provision agreement is typically
    sent, wghich has internal references to existing data rpvodiers
    and dataflows/metadataflows. These elements are also included as
    possible separate submissions, because it may be necessary to
    provide datasource and constraint information independent of the
    establishment of a provision agreement."""
    subclass = None
    superclass = None
    def __init__(self, ProvisionAgreement=None, DataProviderRef=None, DataflowRef=None, MetadatataflowRef=None):
        self.original_tagname_ = None
        if ProvisionAgreement is None:
            self.ProvisionAgreement = []
        else:
            self.ProvisionAgreement = ProvisionAgreement
        if DataProviderRef is None:
            self.DataProviderRef = []
        else:
            self.DataProviderRef = DataProviderRef
        if DataflowRef is None:
            self.DataflowRef = []
        else:
            self.DataflowRef = DataflowRef
        if MetadatataflowRef is None:
            self.MetadatataflowRef = []
        else:
            self.MetadatataflowRef = MetadatataflowRef
    def factory(*args_, **kwargs_):
        if SubmitProvisioningRequestType.subclass:
            return SubmitProvisioningRequestType.subclass(*args_, **kwargs_)
        else:
            return SubmitProvisioningRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisionAgreement(self): return self.ProvisionAgreement
    def set_ProvisionAgreement(self, ProvisionAgreement): self.ProvisionAgreement = ProvisionAgreement
    def add_ProvisionAgreement(self, value): self.ProvisionAgreement.append(value)
    def insert_ProvisionAgreement_at(self, index, value): self.ProvisionAgreement.insert(index, value)
    def replace_ProvisionAgreement_at(self, index, value): self.ProvisionAgreement[index] = value
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def add_DataProviderRef(self, value): self.DataProviderRef.append(value)
    def insert_DataProviderRef_at(self, index, value): self.DataProviderRef.insert(index, value)
    def replace_DataProviderRef_at(self, index, value): self.DataProviderRef[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def add_DataflowRef(self, value): self.DataflowRef.append(value)
    def insert_DataflowRef_at(self, index, value): self.DataflowRef.insert(index, value)
    def replace_DataflowRef_at(self, index, value): self.DataflowRef[index] = value
    def get_MetadatataflowRef(self): return self.MetadatataflowRef
    def set_MetadatataflowRef(self, MetadatataflowRef): self.MetadatataflowRef = MetadatataflowRef
    def add_MetadatataflowRef(self, value): self.MetadatataflowRef.append(value)
    def insert_MetadatataflowRef_at(self, index, value): self.MetadatataflowRef.insert(index, value)
    def replace_MetadatataflowRef_at(self, index, value): self.MetadatataflowRef[index] = value
    def hasContent_(self):
        if (
            self.ProvisionAgreement or
            self.DataProviderRef or
            self.DataflowRef or
            self.MetadatataflowRef
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitProvisioningRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitProvisioningRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitProvisioningRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitProvisioningRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitProvisioningRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProvisionAgreement_ in self.ProvisionAgreement:
            ProvisionAgreement_.export(outfile, level, namespace_, name_='ProvisionAgreement', pretty_print=pretty_print)
        for DataProviderRef_ in self.DataProviderRef:
            DataProviderRef_.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        for DataflowRef_ in self.DataflowRef:
            DataflowRef_.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        for MetadatataflowRef_ in self.MetadatataflowRef:
            MetadatataflowRef_.export(outfile, level, namespace_, name_='MetadatataflowRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitProvisioningRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProvisionAgreement=[\n')
        level += 1
        for ProvisionAgreement_ in self.ProvisionAgreement:
            showIndent(outfile, level)
            outfile.write('model_.ProvisionAgreementType(\n')
            ProvisionAgreement_.exportLiteral(outfile, level, name_='ProvisionAgreementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderRef=[\n')
        level += 1
        for DataProviderRef_ in self.DataProviderRef:
            showIndent(outfile, level)
            outfile.write('model_.DataProviderRefType(\n')
            DataProviderRef_.exportLiteral(outfile, level, name_='DataProviderRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowRef=[\n')
        level += 1
        for DataflowRef_ in self.DataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.DataflowRefType(\n')
            DataflowRef_.exportLiteral(outfile, level, name_='DataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadatataflowRef=[\n')
        level += 1
        for MetadatataflowRef_ in self.MetadatataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowRefType(\n')
            MetadatataflowRef_.exportLiteral(outfile, level, name_='MetadataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisionAgreement':
            obj_ = ProvisionAgreementType.factory()
            obj_.build(child_)
            self.ProvisionAgreement.append(obj_)
            obj_.original_tagname_ = 'ProvisionAgreement'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef.append(obj_)
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef.append(obj_)
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadatataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadatataflowRef.append(obj_)
            obj_.original_tagname_ = 'MetadatataflowRef'
# end class SubmitProvisioningRequestType


class SubmitProvisioningResponseType(GeneratedsSuper):
    """The ProvisioningResponse element is returned by the registry
    services in response to a provisioning request. It contains
    information about the status of the submitted provisioning
    information, and any relevant error messages in case of failure."""
    subclass = None
    superclass = None
    def __init__(self, ProvisioningStatus=None):
        self.original_tagname_ = None
        if ProvisioningStatus is None:
            self.ProvisioningStatus = []
        else:
            self.ProvisioningStatus = ProvisioningStatus
    def factory(*args_, **kwargs_):
        if SubmitProvisioningResponseType.subclass:
            return SubmitProvisioningResponseType.subclass(*args_, **kwargs_)
        else:
            return SubmitProvisioningResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisioningStatus(self): return self.ProvisioningStatus
    def set_ProvisioningStatus(self, ProvisioningStatus): self.ProvisioningStatus = ProvisioningStatus
    def add_ProvisioningStatus(self, value): self.ProvisioningStatus.append(value)
    def insert_ProvisioningStatus_at(self, index, value): self.ProvisioningStatus.insert(index, value)
    def replace_ProvisioningStatus_at(self, index, value): self.ProvisioningStatus[index] = value
    def hasContent_(self):
        if (
            self.ProvisioningStatus
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmitProvisioningResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmitProvisioningResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmitProvisioningResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmitProvisioningResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmitProvisioningResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProvisioningStatus_ in self.ProvisioningStatus:
            ProvisioningStatus_.export(outfile, level, namespace_, name_='ProvisioningStatus', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmitProvisioningResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProvisioningStatus=[\n')
        level += 1
        for ProvisioningStatus_ in self.ProvisioningStatus:
            showIndent(outfile, level)
            outfile.write('model_.ProvisioningStatusType(\n')
            ProvisioningStatus_.exportLiteral(outfile, level, name_='ProvisioningStatusType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisioningStatus':
            obj_ = ProvisioningStatusType.factory()
            obj_.build(child_)
            self.ProvisioningStatus.append(obj_)
            obj_.original_tagname_ = 'ProvisioningStatus'
# end class SubmitProvisioningResponseType


class QueryProvisioningRequestType(GeneratedsSuper):
    """QueryProvisioningRequest is used to query the repository for
    provisioning metadata. The response is a
    QueryProvisioningResponse document, carrying either the result
    set of the query or relevant error messages. Note that whatever
    information is presented here, regarding provision agreements,
    data flow, metadataflow, or data providers, is taken to be the
    search criteria - the query is for all provision agreements
    which match the supplied criteria. If any of provision
    agreement, metadataflow, dataflow, or data provider are omitted,
    the search will apply to all values for those objects in the
    repository."""
    subclass = None
    superclass = None
    def __init__(self, ProvisionAgreementRef=None, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None):
        self.original_tagname_ = None
        self.ProvisionAgreementRef = ProvisionAgreementRef
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.DataProviderRef = DataProviderRef
    def factory(*args_, **kwargs_):
        if QueryProvisioningRequestType.subclass:
            return QueryProvisioningRequestType.subclass(*args_, **kwargs_)
        else:
            return QueryProvisioningRequestType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def hasContent_(self):
        if (
            self.ProvisionAgreementRef is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.DataProviderRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryProvisioningRequestType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryProvisioningRequestType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryProvisioningRequestType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryProvisioningRequestType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryProvisioningRequestType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryProvisioningRequestType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
# end class QueryProvisioningRequestType


class QueryProvisioningResponseType(GeneratedsSuper):
    """The QueryProvisioningResponse element is returned in response to
    queries regarding provisioning information. It carries either
    the provisioning information making up the result set, or
    relevant status messages containing errors or warnings, or both.
    The references to Dataflow, Metadataflow, and Data Provider are
    included in those cases where the result set has these objects,
    but not associated with any Provisioning Agreement."""
    subclass = None
    superclass = None
    def __init__(self, ProvisionAgreement=None, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None, StatusMessage=None):
        self.original_tagname_ = None
        if ProvisionAgreement is None:
            self.ProvisionAgreement = []
        else:
            self.ProvisionAgreement = ProvisionAgreement
        if DataflowRef is None:
            self.DataflowRef = []
        else:
            self.DataflowRef = DataflowRef
        if MetadataflowRef is None:
            self.MetadataflowRef = []
        else:
            self.MetadataflowRef = MetadataflowRef
        if DataProviderRef is None:
            self.DataProviderRef = []
        else:
            self.DataProviderRef = DataProviderRef
        self.StatusMessage = StatusMessage
    def factory(*args_, **kwargs_):
        if QueryProvisioningResponseType.subclass:
            return QueryProvisioningResponseType.subclass(*args_, **kwargs_)
        else:
            return QueryProvisioningResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisionAgreement(self): return self.ProvisionAgreement
    def set_ProvisionAgreement(self, ProvisionAgreement): self.ProvisionAgreement = ProvisionAgreement
    def add_ProvisionAgreement(self, value): self.ProvisionAgreement.append(value)
    def insert_ProvisionAgreement_at(self, index, value): self.ProvisionAgreement.insert(index, value)
    def replace_ProvisionAgreement_at(self, index, value): self.ProvisionAgreement[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def add_DataflowRef(self, value): self.DataflowRef.append(value)
    def insert_DataflowRef_at(self, index, value): self.DataflowRef.insert(index, value)
    def replace_DataflowRef_at(self, index, value): self.DataflowRef[index] = value
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def add_MetadataflowRef(self, value): self.MetadataflowRef.append(value)
    def insert_MetadataflowRef_at(self, index, value): self.MetadataflowRef.insert(index, value)
    def replace_MetadataflowRef_at(self, index, value): self.MetadataflowRef[index] = value
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def add_DataProviderRef(self, value): self.DataProviderRef.append(value)
    def insert_DataProviderRef_at(self, index, value): self.DataProviderRef.insert(index, value)
    def replace_DataProviderRef_at(self, index, value): self.DataProviderRef[index] = value
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def hasContent_(self):
        if (
            self.ProvisionAgreement or
            self.DataflowRef or
            self.MetadataflowRef or
            self.DataProviderRef or
            self.StatusMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryProvisioningResponseType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryProvisioningResponseType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryProvisioningResponseType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryProvisioningResponseType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryProvisioningResponseType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProvisionAgreement_ in self.ProvisionAgreement:
            ProvisionAgreement_.export(outfile, level, namespace_, name_='ProvisionAgreement', pretty_print=pretty_print)
        for DataflowRef_ in self.DataflowRef:
            DataflowRef_.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        for MetadataflowRef_ in self.MetadataflowRef:
            MetadataflowRef_.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        for DataProviderRef_ in self.DataProviderRef:
            DataProviderRef_.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryProvisioningResponseType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProvisionAgreement=[\n')
        level += 1
        for ProvisionAgreement_ in self.ProvisionAgreement:
            showIndent(outfile, level)
            outfile.write('model_.ProvisionAgreementType(\n')
            ProvisionAgreement_.exportLiteral(outfile, level, name_='ProvisionAgreementType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowRef=[\n')
        level += 1
        for DataflowRef_ in self.DataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.DataflowRefType(\n')
            DataflowRef_.exportLiteral(outfile, level, name_='DataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowRef=[\n')
        level += 1
        for MetadataflowRef_ in self.MetadataflowRef:
            showIndent(outfile, level)
            outfile.write('model_.MetadataflowRefType(\n')
            MetadataflowRef_.exportLiteral(outfile, level, name_='MetadataflowRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderRef=[\n')
        level += 1
        for DataProviderRef_ in self.DataProviderRef:
            showIndent(outfile, level)
            outfile.write('model_.DataProviderRefType(\n')
            DataProviderRef_.exportLiteral(outfile, level, name_='DataProviderRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisionAgreement':
            obj_ = ProvisionAgreementType.factory()
            obj_.build(child_)
            self.ProvisionAgreement.append(obj_)
            obj_.original_tagname_ = 'ProvisionAgreement'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef.append(obj_)
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef.append(obj_)
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef.append(obj_)
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
# end class QueryProvisioningResponseType


class SubscriptionType(GeneratedsSuper):
    """Subscriptions submit a subscription for a registry or repository
    object.Action indicates what action is being taken by sending
    the request. RegistryURN is used to identify the subscription in
    the case of deletion or modification. NotificationMAilTo holds
    an e-mail address (the "mailto:" protocol); NotificationHTTP
    holds an http address to which notifications can be addressed as
    POSTs. SubscriberAssignedID allows the subscriber to specify an
    ID which will be returned as part of the notification for the
    subscribed events. Validity period sets a start and end date for
    the subscription, EventSelector indicates an event or events for
    the subscription."""
    subclass = None
    superclass = None
    def __init__(self, Action=None, RegistryURN=None, NotificationMailTo=None, NotificationHTTP=None, SubscriberAssignedID=None, ValidityPeriod=None, EventSelector=None):
        self.original_tagname_ = None
        self.Action = Action
        self.RegistryURN = RegistryURN
        self.NotificationMailTo = NotificationMailTo
        self.NotificationHTTP = NotificationHTTP
        self.SubscriberAssignedID = SubscriberAssignedID
        self.ValidityPeriod = ValidityPeriod
        self.EventSelector = EventSelector
    def factory(*args_, **kwargs_):
        if SubscriptionType.subclass:
            return SubscriptionType.subclass(*args_, **kwargs_)
        else:
            return SubscriptionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def get_RegistryURN(self): return self.RegistryURN
    def set_RegistryURN(self, RegistryURN): self.RegistryURN = RegistryURN
    def get_NotificationMailTo(self): return self.NotificationMailTo
    def set_NotificationMailTo(self, NotificationMailTo): self.NotificationMailTo = NotificationMailTo
    def get_NotificationHTTP(self): return self.NotificationHTTP
    def set_NotificationHTTP(self, NotificationHTTP): self.NotificationHTTP = NotificationHTTP
    def get_SubscriberAssignedID(self): return self.SubscriberAssignedID
    def set_SubscriberAssignedID(self, SubscriberAssignedID): self.SubscriberAssignedID = SubscriberAssignedID
    def get_ValidityPeriod(self): return self.ValidityPeriod
    def set_ValidityPeriod(self, ValidityPeriod): self.ValidityPeriod = ValidityPeriod
    def get_EventSelector(self): return self.EventSelector
    def set_EventSelector(self, EventSelector): self.EventSelector = EventSelector
    def validate_ActionType(self, value):
        # Validate type ActionType, a restriction on xs:NMTOKEN.
        pass
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Action is not None or
            self.RegistryURN is not None or
            self.NotificationMailTo is not None or
            self.NotificationHTTP is not None or
            self.SubscriberAssignedID is not None or
            self.ValidityPeriod is not None or
            self.EventSelector is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubscriptionType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubscriptionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubscriptionType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubscriptionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubscriptionType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAction>%s</%sAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.Action).encode(ExternalEncoding), input_name='Action'), namespace_, eol_))
        if self.RegistryURN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sRegistryURN>%s</%sRegistryURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.RegistryURN).encode(ExternalEncoding), input_name='RegistryURN'), namespace_, eol_))
        if self.NotificationMailTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotificationMailTo>%s</%sNotificationMailTo>%s' % (namespace_, self.gds_format_string(quote_xml(self.NotificationMailTo).encode(ExternalEncoding), input_name='NotificationMailTo'), namespace_, eol_))
        if self.NotificationHTTP is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotificationHTTP>%s</%sNotificationHTTP>%s' % (namespace_, self.gds_format_string(quote_xml(self.NotificationHTTP).encode(ExternalEncoding), input_name='NotificationHTTP'), namespace_, eol_))
        if self.SubscriberAssignedID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSubscriberAssignedID>%s</%sSubscriberAssignedID>%s' % (namespace_, self.gds_format_string(quote_xml(self.SubscriberAssignedID).encode(ExternalEncoding), input_name='SubscriberAssignedID'), namespace_, eol_))
        if self.ValidityPeriod is not None:
            self.ValidityPeriod.export(outfile, level, namespace_, name_='ValidityPeriod', pretty_print=pretty_print)
        if self.EventSelector is not None:
            self.EventSelector.export(outfile, level, namespace_, name_='EventSelector', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubscriptionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Action is not None:
            showIndent(outfile, level)
            outfile.write('Action=%s,\n' % quote_python(self.Action).encode(ExternalEncoding))
        if self.RegistryURN is not None:
            showIndent(outfile, level)
            outfile.write('RegistryURN=%s,\n' % quote_python(self.RegistryURN).encode(ExternalEncoding))
        if self.NotificationMailTo is not None:
            showIndent(outfile, level)
            outfile.write('NotificationMailTo=%s,\n' % quote_python(self.NotificationMailTo).encode(ExternalEncoding))
        if self.NotificationHTTP is not None:
            showIndent(outfile, level)
            outfile.write('NotificationHTTP=%s,\n' % quote_python(self.NotificationHTTP).encode(ExternalEncoding))
        if self.SubscriberAssignedID is not None:
            showIndent(outfile, level)
            outfile.write('SubscriberAssignedID=%s,\n' % quote_python(self.SubscriberAssignedID).encode(ExternalEncoding))
        if self.ValidityPeriod is not None:
            showIndent(outfile, level)
            outfile.write('ValidityPeriod=model_.ValidityPeriodType(\n')
            self.ValidityPeriod.exportLiteral(outfile, level, name_='ValidityPeriod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EventSelector is not None:
            showIndent(outfile, level)
            outfile.write('EventSelector=model_.EventSelectorType(\n')
            self.EventSelector.exportLiteral(outfile, level, name_='EventSelector')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Action':
            Action_ = child_.text
            Action_ = self.gds_validate_string(Action_, node, 'Action')
            self.Action = Action_
            self.validate_ActionType(self.Action)    # validate type ActionType
        elif nodeName_ == 'RegistryURN':
            RegistryURN_ = child_.text
            RegistryURN_ = self.gds_validate_string(RegistryURN_, node, 'RegistryURN')
            self.RegistryURN = RegistryURN_
        elif nodeName_ == 'NotificationMailTo':
            NotificationMailTo_ = child_.text
            NotificationMailTo_ = self.gds_validate_string(NotificationMailTo_, node, 'NotificationMailTo')
            self.NotificationMailTo = NotificationMailTo_
        elif nodeName_ == 'NotificationHTTP':
            NotificationHTTP_ = child_.text
            NotificationHTTP_ = self.gds_validate_string(NotificationHTTP_, node, 'NotificationHTTP')
            self.NotificationHTTP = NotificationHTTP_
        elif nodeName_ == 'SubscriberAssignedID':
            SubscriberAssignedID_ = child_.text
            SubscriberAssignedID_ = self.gds_validate_string(SubscriberAssignedID_, node, 'SubscriberAssignedID')
            self.SubscriberAssignedID = SubscriberAssignedID_
            self.validate_IDType(self.SubscriberAssignedID)    # validate type IDType
        elif nodeName_ == 'ValidityPeriod':
            obj_ = ValidityPeriodType.factory()
            obj_.build(child_)
            self.ValidityPeriod = obj_
            obj_.original_tagname_ = 'ValidityPeriod'
        elif nodeName_ == 'EventSelector':
            obj_ = EventSelectorType.factory()
            obj_.build(child_)
            self.EventSelector = obj_
            obj_.original_tagname_ = 'EventSelector'
# end class SubscriptionType


class ValidityPeriodType(GeneratedsSuper):
    """Specifies inclusive start and end-dates for the subscription period."""
    subclass = None
    superclass = None
    def __init__(self, StartDate=None, EndDate=None):
        self.original_tagname_ = None
        if isinstance(StartDate, basestring):
            initvalue_ = datetime_.datetime.strptime(StartDate, '%Y-%m-%d').date()
        else:
            initvalue_ = StartDate
        self.StartDate = initvalue_
        if isinstance(EndDate, basestring):
            initvalue_ = datetime_.datetime.strptime(EndDate, '%Y-%m-%d').date()
        else:
            initvalue_ = EndDate
        self.EndDate = initvalue_
    def factory(*args_, **kwargs_):
        if ValidityPeriodType.subclass:
            return ValidityPeriodType.subclass(*args_, **kwargs_)
        else:
            return ValidityPeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StartDate(self): return self.StartDate
    def set_StartDate(self, StartDate): self.StartDate = StartDate
    def get_EndDate(self): return self.EndDate
    def set_EndDate(self, EndDate): self.EndDate = EndDate
    def hasContent_(self):
        if (
            self.StartDate is not None or
            self.EndDate is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ValidityPeriodType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ValidityPeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ValidityPeriodType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ValidityPeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ValidityPeriodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StartDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartDate>%s</%sStartDate>%s' % (namespace_, self.gds_format_date(self.StartDate, input_name='StartDate'), namespace_, eol_))
        if self.EndDate is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sEndDate>%s</%sEndDate>%s' % (namespace_, self.gds_format_date(self.EndDate, input_name='EndDate'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ValidityPeriodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StartDate is not None:
            showIndent(outfile, level)
            outfile.write('StartDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.StartDate, input_name='StartDate'))
        if self.EndDate is not None:
            showIndent(outfile, level)
            outfile.write('EndDate=model_.GeneratedsSuper.gds_parse_date("%s"),\n' % self.gds_format_date(self.EndDate, input_name='EndDate'))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StartDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.StartDate = dval_
        elif nodeName_ == 'EndDate':
            sval_ = child_.text
            dval_ = self.gds_parse_date(sval_)
            self.EndDate = dval_
# end class ValidityPeriodType


class EventSelectorType(GeneratedsSuper):
    """Allows subscribers to specify registry and repository events for
    which they wish to receive notifications."""
    subclass = None
    superclass = None
    def __init__(self, StructuralRepositoryEvents=None, ProvisioningRepositoryEvents=None, DataRegistrationEvents=None, MetadataRegistrationEvents=None):
        self.original_tagname_ = None
        self.StructuralRepositoryEvents = StructuralRepositoryEvents
        self.ProvisioningRepositoryEvents = ProvisioningRepositoryEvents
        self.DataRegistrationEvents = DataRegistrationEvents
        self.MetadataRegistrationEvents = MetadataRegistrationEvents
    def factory(*args_, **kwargs_):
        if EventSelectorType.subclass:
            return EventSelectorType.subclass(*args_, **kwargs_)
        else:
            return EventSelectorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StructuralRepositoryEvents(self): return self.StructuralRepositoryEvents
    def set_StructuralRepositoryEvents(self, StructuralRepositoryEvents): self.StructuralRepositoryEvents = StructuralRepositoryEvents
    def get_ProvisioningRepositoryEvents(self): return self.ProvisioningRepositoryEvents
    def set_ProvisioningRepositoryEvents(self, ProvisioningRepositoryEvents): self.ProvisioningRepositoryEvents = ProvisioningRepositoryEvents
    def get_DataRegistrationEvents(self): return self.DataRegistrationEvents
    def set_DataRegistrationEvents(self, DataRegistrationEvents): self.DataRegistrationEvents = DataRegistrationEvents
    def get_MetadataRegistrationEvents(self): return self.MetadataRegistrationEvents
    def set_MetadataRegistrationEvents(self, MetadataRegistrationEvents): self.MetadataRegistrationEvents = MetadataRegistrationEvents
    def hasContent_(self):
        if (
            self.StructuralRepositoryEvents is not None or
            self.ProvisioningRepositoryEvents is not None or
            self.DataRegistrationEvents is not None or
            self.MetadataRegistrationEvents is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='EventSelectorType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EventSelectorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='EventSelectorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='EventSelectorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='EventSelectorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StructuralRepositoryEvents is not None:
            self.StructuralRepositoryEvents.export(outfile, level, namespace_, name_='StructuralRepositoryEvents', pretty_print=pretty_print)
        if self.ProvisioningRepositoryEvents is not None:
            self.ProvisioningRepositoryEvents.export(outfile, level, namespace_, name_='ProvisioningRepositoryEvents', pretty_print=pretty_print)
        if self.DataRegistrationEvents is not None:
            self.DataRegistrationEvents.export(outfile, level, namespace_, name_='DataRegistrationEvents', pretty_print=pretty_print)
        if self.MetadataRegistrationEvents is not None:
            self.MetadataRegistrationEvents.export(outfile, level, namespace_, name_='MetadataRegistrationEvents', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EventSelectorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StructuralRepositoryEvents is not None:
            showIndent(outfile, level)
            outfile.write('StructuralRepositoryEvents=model_.StructuralRepositoryEventsType(\n')
            self.StructuralRepositoryEvents.exportLiteral(outfile, level, name_='StructuralRepositoryEvents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisioningRepositoryEvents is not None:
            showIndent(outfile, level)
            outfile.write('ProvisioningRepositoryEvents=model_.ProvisioningRepositoryEventsType(\n')
            self.ProvisioningRepositoryEvents.exportLiteral(outfile, level, name_='ProvisioningRepositoryEvents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataRegistrationEvents is not None:
            showIndent(outfile, level)
            outfile.write('DataRegistrationEvents=model_.DataRegistrationEventsType(\n')
            self.DataRegistrationEvents.exportLiteral(outfile, level, name_='DataRegistrationEvents')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataRegistrationEvents is not None:
            showIndent(outfile, level)
            outfile.write('MetadataRegistrationEvents=model_.MetadataRegistrationEventsType(\n')
            self.MetadataRegistrationEvents.exportLiteral(outfile, level, name_='MetadataRegistrationEvents')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StructuralRepositoryEvents':
            obj_ = StructuralRepositoryEventsType.factory()
            obj_.build(child_)
            self.StructuralRepositoryEvents = obj_
            obj_.original_tagname_ = 'StructuralRepositoryEvents'
        elif nodeName_ == 'ProvisioningRepositoryEvents':
            obj_ = ProvisioningRepositoryEventsType.factory()
            obj_.build(child_)
            self.ProvisioningRepositoryEvents = obj_
            obj_.original_tagname_ = 'ProvisioningRepositoryEvents'
        elif nodeName_ == 'DataRegistrationEvents':
            obj_ = DataRegistrationEventsType.factory()
            obj_.build(child_)
            self.DataRegistrationEvents = obj_
            obj_.original_tagname_ = 'DataRegistrationEvents'
        elif nodeName_ == 'MetadataRegistrationEvents':
            obj_ = MetadataRegistrationEventsType.factory()
            obj_.build(child_)
            self.MetadataRegistrationEvents = obj_
            obj_.original_tagname_ = 'MetadataRegistrationEvents'
# end class EventSelectorType


class StructuralRepositoryEventsType(GeneratedsSuper):
    """Contains details of the subscribed structural repository events.
    AgencyID specifies an agency for the object or objects indicated
    in the other ID fields. Note that the ID fields (including
    AgencyID) may hold a complete ID or Repository URN, but may also
    insert the "%" wildcard character, which represents 0 or more
    characters, in the ID string. If left empty, all objects will be
    matched within the other constraints (agency, object type)
    provided."""
    subclass = None
    superclass = None
    def __init__(self, AgencyID=None, AllEventsID=None, KeyFamilyID=None, ConceptSchemeID=None, CodeListID=None, MetadataStructureID=None, CategorySchemeID=None, DataflowID=None, MetadataflowID=None, OrganisationSchemeID=None, HierarchicalCodelistID=None, StructureSetID=None, ReportingTaxonomyID=None, ProcessID=None):
        self.original_tagname_ = None
        if AgencyID is None:
            self.AgencyID = []
        else:
            self.AgencyID = AgencyID
        if AllEventsID is None:
            self.AllEventsID = []
        else:
            self.AllEventsID = AllEventsID
        if KeyFamilyID is None:
            self.KeyFamilyID = []
        else:
            self.KeyFamilyID = KeyFamilyID
        if ConceptSchemeID is None:
            self.ConceptSchemeID = []
        else:
            self.ConceptSchemeID = ConceptSchemeID
        if CodeListID is None:
            self.CodeListID = []
        else:
            self.CodeListID = CodeListID
        if MetadataStructureID is None:
            self.MetadataStructureID = []
        else:
            self.MetadataStructureID = MetadataStructureID
        if CategorySchemeID is None:
            self.CategorySchemeID = []
        else:
            self.CategorySchemeID = CategorySchemeID
        if DataflowID is None:
            self.DataflowID = []
        else:
            self.DataflowID = DataflowID
        if MetadataflowID is None:
            self.MetadataflowID = []
        else:
            self.MetadataflowID = MetadataflowID
        if OrganisationSchemeID is None:
            self.OrganisationSchemeID = []
        else:
            self.OrganisationSchemeID = OrganisationSchemeID
        if HierarchicalCodelistID is None:
            self.HierarchicalCodelistID = []
        else:
            self.HierarchicalCodelistID = HierarchicalCodelistID
        if StructureSetID is None:
            self.StructureSetID = []
        else:
            self.StructureSetID = StructureSetID
        if ReportingTaxonomyID is None:
            self.ReportingTaxonomyID = []
        else:
            self.ReportingTaxonomyID = ReportingTaxonomyID
        if ProcessID is None:
            self.ProcessID = []
        else:
            self.ProcessID = ProcessID
    def factory(*args_, **kwargs_):
        if StructuralRepositoryEventsType.subclass:
            return StructuralRepositoryEventsType.subclass(*args_, **kwargs_)
        else:
            return StructuralRepositoryEventsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def add_AgencyID(self, value): self.AgencyID.append(value)
    def insert_AgencyID_at(self, index, value): self.AgencyID.insert(index, value)
    def replace_AgencyID_at(self, index, value): self.AgencyID[index] = value
    def get_AllEventsID(self): return self.AllEventsID
    def set_AllEventsID(self, AllEventsID): self.AllEventsID = AllEventsID
    def add_AllEventsID(self, value): self.AllEventsID.append(value)
    def insert_AllEventsID_at(self, index, value): self.AllEventsID.insert(index, value)
    def replace_AllEventsID_at(self, index, value): self.AllEventsID[index] = value
    def get_KeyFamilyID(self): return self.KeyFamilyID
    def set_KeyFamilyID(self, KeyFamilyID): self.KeyFamilyID = KeyFamilyID
    def add_KeyFamilyID(self, value): self.KeyFamilyID.append(value)
    def insert_KeyFamilyID_at(self, index, value): self.KeyFamilyID.insert(index, value)
    def replace_KeyFamilyID_at(self, index, value): self.KeyFamilyID[index] = value
    def get_ConceptSchemeID(self): return self.ConceptSchemeID
    def set_ConceptSchemeID(self, ConceptSchemeID): self.ConceptSchemeID = ConceptSchemeID
    def add_ConceptSchemeID(self, value): self.ConceptSchemeID.append(value)
    def insert_ConceptSchemeID_at(self, index, value): self.ConceptSchemeID.insert(index, value)
    def replace_ConceptSchemeID_at(self, index, value): self.ConceptSchemeID[index] = value
    def get_CodeListID(self): return self.CodeListID
    def set_CodeListID(self, CodeListID): self.CodeListID = CodeListID
    def add_CodeListID(self, value): self.CodeListID.append(value)
    def insert_CodeListID_at(self, index, value): self.CodeListID.insert(index, value)
    def replace_CodeListID_at(self, index, value): self.CodeListID[index] = value
    def get_MetadataStructureID(self): return self.MetadataStructureID
    def set_MetadataStructureID(self, MetadataStructureID): self.MetadataStructureID = MetadataStructureID
    def add_MetadataStructureID(self, value): self.MetadataStructureID.append(value)
    def insert_MetadataStructureID_at(self, index, value): self.MetadataStructureID.insert(index, value)
    def replace_MetadataStructureID_at(self, index, value): self.MetadataStructureID[index] = value
    def get_CategorySchemeID(self): return self.CategorySchemeID
    def set_CategorySchemeID(self, CategorySchemeID): self.CategorySchemeID = CategorySchemeID
    def add_CategorySchemeID(self, value): self.CategorySchemeID.append(value)
    def insert_CategorySchemeID_at(self, index, value): self.CategorySchemeID.insert(index, value)
    def replace_CategorySchemeID_at(self, index, value): self.CategorySchemeID[index] = value
    def get_DataflowID(self): return self.DataflowID
    def set_DataflowID(self, DataflowID): self.DataflowID = DataflowID
    def add_DataflowID(self, value): self.DataflowID.append(value)
    def insert_DataflowID_at(self, index, value): self.DataflowID.insert(index, value)
    def replace_DataflowID_at(self, index, value): self.DataflowID[index] = value
    def get_MetadataflowID(self): return self.MetadataflowID
    def set_MetadataflowID(self, MetadataflowID): self.MetadataflowID = MetadataflowID
    def add_MetadataflowID(self, value): self.MetadataflowID.append(value)
    def insert_MetadataflowID_at(self, index, value): self.MetadataflowID.insert(index, value)
    def replace_MetadataflowID_at(self, index, value): self.MetadataflowID[index] = value
    def get_OrganisationSchemeID(self): return self.OrganisationSchemeID
    def set_OrganisationSchemeID(self, OrganisationSchemeID): self.OrganisationSchemeID = OrganisationSchemeID
    def add_OrganisationSchemeID(self, value): self.OrganisationSchemeID.append(value)
    def insert_OrganisationSchemeID_at(self, index, value): self.OrganisationSchemeID.insert(index, value)
    def replace_OrganisationSchemeID_at(self, index, value): self.OrganisationSchemeID[index] = value
    def get_HierarchicalCodelistID(self): return self.HierarchicalCodelistID
    def set_HierarchicalCodelistID(self, HierarchicalCodelistID): self.HierarchicalCodelistID = HierarchicalCodelistID
    def add_HierarchicalCodelistID(self, value): self.HierarchicalCodelistID.append(value)
    def insert_HierarchicalCodelistID_at(self, index, value): self.HierarchicalCodelistID.insert(index, value)
    def replace_HierarchicalCodelistID_at(self, index, value): self.HierarchicalCodelistID[index] = value
    def get_StructureSetID(self): return self.StructureSetID
    def set_StructureSetID(self, StructureSetID): self.StructureSetID = StructureSetID
    def add_StructureSetID(self, value): self.StructureSetID.append(value)
    def insert_StructureSetID_at(self, index, value): self.StructureSetID.insert(index, value)
    def replace_StructureSetID_at(self, index, value): self.StructureSetID[index] = value
    def get_ReportingTaxonomyID(self): return self.ReportingTaxonomyID
    def set_ReportingTaxonomyID(self, ReportingTaxonomyID): self.ReportingTaxonomyID = ReportingTaxonomyID
    def add_ReportingTaxonomyID(self, value): self.ReportingTaxonomyID.append(value)
    def insert_ReportingTaxonomyID_at(self, index, value): self.ReportingTaxonomyID.insert(index, value)
    def replace_ReportingTaxonomyID_at(self, index, value): self.ReportingTaxonomyID[index] = value
    def get_ProcessID(self): return self.ProcessID
    def set_ProcessID(self, ProcessID): self.ProcessID = ProcessID
    def add_ProcessID(self, value): self.ProcessID.append(value)
    def insert_ProcessID_at(self, index, value): self.ProcessID.insert(index, value)
    def replace_ProcessID_at(self, index, value): self.ProcessID[index] = value
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.AgencyID or
            self.AllEventsID or
            self.KeyFamilyID or
            self.ConceptSchemeID or
            self.CodeListID or
            self.MetadataStructureID or
            self.CategorySchemeID or
            self.DataflowID or
            self.MetadataflowID or
            self.OrganisationSchemeID or
            self.HierarchicalCodelistID or
            self.StructureSetID or
            self.ReportingTaxonomyID or
            self.ProcessID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructuralRepositoryEventsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuralRepositoryEventsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructuralRepositoryEventsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructuralRepositoryEventsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructuralRepositoryEventsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(AgencyID_).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEventsID>%s</%sAllEventsID>%s' % (namespace_, self.gds_format_string(quote_xml(AllEventsID_).encode(ExternalEncoding), input_name='AllEventsID'), namespace_, eol_))
        for KeyFamilyID_ in self.KeyFamilyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyID>%s</%sKeyFamilyID>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamilyID_).encode(ExternalEncoding), input_name='KeyFamilyID'), namespace_, eol_))
        for ConceptSchemeID_ in self.ConceptSchemeID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sConceptSchemeID>%s</%sConceptSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(ConceptSchemeID_).encode(ExternalEncoding), input_name='ConceptSchemeID'), namespace_, eol_))
        for CodeListID_ in self.CodeListID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCodeListID>%s</%sCodeListID>%s' % (namespace_, self.gds_format_string(quote_xml(CodeListID_).encode(ExternalEncoding), input_name='CodeListID'), namespace_, eol_))
        for MetadataStructureID_ in self.MetadataStructureID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructureID>%s</%sMetadataStructureID>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataStructureID_).encode(ExternalEncoding), input_name='MetadataStructureID'), namespace_, eol_))
        for CategorySchemeID_ in self.CategorySchemeID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeID>%s</%sCategorySchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(CategorySchemeID_).encode(ExternalEncoding), input_name='CategorySchemeID'), namespace_, eol_))
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowID>%s</%sDataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(DataflowID_).encode(ExternalEncoding), input_name='DataflowID'), namespace_, eol_))
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflowID>%s</%sMetadataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataflowID_).encode(ExternalEncoding), input_name='MetadataflowID'), namespace_, eol_))
        for OrganisationSchemeID_ in self.OrganisationSchemeID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeID>%s</%sOrganisationSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(OrganisationSchemeID_).encode(ExternalEncoding), input_name='OrganisationSchemeID'), namespace_, eol_))
        for HierarchicalCodelistID_ in self.HierarchicalCodelistID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sHierarchicalCodelistID>%s</%sHierarchicalCodelistID>%s' % (namespace_, self.gds_format_string(quote_xml(HierarchicalCodelistID_).encode(ExternalEncoding), input_name='HierarchicalCodelistID'), namespace_, eol_))
        for StructureSetID_ in self.StructureSetID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureSetID>%s</%sStructureSetID>%s' % (namespace_, self.gds_format_string(quote_xml(StructureSetID_).encode(ExternalEncoding), input_name='StructureSetID'), namespace_, eol_))
        for ReportingTaxonomyID_ in self.ReportingTaxonomyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportingTaxonomyID>%s</%sReportingTaxonomyID>%s' % (namespace_, self.gds_format_string(quote_xml(ReportingTaxonomyID_).encode(ExternalEncoding), input_name='ReportingTaxonomyID'), namespace_, eol_))
        for ProcessID_ in self.ProcessID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessID>%s</%sProcessID>%s' % (namespace_, self.gds_format_string(quote_xml(ProcessID_).encode(ExternalEncoding), input_name='ProcessID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='StructuralRepositoryEventsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AgencyID=[\n')
        level += 1
        for AgencyID_ in self.AgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllEventsID=[\n')
        level += 1
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllEventsID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamilyID=[\n')
        level += 1
        for KeyFamilyID_ in self.KeyFamilyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamilyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ConceptSchemeID=[\n')
        level += 1
        for ConceptSchemeID_ in self.ConceptSchemeID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ConceptSchemeID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CodeListID=[\n')
        level += 1
        for CodeListID_ in self.CodeListID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CodeListID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataStructureID=[\n')
        level += 1
        for MetadataStructureID_ in self.MetadataStructureID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataStructureID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeID=[\n')
        level += 1
        for CategorySchemeID_ in self.CategorySchemeID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategorySchemeID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowID=[\n')
        level += 1
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowID=[\n')
        level += 1
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('OrganisationSchemeID=[\n')
        level += 1
        for OrganisationSchemeID_ in self.OrganisationSchemeID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(OrganisationSchemeID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('HierarchicalCodelistID=[\n')
        level += 1
        for HierarchicalCodelistID_ in self.HierarchicalCodelistID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(HierarchicalCodelistID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('StructureSetID=[\n')
        level += 1
        for StructureSetID_ in self.StructureSetID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(StructureSetID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ReportingTaxonomyID=[\n')
        level += 1
        for ReportingTaxonomyID_ in self.ReportingTaxonomyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ReportingTaxonomyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProcessID=[\n')
        level += 1
        for ProcessID_ in self.ProcessID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProcessID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID.append(AgencyID_)
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'AllEventsID':
            AllEventsID_ = child_.text
            AllEventsID_ = self.gds_validate_string(AllEventsID_, node, 'AllEventsID')
            self.AllEventsID.append(AllEventsID_)
        elif nodeName_ == 'KeyFamilyID':
            KeyFamilyID_ = child_.text
            KeyFamilyID_ = self.gds_validate_string(KeyFamilyID_, node, 'KeyFamilyID')
            self.KeyFamilyID.append(KeyFamilyID_)
        elif nodeName_ == 'ConceptSchemeID':
            ConceptSchemeID_ = child_.text
            ConceptSchemeID_ = self.gds_validate_string(ConceptSchemeID_, node, 'ConceptSchemeID')
            self.ConceptSchemeID.append(ConceptSchemeID_)
        elif nodeName_ == 'CodeListID':
            CodeListID_ = child_.text
            CodeListID_ = self.gds_validate_string(CodeListID_, node, 'CodeListID')
            self.CodeListID.append(CodeListID_)
        elif nodeName_ == 'MetadataStructureID':
            MetadataStructureID_ = child_.text
            MetadataStructureID_ = self.gds_validate_string(MetadataStructureID_, node, 'MetadataStructureID')
            self.MetadataStructureID.append(MetadataStructureID_)
        elif nodeName_ == 'CategorySchemeID':
            CategorySchemeID_ = child_.text
            CategorySchemeID_ = self.gds_validate_string(CategorySchemeID_, node, 'CategorySchemeID')
            self.CategorySchemeID.append(CategorySchemeID_)
        elif nodeName_ == 'DataflowID':
            DataflowID_ = child_.text
            DataflowID_ = self.gds_validate_string(DataflowID_, node, 'DataflowID')
            self.DataflowID.append(DataflowID_)
        elif nodeName_ == 'MetadataflowID':
            MetadataflowID_ = child_.text
            MetadataflowID_ = self.gds_validate_string(MetadataflowID_, node, 'MetadataflowID')
            self.MetadataflowID.append(MetadataflowID_)
        elif nodeName_ == 'OrganisationSchemeID':
            OrganisationSchemeID_ = child_.text
            OrganisationSchemeID_ = self.gds_validate_string(OrganisationSchemeID_, node, 'OrganisationSchemeID')
            self.OrganisationSchemeID.append(OrganisationSchemeID_)
        elif nodeName_ == 'HierarchicalCodelistID':
            HierarchicalCodelistID_ = child_.text
            HierarchicalCodelistID_ = self.gds_validate_string(HierarchicalCodelistID_, node, 'HierarchicalCodelistID')
            self.HierarchicalCodelistID.append(HierarchicalCodelistID_)
        elif nodeName_ == 'StructureSetID':
            StructureSetID_ = child_.text
            StructureSetID_ = self.gds_validate_string(StructureSetID_, node, 'StructureSetID')
            self.StructureSetID.append(StructureSetID_)
        elif nodeName_ == 'ReportingTaxonomyID':
            ReportingTaxonomyID_ = child_.text
            ReportingTaxonomyID_ = self.gds_validate_string(ReportingTaxonomyID_, node, 'ReportingTaxonomyID')
            self.ReportingTaxonomyID.append(ReportingTaxonomyID_)
        elif nodeName_ == 'ProcessID':
            ProcessID_ = child_.text
            ProcessID_ = self.gds_validate_string(ProcessID_, node, 'ProcessID')
            self.ProcessID.append(ProcessID_)
# end class StructuralRepositoryEventsType


class ProvisioningRepositoryEventsType(GeneratedsSuper):
    """Contains details of the subscribed provisioning repository events.
    Note that the ID fields may hold a complete ID or Repository
    URN, but may also insert the "%" wildcard character, which
    represents 0 or more characters, in the ID string. If left
    empty, all objects will be matched within the other constraints
    (agency, object type) provided."""
    subclass = None
    superclass = None
    def __init__(self, ProvisionAgreementID=None, DataProviderID=None, DataflowID=None, MetadataflowID=None, AllEventsID=None):
        self.original_tagname_ = None
        if ProvisionAgreementID is None:
            self.ProvisionAgreementID = []
        else:
            self.ProvisionAgreementID = ProvisionAgreementID
        if DataProviderID is None:
            self.DataProviderID = []
        else:
            self.DataProviderID = DataProviderID
        if DataflowID is None:
            self.DataflowID = []
        else:
            self.DataflowID = DataflowID
        if MetadataflowID is None:
            self.MetadataflowID = []
        else:
            self.MetadataflowID = MetadataflowID
        if AllEventsID is None:
            self.AllEventsID = []
        else:
            self.AllEventsID = AllEventsID
    def factory(*args_, **kwargs_):
        if ProvisioningRepositoryEventsType.subclass:
            return ProvisioningRepositoryEventsType.subclass(*args_, **kwargs_)
        else:
            return ProvisioningRepositoryEventsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisionAgreementID(self): return self.ProvisionAgreementID
    def set_ProvisionAgreementID(self, ProvisionAgreementID): self.ProvisionAgreementID = ProvisionAgreementID
    def add_ProvisionAgreementID(self, value): self.ProvisionAgreementID.append(value)
    def insert_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID.insert(index, value)
    def replace_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID[index] = value
    def get_DataProviderID(self): return self.DataProviderID
    def set_DataProviderID(self, DataProviderID): self.DataProviderID = DataProviderID
    def add_DataProviderID(self, value): self.DataProviderID.append(value)
    def insert_DataProviderID_at(self, index, value): self.DataProviderID.insert(index, value)
    def replace_DataProviderID_at(self, index, value): self.DataProviderID[index] = value
    def get_DataflowID(self): return self.DataflowID
    def set_DataflowID(self, DataflowID): self.DataflowID = DataflowID
    def add_DataflowID(self, value): self.DataflowID.append(value)
    def insert_DataflowID_at(self, index, value): self.DataflowID.insert(index, value)
    def replace_DataflowID_at(self, index, value): self.DataflowID[index] = value
    def get_MetadataflowID(self): return self.MetadataflowID
    def set_MetadataflowID(self, MetadataflowID): self.MetadataflowID = MetadataflowID
    def add_MetadataflowID(self, value): self.MetadataflowID.append(value)
    def insert_MetadataflowID_at(self, index, value): self.MetadataflowID.insert(index, value)
    def replace_MetadataflowID_at(self, index, value): self.MetadataflowID[index] = value
    def get_AllEventsID(self): return self.AllEventsID
    def set_AllEventsID(self, AllEventsID): self.AllEventsID = AllEventsID
    def add_AllEventsID(self, value): self.AllEventsID.append(value)
    def insert_AllEventsID_at(self, index, value): self.AllEventsID.insert(index, value)
    def replace_AllEventsID_at(self, index, value): self.AllEventsID[index] = value
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.ProvisionAgreementID or
            self.DataProviderID or
            self.DataflowID or
            self.MetadataflowID or
            self.AllEventsID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProvisioningRepositoryEventsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProvisioningRepositoryEventsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProvisioningRepositoryEventsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProvisioningRepositoryEventsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProvisioningRepositoryEventsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvisionAgreementID>%s</%sProvisionAgreementID>%s' % (namespace_, self.gds_format_string(quote_xml(ProvisionAgreementID_).encode(ExternalEncoding), input_name='ProvisionAgreementID'), namespace_, eol_))
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderID>%s</%sDataProviderID>%s' % (namespace_, self.gds_format_string(quote_xml(DataProviderID_).encode(ExternalEncoding), input_name='DataProviderID'), namespace_, eol_))
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowID>%s</%sDataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(DataflowID_).encode(ExternalEncoding), input_name='DataflowID'), namespace_, eol_))
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflowID>%s</%sMetadataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataflowID_).encode(ExternalEncoding), input_name='MetadataflowID'), namespace_, eol_))
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEventsID>%s</%sAllEventsID>%s' % (namespace_, self.gds_format_string(quote_xml(AllEventsID_).encode(ExternalEncoding), input_name='AllEventsID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ProvisioningRepositoryEventsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ProvisionAgreementID=[\n')
        level += 1
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProvisionAgreementID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderID=[\n')
        level += 1
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProviderID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowID=[\n')
        level += 1
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowID=[\n')
        level += 1
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('AllEventsID=[\n')
        level += 1
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllEventsID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisionAgreementID':
            ProvisionAgreementID_ = child_.text
            ProvisionAgreementID_ = self.gds_validate_string(ProvisionAgreementID_, node, 'ProvisionAgreementID')
            self.ProvisionAgreementID.append(ProvisionAgreementID_)
            self.validate_IDType(self.ProvisionAgreementID)    # validate type IDType
        elif nodeName_ == 'DataProviderID':
            DataProviderID_ = child_.text
            DataProviderID_ = self.gds_validate_string(DataProviderID_, node, 'DataProviderID')
            self.DataProviderID.append(DataProviderID_)
        elif nodeName_ == 'DataflowID':
            DataflowID_ = child_.text
            DataflowID_ = self.gds_validate_string(DataflowID_, node, 'DataflowID')
            self.DataflowID.append(DataflowID_)
        elif nodeName_ == 'MetadataflowID':
            MetadataflowID_ = child_.text
            MetadataflowID_ = self.gds_validate_string(MetadataflowID_, node, 'MetadataflowID')
            self.MetadataflowID.append(MetadataflowID_)
        elif nodeName_ == 'AllEventsID':
            AllEventsID_ = child_.text
            AllEventsID_ = self.gds_validate_string(AllEventsID_, node, 'AllEventsID')
            self.AllEventsID.append(AllEventsID_)
# end class ProvisioningRepositoryEventsType


class DataRegistrationEventsType(GeneratedsSuper):
    """Contains details of the subscribed data registry events. Note that
    the ID fields may hold a complete ID or Registry URN, but may
    also insert the "%" wildcard character, which represents 0 or
    more characters, in the ID string. If left empty, all objects
    will be matched within the other constraints (agency, object
    type) provided."""
    subclass = None
    superclass = None
    def __init__(self, AllEventsID=None, DataProviderID=None, ProvisionAgreementID=None, DataflowID=None, KeyFamilyID=None, CategoryID=None, CategorySchemeID=None, CategorySchemeAgencyID=None):
        self.original_tagname_ = None
        if AllEventsID is None:
            self.AllEventsID = []
        else:
            self.AllEventsID = AllEventsID
        if DataProviderID is None:
            self.DataProviderID = []
        else:
            self.DataProviderID = DataProviderID
        if ProvisionAgreementID is None:
            self.ProvisionAgreementID = []
        else:
            self.ProvisionAgreementID = ProvisionAgreementID
        if DataflowID is None:
            self.DataflowID = []
        else:
            self.DataflowID = DataflowID
        if KeyFamilyID is None:
            self.KeyFamilyID = []
        else:
            self.KeyFamilyID = KeyFamilyID
        if CategoryID is None:
            self.CategoryID = []
        else:
            self.CategoryID = CategoryID
        if CategorySchemeID is None:
            self.CategorySchemeID = []
        else:
            self.CategorySchemeID = CategorySchemeID
        if CategorySchemeAgencyID is None:
            self.CategorySchemeAgencyID = []
        else:
            self.CategorySchemeAgencyID = CategorySchemeAgencyID
    def factory(*args_, **kwargs_):
        if DataRegistrationEventsType.subclass:
            return DataRegistrationEventsType.subclass(*args_, **kwargs_)
        else:
            return DataRegistrationEventsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEventsID(self): return self.AllEventsID
    def set_AllEventsID(self, AllEventsID): self.AllEventsID = AllEventsID
    def add_AllEventsID(self, value): self.AllEventsID.append(value)
    def insert_AllEventsID_at(self, index, value): self.AllEventsID.insert(index, value)
    def replace_AllEventsID_at(self, index, value): self.AllEventsID[index] = value
    def get_DataProviderID(self): return self.DataProviderID
    def set_DataProviderID(self, DataProviderID): self.DataProviderID = DataProviderID
    def add_DataProviderID(self, value): self.DataProviderID.append(value)
    def insert_DataProviderID_at(self, index, value): self.DataProviderID.insert(index, value)
    def replace_DataProviderID_at(self, index, value): self.DataProviderID[index] = value
    def get_ProvisionAgreementID(self): return self.ProvisionAgreementID
    def set_ProvisionAgreementID(self, ProvisionAgreementID): self.ProvisionAgreementID = ProvisionAgreementID
    def add_ProvisionAgreementID(self, value): self.ProvisionAgreementID.append(value)
    def insert_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID.insert(index, value)
    def replace_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID[index] = value
    def get_DataflowID(self): return self.DataflowID
    def set_DataflowID(self, DataflowID): self.DataflowID = DataflowID
    def add_DataflowID(self, value): self.DataflowID.append(value)
    def insert_DataflowID_at(self, index, value): self.DataflowID.insert(index, value)
    def replace_DataflowID_at(self, index, value): self.DataflowID[index] = value
    def get_KeyFamilyID(self): return self.KeyFamilyID
    def set_KeyFamilyID(self, KeyFamilyID): self.KeyFamilyID = KeyFamilyID
    def add_KeyFamilyID(self, value): self.KeyFamilyID.append(value)
    def insert_KeyFamilyID_at(self, index, value): self.KeyFamilyID.insert(index, value)
    def replace_KeyFamilyID_at(self, index, value): self.KeyFamilyID[index] = value
    def get_CategoryID(self): return self.CategoryID
    def set_CategoryID(self, CategoryID): self.CategoryID = CategoryID
    def add_CategoryID(self, value): self.CategoryID.append(value)
    def insert_CategoryID_at(self, index, value): self.CategoryID.insert(index, value)
    def replace_CategoryID_at(self, index, value): self.CategoryID[index] = value
    def get_CategorySchemeID(self): return self.CategorySchemeID
    def set_CategorySchemeID(self, CategorySchemeID): self.CategorySchemeID = CategorySchemeID
    def add_CategorySchemeID(self, value): self.CategorySchemeID.append(value)
    def insert_CategorySchemeID_at(self, index, value): self.CategorySchemeID.insert(index, value)
    def replace_CategorySchemeID_at(self, index, value): self.CategorySchemeID[index] = value
    def get_CategorySchemeAgencyID(self): return self.CategorySchemeAgencyID
    def set_CategorySchemeAgencyID(self, CategorySchemeAgencyID): self.CategorySchemeAgencyID = CategorySchemeAgencyID
    def add_CategorySchemeAgencyID(self, value): self.CategorySchemeAgencyID.append(value)
    def insert_CategorySchemeAgencyID_at(self, index, value): self.CategorySchemeAgencyID.insert(index, value)
    def replace_CategorySchemeAgencyID_at(self, index, value): self.CategorySchemeAgencyID[index] = value
    def hasContent_(self):
        if (
            self.AllEventsID or
            self.DataProviderID or
            self.ProvisionAgreementID or
            self.DataflowID or
            self.KeyFamilyID or
            self.CategoryID or
            self.CategorySchemeID or
            self.CategorySchemeAgencyID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DataRegistrationEventsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DataRegistrationEventsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DataRegistrationEventsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DataRegistrationEventsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DataRegistrationEventsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEventsID>%s</%sAllEventsID>%s' % (namespace_, self.gds_format_string(quote_xml(AllEventsID_).encode(ExternalEncoding), input_name='AllEventsID'), namespace_, eol_))
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderID>%s</%sDataProviderID>%s' % (namespace_, self.gds_format_string(quote_xml(DataProviderID_).encode(ExternalEncoding), input_name='DataProviderID'), namespace_, eol_))
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvisionAgreementID>%s</%sProvisionAgreementID>%s' % (namespace_, self.gds_format_string(quote_xml(ProvisionAgreementID_).encode(ExternalEncoding), input_name='ProvisionAgreementID'), namespace_, eol_))
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataflowID>%s</%sDataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(DataflowID_).encode(ExternalEncoding), input_name='DataflowID'), namespace_, eol_))
        for KeyFamilyID_ in self.KeyFamilyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sKeyFamilyID>%s</%sKeyFamilyID>%s' % (namespace_, self.gds_format_string(quote_xml(KeyFamilyID_).encode(ExternalEncoding), input_name='KeyFamilyID'), namespace_, eol_))
        for CategoryID_ in self.CategoryID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryID>%s</%sCategoryID>%s' % (namespace_, self.gds_format_string(quote_xml(CategoryID_).encode(ExternalEncoding), input_name='CategoryID'), namespace_, eol_))
        for CategorySchemeID_ in self.CategorySchemeID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeID>%s</%sCategorySchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(CategorySchemeID_).encode(ExternalEncoding), input_name='CategorySchemeID'), namespace_, eol_))
        for CategorySchemeAgencyID_ in self.CategorySchemeAgencyID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategorySchemeAgencyID>%s</%sCategorySchemeAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(CategorySchemeAgencyID_).encode(ExternalEncoding), input_name='CategorySchemeAgencyID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='DataRegistrationEventsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AllEventsID=[\n')
        level += 1
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllEventsID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderID=[\n')
        level += 1
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProviderID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProvisionAgreementID=[\n')
        level += 1
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProvisionAgreementID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataflowID=[\n')
        level += 1
        for DataflowID_ in self.DataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('KeyFamilyID=[\n')
        level += 1
        for KeyFamilyID_ in self.KeyFamilyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(KeyFamilyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategoryID=[\n')
        level += 1
        for CategoryID_ in self.CategoryID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategoryID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeID=[\n')
        level += 1
        for CategorySchemeID_ in self.CategorySchemeID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategorySchemeID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategorySchemeAgencyID=[\n')
        level += 1
        for CategorySchemeAgencyID_ in self.CategorySchemeAgencyID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategorySchemeAgencyID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEventsID':
            AllEventsID_ = child_.text
            AllEventsID_ = self.gds_validate_string(AllEventsID_, node, 'AllEventsID')
            self.AllEventsID.append(AllEventsID_)
        elif nodeName_ == 'DataProviderID':
            DataProviderID_ = child_.text
            DataProviderID_ = self.gds_validate_string(DataProviderID_, node, 'DataProviderID')
            self.DataProviderID.append(DataProviderID_)
        elif nodeName_ == 'ProvisionAgreementID':
            ProvisionAgreementID_ = child_.text
            ProvisionAgreementID_ = self.gds_validate_string(ProvisionAgreementID_, node, 'ProvisionAgreementID')
            self.ProvisionAgreementID.append(ProvisionAgreementID_)
        elif nodeName_ == 'DataflowID':
            DataflowID_ = child_.text
            DataflowID_ = self.gds_validate_string(DataflowID_, node, 'DataflowID')
            self.DataflowID.append(DataflowID_)
        elif nodeName_ == 'KeyFamilyID':
            KeyFamilyID_ = child_.text
            KeyFamilyID_ = self.gds_validate_string(KeyFamilyID_, node, 'KeyFamilyID')
            self.KeyFamilyID.append(KeyFamilyID_)
        elif nodeName_ == 'CategoryID':
            CategoryID_ = child_.text
            CategoryID_ = self.gds_validate_string(CategoryID_, node, 'CategoryID')
            self.CategoryID.append(CategoryID_)
        elif nodeName_ == 'CategorySchemeID':
            CategorySchemeID_ = child_.text
            CategorySchemeID_ = self.gds_validate_string(CategorySchemeID_, node, 'CategorySchemeID')
            self.CategorySchemeID.append(CategorySchemeID_)
        elif nodeName_ == 'CategorySchemeAgencyID':
            CategorySchemeAgencyID_ = child_.text
            CategorySchemeAgencyID_ = self.gds_validate_string(CategorySchemeAgencyID_, node, 'CategorySchemeAgencyID')
            self.CategorySchemeAgencyID.append(CategorySchemeAgencyID_)
# end class DataRegistrationEventsType


class MetadataRegistrationEventsType(GeneratedsSuper):
    """Contains details of the subscribed metadadata registry events. Note
    that the ID fields may hold a complete ID or Registry URN, but
    may also insert the "%" wildcard character, which represents 0
    or more characters, in the ID string. If left empty, all objects
    will be matched within the other constraints (agency, object
    type) provided."""
    subclass = None
    superclass = None
    def __init__(self, AllEventsID=None, DataProviderID=None, ProvisionAgreementID=None, MetadataflowID=None, MetadatastructureID=None, CategoryID=None):
        self.original_tagname_ = None
        if AllEventsID is None:
            self.AllEventsID = []
        else:
            self.AllEventsID = AllEventsID
        if DataProviderID is None:
            self.DataProviderID = []
        else:
            self.DataProviderID = DataProviderID
        if ProvisionAgreementID is None:
            self.ProvisionAgreementID = []
        else:
            self.ProvisionAgreementID = ProvisionAgreementID
        if MetadataflowID is None:
            self.MetadataflowID = []
        else:
            self.MetadataflowID = MetadataflowID
        if MetadatastructureID is None:
            self.MetadatastructureID = []
        else:
            self.MetadatastructureID = MetadatastructureID
        if CategoryID is None:
            self.CategoryID = []
        else:
            self.CategoryID = CategoryID
    def factory(*args_, **kwargs_):
        if MetadataRegistrationEventsType.subclass:
            return MetadataRegistrationEventsType.subclass(*args_, **kwargs_)
        else:
            return MetadataRegistrationEventsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AllEventsID(self): return self.AllEventsID
    def set_AllEventsID(self, AllEventsID): self.AllEventsID = AllEventsID
    def add_AllEventsID(self, value): self.AllEventsID.append(value)
    def insert_AllEventsID_at(self, index, value): self.AllEventsID.insert(index, value)
    def replace_AllEventsID_at(self, index, value): self.AllEventsID[index] = value
    def get_DataProviderID(self): return self.DataProviderID
    def set_DataProviderID(self, DataProviderID): self.DataProviderID = DataProviderID
    def add_DataProviderID(self, value): self.DataProviderID.append(value)
    def insert_DataProviderID_at(self, index, value): self.DataProviderID.insert(index, value)
    def replace_DataProviderID_at(self, index, value): self.DataProviderID[index] = value
    def get_ProvisionAgreementID(self): return self.ProvisionAgreementID
    def set_ProvisionAgreementID(self, ProvisionAgreementID): self.ProvisionAgreementID = ProvisionAgreementID
    def add_ProvisionAgreementID(self, value): self.ProvisionAgreementID.append(value)
    def insert_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID.insert(index, value)
    def replace_ProvisionAgreementID_at(self, index, value): self.ProvisionAgreementID[index] = value
    def get_MetadataflowID(self): return self.MetadataflowID
    def set_MetadataflowID(self, MetadataflowID): self.MetadataflowID = MetadataflowID
    def add_MetadataflowID(self, value): self.MetadataflowID.append(value)
    def insert_MetadataflowID_at(self, index, value): self.MetadataflowID.insert(index, value)
    def replace_MetadataflowID_at(self, index, value): self.MetadataflowID[index] = value
    def get_MetadatastructureID(self): return self.MetadatastructureID
    def set_MetadatastructureID(self, MetadatastructureID): self.MetadatastructureID = MetadatastructureID
    def add_MetadatastructureID(self, value): self.MetadatastructureID.append(value)
    def insert_MetadatastructureID_at(self, index, value): self.MetadatastructureID.insert(index, value)
    def replace_MetadatastructureID_at(self, index, value): self.MetadatastructureID[index] = value
    def get_CategoryID(self): return self.CategoryID
    def set_CategoryID(self, CategoryID): self.CategoryID = CategoryID
    def add_CategoryID(self, value): self.CategoryID.append(value)
    def insert_CategoryID_at(self, index, value): self.CategoryID.insert(index, value)
    def replace_CategoryID_at(self, index, value): self.CategoryID[index] = value
    def hasContent_(self):
        if (
            self.AllEventsID or
            self.DataProviderID or
            self.ProvisionAgreementID or
            self.MetadataflowID or
            self.MetadatastructureID or
            self.CategoryID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataRegistrationEventsType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataRegistrationEventsType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataRegistrationEventsType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataRegistrationEventsType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataRegistrationEventsType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAllEventsID>%s</%sAllEventsID>%s' % (namespace_, self.gds_format_string(quote_xml(AllEventsID_).encode(ExternalEncoding), input_name='AllEventsID'), namespace_, eol_))
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataProviderID>%s</%sDataProviderID>%s' % (namespace_, self.gds_format_string(quote_xml(DataProviderID_).encode(ExternalEncoding), input_name='DataProviderID'), namespace_, eol_))
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProvisionAgreementID>%s</%sProvisionAgreementID>%s' % (namespace_, self.gds_format_string(quote_xml(ProvisionAgreementID_).encode(ExternalEncoding), input_name='ProvisionAgreementID'), namespace_, eol_))
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataflowID>%s</%sMetadataflowID>%s' % (namespace_, self.gds_format_string(quote_xml(MetadataflowID_).encode(ExternalEncoding), input_name='MetadataflowID'), namespace_, eol_))
        for MetadatastructureID_ in self.MetadatastructureID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadatastructureID>%s</%sMetadatastructureID>%s' % (namespace_, self.gds_format_string(quote_xml(MetadatastructureID_).encode(ExternalEncoding), input_name='MetadatastructureID'), namespace_, eol_))
        for CategoryID_ in self.CategoryID:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCategoryID>%s</%sCategoryID>%s' % (namespace_, self.gds_format_string(quote_xml(CategoryID_).encode(ExternalEncoding), input_name='CategoryID'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='MetadataRegistrationEventsType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AllEventsID=[\n')
        level += 1
        for AllEventsID_ in self.AllEventsID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(AllEventsID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DataProviderID=[\n')
        level += 1
        for DataProviderID_ in self.DataProviderID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(DataProviderID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ProvisionAgreementID=[\n')
        level += 1
        for ProvisionAgreementID_ in self.ProvisionAgreementID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(ProvisionAgreementID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadataflowID=[\n')
        level += 1
        for MetadataflowID_ in self.MetadataflowID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadataflowID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('MetadatastructureID=[\n')
        level += 1
        for MetadatastructureID_ in self.MetadatastructureID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(MetadatastructureID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('CategoryID=[\n')
        level += 1
        for CategoryID_ in self.CategoryID:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(CategoryID_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AllEventsID':
            AllEventsID_ = child_.text
            AllEventsID_ = self.gds_validate_string(AllEventsID_, node, 'AllEventsID')
            self.AllEventsID.append(AllEventsID_)
        elif nodeName_ == 'DataProviderID':
            DataProviderID_ = child_.text
            DataProviderID_ = self.gds_validate_string(DataProviderID_, node, 'DataProviderID')
            self.DataProviderID.append(DataProviderID_)
        elif nodeName_ == 'ProvisionAgreementID':
            ProvisionAgreementID_ = child_.text
            ProvisionAgreementID_ = self.gds_validate_string(ProvisionAgreementID_, node, 'ProvisionAgreementID')
            self.ProvisionAgreementID.append(ProvisionAgreementID_)
        elif nodeName_ == 'MetadataflowID':
            MetadataflowID_ = child_.text
            MetadataflowID_ = self.gds_validate_string(MetadataflowID_, node, 'MetadataflowID')
            self.MetadataflowID.append(MetadataflowID_)
        elif nodeName_ == 'MetadatastructureID':
            MetadatastructureID_ = child_.text
            MetadatastructureID_ = self.gds_validate_string(MetadatastructureID_, node, 'MetadatastructureID')
            self.MetadatastructureID.append(MetadatastructureID_)
        elif nodeName_ == 'CategoryID':
            CategoryID_ = child_.text
            CategoryID_ = self.gds_validate_string(CategoryID_, node, 'CategoryID')
            self.CategoryID.append(CategoryID_)
# end class MetadataRegistrationEventsType


class StructuralEventType(GeneratedsSuper):
    """This provides the details of a structural repository event for the
    purposes of notification."""
    subclass = None
    superclass = None
    def __init__(self, OrganisationSchemes=None, Dataflows=None, Metadataflows=None, CategorySchemes=None, CodeLists=None, HierarchicalCodelists=None, Concepts=None, MetadataStructureDefinitions=None, KeyFamilies=None, StructureSets=None, Processes=None, ReportingTaxonomies=None):
        self.original_tagname_ = None
        self.OrganisationSchemes = OrganisationSchemes
        self.Dataflows = Dataflows
        self.Metadataflows = Metadataflows
        self.CategorySchemes = CategorySchemes
        self.CodeLists = CodeLists
        self.HierarchicalCodelists = HierarchicalCodelists
        self.Concepts = Concepts
        self.MetadataStructureDefinitions = MetadataStructureDefinitions
        self.KeyFamilies = KeyFamilies
        self.StructureSets = StructureSets
        self.Processes = Processes
        self.ReportingTaxonomies = ReportingTaxonomies
    def factory(*args_, **kwargs_):
        if StructuralEventType.subclass:
            return StructuralEventType.subclass(*args_, **kwargs_)
        else:
            return StructuralEventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OrganisationSchemes(self): return self.OrganisationSchemes
    def set_OrganisationSchemes(self, OrganisationSchemes): self.OrganisationSchemes = OrganisationSchemes
    def get_Dataflows(self): return self.Dataflows
    def set_Dataflows(self, Dataflows): self.Dataflows = Dataflows
    def get_Metadataflows(self): return self.Metadataflows
    def set_Metadataflows(self, Metadataflows): self.Metadataflows = Metadataflows
    def get_CategorySchemes(self): return self.CategorySchemes
    def set_CategorySchemes(self, CategorySchemes): self.CategorySchemes = CategorySchemes
    def get_CodeLists(self): return self.CodeLists
    def set_CodeLists(self, CodeLists): self.CodeLists = CodeLists
    def get_HierarchicalCodelists(self): return self.HierarchicalCodelists
    def set_HierarchicalCodelists(self, HierarchicalCodelists): self.HierarchicalCodelists = HierarchicalCodelists
    def get_Concepts(self): return self.Concepts
    def set_Concepts(self, Concepts): self.Concepts = Concepts
    def get_MetadataStructureDefinitions(self): return self.MetadataStructureDefinitions
    def set_MetadataStructureDefinitions(self, MetadataStructureDefinitions): self.MetadataStructureDefinitions = MetadataStructureDefinitions
    def get_KeyFamilies(self): return self.KeyFamilies
    def set_KeyFamilies(self, KeyFamilies): self.KeyFamilies = KeyFamilies
    def get_StructureSets(self): return self.StructureSets
    def set_StructureSets(self, StructureSets): self.StructureSets = StructureSets
    def get_Processes(self): return self.Processes
    def set_Processes(self, Processes): self.Processes = Processes
    def get_ReportingTaxonomies(self): return self.ReportingTaxonomies
    def set_ReportingTaxonomies(self, ReportingTaxonomies): self.ReportingTaxonomies = ReportingTaxonomies
    def hasContent_(self):
        if (
            self.OrganisationSchemes is not None or
            self.Dataflows is not None or
            self.Metadataflows is not None or
            self.CategorySchemes is not None or
            self.CodeLists is not None or
            self.HierarchicalCodelists is not None or
            self.Concepts is not None or
            self.MetadataStructureDefinitions is not None or
            self.KeyFamilies is not None or
            self.StructureSets is not None or
            self.Processes is not None or
            self.ReportingTaxonomies is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructuralEventType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:structure="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/structure" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructuralEventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructuralEventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructuralEventType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructuralEventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OrganisationSchemes is not None:
            self.OrganisationSchemes.export(outfile, level, namespace_, name_='OrganisationSchemes', pretty_print=pretty_print)
        if self.Dataflows is not None:
            self.Dataflows.export(outfile, level, namespace_, name_='Dataflows', pretty_print=pretty_print)
        if self.Metadataflows is not None:
            self.Metadataflows.export(outfile, level, namespace_, name_='Metadataflows', pretty_print=pretty_print)
        if self.CategorySchemes is not None:
            self.CategorySchemes.export(outfile, level, namespace_, name_='CategorySchemes', pretty_print=pretty_print)
        if self.CodeLists is not None:
            self.CodeLists.export(outfile, level, namespace_, name_='CodeLists', pretty_print=pretty_print)
        if self.HierarchicalCodelists is not None:
            self.HierarchicalCodelists.export(outfile, level, namespace_, name_='HierarchicalCodelists', pretty_print=pretty_print)
        if self.Concepts is not None:
            self.Concepts.export(outfile, level, namespace_, name_='Concepts', pretty_print=pretty_print)
        if self.MetadataStructureDefinitions is not None:
            self.MetadataStructureDefinitions.export(outfile, level, namespace_, name_='MetadataStructureDefinitions', pretty_print=pretty_print)
        if self.KeyFamilies is not None:
            self.KeyFamilies.export(outfile, level, namespace_, name_='KeyFamilies', pretty_print=pretty_print)
        if self.StructureSets is not None:
            self.StructureSets.export(outfile, level, namespace_, name_='StructureSets', pretty_print=pretty_print)
        if self.Processes is not None:
            self.Processes.export(outfile, level, namespace_, name_='Processes', pretty_print=pretty_print)
        if self.ReportingTaxonomies is not None:
            self.ReportingTaxonomies.export(outfile, level, namespace_, name_='ReportingTaxonomies', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StructuralEventType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.OrganisationSchemes is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemes=model_.OrganisationSchemesType(\n')
            self.OrganisationSchemes.exportLiteral(outfile, level, name_='OrganisationSchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Dataflows is not None:
            showIndent(outfile, level)
            outfile.write('Dataflows=model_.DataflowsType(\n')
            self.Dataflows.exportLiteral(outfile, level, name_='Dataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Metadataflows is not None:
            showIndent(outfile, level)
            outfile.write('Metadataflows=model_.MetadataflowsType(\n')
            self.Metadataflows.exportLiteral(outfile, level, name_='Metadataflows')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CategorySchemes is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemes=model_.CategorySchemesType(\n')
            self.CategorySchemes.exportLiteral(outfile, level, name_='CategorySchemes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CodeLists is not None:
            showIndent(outfile, level)
            outfile.write('CodeLists=model_.CodeListsType(\n')
            self.CodeLists.exportLiteral(outfile, level, name_='CodeLists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HierarchicalCodelists is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelists=model_.HierarchicalCodelistsType(\n')
            self.HierarchicalCodelists.exportLiteral(outfile, level, name_='HierarchicalCodelists')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Concepts is not None:
            showIndent(outfile, level)
            outfile.write('Concepts=model_.ConceptsType(\n')
            self.Concepts.exportLiteral(outfile, level, name_='Concepts')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataStructureDefinitions is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureDefinitions=model_.MetadataStructureDefinitionsType(\n')
            self.MetadataStructureDefinitions.exportLiteral(outfile, level, name_='MetadataStructureDefinitions')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KeyFamilies is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilies=model_.KeyFamiliesType(\n')
            self.KeyFamilies.exportLiteral(outfile, level, name_='KeyFamilies')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureSets is not None:
            showIndent(outfile, level)
            outfile.write('StructureSets=model_.StructureSetsType(\n')
            self.StructureSets.exportLiteral(outfile, level, name_='StructureSets')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Processes is not None:
            showIndent(outfile, level)
            outfile.write('Processes=model_.ProcessesType(\n')
            self.Processes.exportLiteral(outfile, level, name_='Processes')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReportingTaxonomies is not None:
            showIndent(outfile, level)
            outfile.write('ReportingTaxonomies=model_.ReportingTaxonomiesType(\n')
            self.ReportingTaxonomies.exportLiteral(outfile, level, name_='ReportingTaxonomies')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OrganisationSchemes':
            obj_ = OrganisationSchemesType.factory()
            obj_.build(child_)
            self.OrganisationSchemes = obj_
            obj_.original_tagname_ = 'OrganisationSchemes'
        elif nodeName_ == 'Dataflows':
            obj_ = DataflowsType.factory()
            obj_.build(child_)
            self.Dataflows = obj_
            obj_.original_tagname_ = 'Dataflows'
        elif nodeName_ == 'Metadataflows':
            obj_ = MetadataflowsType.factory()
            obj_.build(child_)
            self.Metadataflows = obj_
            obj_.original_tagname_ = 'Metadataflows'
        elif nodeName_ == 'CategorySchemes':
            obj_ = CategorySchemesType.factory()
            obj_.build(child_)
            self.CategorySchemes = obj_
            obj_.original_tagname_ = 'CategorySchemes'
        elif nodeName_ == 'CodeLists':
            obj_ = CodeListsType.factory()
            obj_.build(child_)
            self.CodeLists = obj_
            obj_.original_tagname_ = 'CodeLists'
        elif nodeName_ == 'HierarchicalCodelists':
            obj_ = HierarchicalCodelistsType.factory()
            obj_.build(child_)
            self.HierarchicalCodelists = obj_
            obj_.original_tagname_ = 'HierarchicalCodelists'
        elif nodeName_ == 'Concepts':
            obj_ = ConceptsType.factory()
            obj_.build(child_)
            self.Concepts = obj_
            obj_.original_tagname_ = 'Concepts'
        elif nodeName_ == 'MetadataStructureDefinitions':
            obj_ = MetadataStructureDefinitionsType.factory()
            obj_.build(child_)
            self.MetadataStructureDefinitions = obj_
            obj_.original_tagname_ = 'MetadataStructureDefinitions'
        elif nodeName_ == 'KeyFamilies':
            obj_ = KeyFamiliesType.factory()
            obj_.build(child_)
            self.KeyFamilies = obj_
            obj_.original_tagname_ = 'KeyFamilies'
        elif nodeName_ == 'StructureSets':
            obj_ = StructureSetsType.factory()
            obj_.build(child_)
            self.StructureSets = obj_
            obj_.original_tagname_ = 'StructureSets'
        elif nodeName_ == 'Processes':
            obj_ = ProcessesType.factory()
            obj_.build(child_)
            self.Processes = obj_
            obj_.original_tagname_ = 'Processes'
        elif nodeName_ == 'ReportingTaxonomies':
            obj_ = ReportingTaxonomiesType.factory()
            obj_.build(child_)
            self.ReportingTaxonomies = obj_
            obj_.original_tagname_ = 'ReportingTaxonomies'
# end class StructuralEventType


class ProvisioningEventType(GeneratedsSuper):
    """This provides the details of a provisioning event for the purposes
    of notification."""
    subclass = None
    superclass = None
    def __init__(self, DataProviderRef=None, DataflowRef=None, MetadataflowRef=None, ProvisionAgreement=None):
        self.original_tagname_ = None
        self.DataProviderRef = DataProviderRef
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.ProvisionAgreement = ProvisionAgreement
    def factory(*args_, **kwargs_):
        if ProvisioningEventType.subclass:
            return ProvisioningEventType.subclass(*args_, **kwargs_)
        else:
            return ProvisioningEventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_ProvisionAgreement(self): return self.ProvisionAgreement
    def set_ProvisionAgreement(self, ProvisionAgreement): self.ProvisionAgreement = ProvisionAgreement
    def hasContent_(self):
        if (
            self.DataProviderRef is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.ProvisionAgreement is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProvisioningEventType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProvisioningEventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProvisioningEventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProvisioningEventType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProvisioningEventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.ProvisionAgreement is not None:
            self.ProvisionAgreement.export(outfile, level, namespace_, name_='ProvisionAgreement', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProvisioningEventType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisionAgreement is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreement=model_.ProvisionAgreementType(\n')
            self.ProvisionAgreement.exportLiteral(outfile, level, name_='ProvisionAgreement')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'ProvisionAgreement':
            obj_ = ProvisionAgreementType.factory()
            obj_.build(child_)
            self.ProvisionAgreement = obj_
            obj_.original_tagname_ = 'ProvisionAgreement'
# end class ProvisioningEventType


class RegistrationEventType(GeneratedsSuper):
    """This provides the details of a data or metadata registration event
    for the purposes of notification."""
    subclass = None
    superclass = None
    def __init__(self, Registration=None):
        self.original_tagname_ = None
        self.Registration = Registration
    def factory(*args_, **kwargs_):
        if RegistrationEventType.subclass:
            return RegistrationEventType.subclass(*args_, **kwargs_)
        else:
            return RegistrationEventType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Registration(self): return self.Registration
    def set_Registration(self, Registration): self.Registration = Registration
    def hasContent_(self):
        if (
            self.Registration is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RegistrationEventType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistrationEventType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RegistrationEventType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RegistrationEventType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='RegistrationEventType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Registration is not None:
            self.Registration.export(outfile, level, namespace_, name_='Registration', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegistrationEventType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Registration is not None:
            showIndent(outfile, level)
            outfile.write('Registration=model_.RegistrationType(\n')
            self.Registration.exportLiteral(outfile, level, name_='Registration')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Registration':
            obj_ = RegistrationType.factory()
            obj_.build(child_)
            self.Registration = obj_
            obj_.original_tagname_ = 'Registration'
# end class RegistrationEventType


class ProvisionAgreementType(GeneratedsSuper):
    """Provision agreements contain a reference to a pre-existing data flow
    or metadata flow definition and a pre-existing data (or
    metadata) provider in the registry. They also must have the
    action attribute set, indicating whether this is an addition, a
    modification, or a deletion of a provision agreement. They may
    also supply boolean values which describe how the registry must
    behave: if indexTimeSeries is true, then the registry must index
    all time series when a data set is registered against this
    provision agreement; if indexDataSet is true, then the registry
    must index the range of actual (present) values for each
    dimension of the Dataset (as indicated in the dataset's key
    family); if indexReportingPeriod is true, then the registry must
    index the time period ranges for which data are present in the
    dataset(s) registered against the provision agreement. Note that
    the values for these attributes are not needed when a Delete
    action is indicated. As for all identifiable objects, provision
    agreements have Name and Description elements, which are
    repeatable to provide language-specific forms. These may be
    ommitted if the provision agreement already exists (as is the
    case for modification and deletion); descriptions are always
    optional. The id attribute holds the unique id of the provision
    agreement as derived (according to teh logical registry
    specifcation.) If specified, the uri attribute points to a
    location (typically a URL) where the provision agreement is
    described in a valid QueryProvisioningResponse message. The urn
    attribute holds the reserved registry URN assigned to the
    provision agreement - this must be included when the
    ProvisionAgreement structure is used in a response document of
    any type. The action attribute must be specified when the
    provisionAgreement is used in a request document of any type..
    Datasource is used to describe the data source associated with
    the provider agreement. Annotations may be provided in the
    Annotations element. The validFrom and validTo attributes
    provide inclusive dates for providing supplemental validity
    information about the version."""
    subclass = None
    superclass = None
    def __init__(self, indexReportingPeriod=None, indexTimeSeries=None, indexDataSet=None, urn=None, uri=None, validTo=None, action=None, validFrom=None, id=None, Name=None, Description=None, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None, Datasource=None, Constraint=None, Annotations=None):
        self.original_tagname_ = None
        self.indexReportingPeriod = _cast(bool, indexReportingPeriod)
        self.indexTimeSeries = _cast(bool, indexTimeSeries)
        self.indexDataSet = _cast(bool, indexDataSet)
        self.urn = _cast(None, urn)
        self.uri = _cast(None, uri)
        self.validTo = _cast(None, validTo)
        self.action = _cast(None, action)
        self.validFrom = _cast(None, validFrom)
        self.id = _cast(None, id)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        if Description is None:
            self.Description = []
        else:
            self.Description = Description
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.DataProviderRef = DataProviderRef
        self.Datasource = Datasource
        self.Constraint = Constraint
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ProvisionAgreementType.subclass:
            return ProvisionAgreementType.subclass(*args_, **kwargs_)
        else:
            return ProvisionAgreementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_Description(self): return self.Description
    def set_Description(self, Description): self.Description = Description
    def add_Description(self, value): self.Description.append(value)
    def insert_Description_at(self, index, value): self.Description.insert(index, value)
    def replace_Description_at(self, index, value): self.Description[index] = value
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def get_Datasource(self): return self.Datasource
    def set_Datasource(self, Datasource): self.Datasource = Datasource
    def get_Constraint(self): return self.Constraint
    def set_Constraint(self, Constraint): self.Constraint = Constraint
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_indexReportingPeriod(self): return self.indexReportingPeriod
    def set_indexReportingPeriod(self, indexReportingPeriod): self.indexReportingPeriod = indexReportingPeriod
    def get_indexTimeSeries(self): return self.indexTimeSeries
    def set_indexTimeSeries(self, indexTimeSeries): self.indexTimeSeries = indexTimeSeries
    def get_indexDataSet(self): return self.indexDataSet
    def set_indexDataSet(self, indexDataSet): self.indexDataSet = indexDataSet
    def get_urn(self): return self.urn
    def set_urn(self, urn): self.urn = urn
    def get_uri(self): return self.uri
    def set_uri(self, uri): self.uri = uri
    def get_validTo(self): return self.validTo
    def set_validTo(self, validTo): self.validTo = validTo
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_validFrom(self): return self.validFrom
    def set_validFrom(self, validFrom): self.validFrom = validFrom
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def hasContent_(self):
        if (
            self.Name or
            self.Description or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.DataProviderRef is not None or
            self.Datasource is not None or
            self.Constraint is not None or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProvisionAgreementType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProvisionAgreementType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProvisionAgreementType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProvisionAgreementType'):
        if self.indexReportingPeriod is not None and 'indexReportingPeriod' not in already_processed:
            already_processed.add('indexReportingPeriod')
            outfile.write(' indexReportingPeriod="%s"' % self.gds_format_boolean(self.indexReportingPeriod, input_name='indexReportingPeriod'))
        if self.indexTimeSeries is not None and 'indexTimeSeries' not in already_processed:
            already_processed.add('indexTimeSeries')
            outfile.write(' indexTimeSeries="%s"' % self.gds_format_boolean(self.indexTimeSeries, input_name='indexTimeSeries'))
        if self.indexDataSet is not None and 'indexDataSet' not in already_processed:
            already_processed.add('indexDataSet')
            outfile.write(' indexDataSet="%s"' % self.gds_format_boolean(self.indexDataSet, input_name='indexDataSet'))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            outfile.write(' urn=%s' % (self.gds_format_string(quote_attrib(self.urn).encode(ExternalEncoding), input_name='urn'), ))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            outfile.write(' uri=%s' % (self.gds_format_string(quote_attrib(self.uri).encode(ExternalEncoding), input_name='uri'), ))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            outfile.write(' validTo=%s' % (quote_attrib(self.validTo), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            outfile.write(' validFrom=%s' % (quote_attrib(self.validFrom), ))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (quote_attrib(self.id), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProvisionAgreementType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        for Description_ in self.Description:
            Description_.export(outfile, level, namespace_, name_='Description', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.Datasource is not None:
            self.Datasource.export(outfile, level, namespace_, name_='Datasource', pretty_print=pretty_print)
        if self.Constraint is not None:
            self.Constraint.export(outfile, level, namespace_, name_='Constraint', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProvisionAgreementType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.indexReportingPeriod is not None and 'indexReportingPeriod' not in already_processed:
            already_processed.add('indexReportingPeriod')
            showIndent(outfile, level)
            outfile.write('indexReportingPeriod=%s,\n' % (self.indexReportingPeriod,))
        if self.indexTimeSeries is not None and 'indexTimeSeries' not in already_processed:
            already_processed.add('indexTimeSeries')
            showIndent(outfile, level)
            outfile.write('indexTimeSeries=%s,\n' % (self.indexTimeSeries,))
        if self.indexDataSet is not None and 'indexDataSet' not in already_processed:
            already_processed.add('indexDataSet')
            showIndent(outfile, level)
            outfile.write('indexDataSet=%s,\n' % (self.indexDataSet,))
        if self.urn is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            showIndent(outfile, level)
            outfile.write('urn="%s",\n' % (self.urn,))
        if self.uri is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            showIndent(outfile, level)
            outfile.write('uri="%s",\n' % (self.uri,))
        if self.validTo is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            showIndent(outfile, level)
            outfile.write('validTo=%s,\n' % (self.validTo,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % (self.action,))
        if self.validFrom is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            showIndent(outfile, level)
            outfile.write('validFrom=%s,\n' % (self.validFrom,))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id=%s,\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Description=[\n')
        level += 1
        for Description_ in self.Description:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Description_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Datasource is not None:
            showIndent(outfile, level)
            outfile.write('Datasource=model_.QueryableDatasourceType(\n')
            self.Datasource.exportLiteral(outfile, level, name_='Datasource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constraint is not None:
            showIndent(outfile, level)
            outfile.write('Constraint=model_.ConstraintType(\n')
            self.Constraint.exportLiteral(outfile, level, name_='Constraint')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('indexReportingPeriod', node)
        if value is not None and 'indexReportingPeriod' not in already_processed:
            already_processed.add('indexReportingPeriod')
            if value in ('true', '1'):
                self.indexReportingPeriod = True
            elif value in ('false', '0'):
                self.indexReportingPeriod = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('indexTimeSeries', node)
        if value is not None and 'indexTimeSeries' not in already_processed:
            already_processed.add('indexTimeSeries')
            if value in ('true', '1'):
                self.indexTimeSeries = True
            elif value in ('false', '0'):
                self.indexTimeSeries = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('indexDataSet', node)
        if value is not None and 'indexDataSet' not in already_processed:
            already_processed.add('indexDataSet')
            if value in ('true', '1'):
                self.indexDataSet = True
            elif value in ('false', '0'):
                self.indexDataSet = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('urn', node)
        if value is not None and 'urn' not in already_processed:
            already_processed.add('urn')
            self.urn = value
        value = find_attr_value_('uri', node)
        if value is not None and 'uri' not in already_processed:
            already_processed.add('uri')
            self.uri = value
        value = find_attr_value_('validTo', node)
        if value is not None and 'validTo' not in already_processed:
            already_processed.add('validTo')
            self.validTo = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('validFrom', node)
        if value is not None and 'validFrom' not in already_processed:
            already_processed.add('validFrom')
            self.validFrom = value
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'Description':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Description.append(obj_)
            obj_.original_tagname_ = 'Description'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'Datasource':
            obj_ = QueryableDatasourceType.factory()
            obj_.build(child_)
            self.Datasource = obj_
            obj_.original_tagname_ = 'Datasource'
        elif nodeName_ == 'Constraint':
            obj_ = ConstraintType.factory()
            obj_.build(child_)
            self.Constraint = obj_
            obj_.original_tagname_ = 'Constraint'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ProvisionAgreementType


class DatasourceType(GeneratedsSuper):
    """Datasource specifies the properties of a data or metadata source. A
    SimpleDatasource requires only the URL of the data. A
    QueryableDatasource must be able to accept an SDMX-ML Query
    Message, and respond appropriately. Either or both may be
    specified."""
    subclass = None
    superclass = None
    def __init__(self, SimpleDatasource=None, QueryableDatasource=None):
        self.original_tagname_ = None
        self.SimpleDatasource = SimpleDatasource
        self.QueryableDatasource = QueryableDatasource
    def factory(*args_, **kwargs_):
        if DatasourceType.subclass:
            return DatasourceType.subclass(*args_, **kwargs_)
        else:
            return DatasourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SimpleDatasource(self): return self.SimpleDatasource
    def set_SimpleDatasource(self, SimpleDatasource): self.SimpleDatasource = SimpleDatasource
    def get_QueryableDatasource(self): return self.QueryableDatasource
    def set_QueryableDatasource(self, QueryableDatasource): self.QueryableDatasource = QueryableDatasource
    def hasContent_(self):
        if (
            self.SimpleDatasource is not None or
            self.QueryableDatasource is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='DatasourceType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DatasourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='DatasourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='DatasourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='DatasourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SimpleDatasource is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSimpleDatasource>%s</%sSimpleDatasource>%s' % (namespace_, self.gds_format_string(quote_xml(self.SimpleDatasource).encode(ExternalEncoding), input_name='SimpleDatasource'), namespace_, eol_))
        if self.QueryableDatasource is not None:
            self.QueryableDatasource.export(outfile, level, namespace_, name_='QueryableDatasource', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DatasourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SimpleDatasource is not None:
            showIndent(outfile, level)
            outfile.write('SimpleDatasource=%s,\n' % quote_python(self.SimpleDatasource).encode(ExternalEncoding))
        if self.QueryableDatasource is not None:
            showIndent(outfile, level)
            outfile.write('QueryableDatasource=model_.QueryableDatasourceType(\n')
            self.QueryableDatasource.exportLiteral(outfile, level, name_='QueryableDatasource')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SimpleDatasource':
            SimpleDatasource_ = child_.text
            SimpleDatasource_ = self.gds_validate_string(SimpleDatasource_, node, 'SimpleDatasource')
            self.SimpleDatasource = SimpleDatasource_
        elif nodeName_ == 'QueryableDatasource':
            obj_ = QueryableDatasourceType.factory()
            obj_.build(child_)
            self.QueryableDatasource = obj_
            obj_.original_tagname_ = 'QueryableDatasource'
# end class DatasourceType


class QueryableDatasourceType(GeneratedsSuper):
    """If the data provider uses a single, queryable data source for all
    provision agreements contained in the ProvisionRequest element,
    then this element should be used to describe the queryable
    datasource. DataUrl contains the URL of the datasource, with
    WSDLUrl optionally providing the location of a WSDL instance on
    the internet which deascribes the queryable datasource. The
    attributes isRESTDatasource and isWebServiceDatasource indicate,
    if true, that the queryable datasource is accessible via the
    REST protocol and/or Web Services protocols, respectively."""
    subclass = None
    superclass = None
    def __init__(self, isRESTDatasource=None, isWebServiceDatasource=None, DataUrl=None, WSDLUrl=None):
        self.original_tagname_ = None
        self.isRESTDatasource = _cast(bool, isRESTDatasource)
        self.isWebServiceDatasource = _cast(bool, isWebServiceDatasource)
        self.DataUrl = DataUrl
        self.WSDLUrl = WSDLUrl
    def factory(*args_, **kwargs_):
        if QueryableDatasourceType.subclass:
            return QueryableDatasourceType.subclass(*args_, **kwargs_)
        else:
            return QueryableDatasourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataUrl(self): return self.DataUrl
    def set_DataUrl(self, DataUrl): self.DataUrl = DataUrl
    def get_WSDLUrl(self): return self.WSDLUrl
    def set_WSDLUrl(self, WSDLUrl): self.WSDLUrl = WSDLUrl
    def get_isRESTDatasource(self): return self.isRESTDatasource
    def set_isRESTDatasource(self, isRESTDatasource): self.isRESTDatasource = isRESTDatasource
    def get_isWebServiceDatasource(self): return self.isWebServiceDatasource
    def set_isWebServiceDatasource(self, isWebServiceDatasource): self.isWebServiceDatasource = isWebServiceDatasource
    def hasContent_(self):
        if (
            self.DataUrl is not None or
            self.WSDLUrl is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryableDatasourceType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryableDatasourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryableDatasourceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryableDatasourceType'):
        if self.isRESTDatasource is not None and 'isRESTDatasource' not in already_processed:
            already_processed.add('isRESTDatasource')
            outfile.write(' isRESTDatasource="%s"' % self.gds_format_boolean(self.isRESTDatasource, input_name='isRESTDatasource'))
        if self.isWebServiceDatasource is not None and 'isWebServiceDatasource' not in already_processed:
            already_processed.add('isWebServiceDatasource')
            outfile.write(' isWebServiceDatasource="%s"' % self.gds_format_boolean(self.isWebServiceDatasource, input_name='isWebServiceDatasource'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryableDatasourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDataUrl>%s</%sDataUrl>%s' % (namespace_, self.gds_format_string(quote_xml(self.DataUrl).encode(ExternalEncoding), input_name='DataUrl'), namespace_, eol_))
        if self.WSDLUrl is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sWSDLUrl>%s</%sWSDLUrl>%s' % (namespace_, self.gds_format_string(quote_xml(self.WSDLUrl).encode(ExternalEncoding), input_name='WSDLUrl'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='QueryableDatasourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.isRESTDatasource is not None and 'isRESTDatasource' not in already_processed:
            already_processed.add('isRESTDatasource')
            showIndent(outfile, level)
            outfile.write('isRESTDatasource=%s,\n' % (self.isRESTDatasource,))
        if self.isWebServiceDatasource is not None and 'isWebServiceDatasource' not in already_processed:
            already_processed.add('isWebServiceDatasource')
            showIndent(outfile, level)
            outfile.write('isWebServiceDatasource=%s,\n' % (self.isWebServiceDatasource,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataUrl is not None:
            showIndent(outfile, level)
            outfile.write('DataUrl=%s,\n' % quote_python(self.DataUrl).encode(ExternalEncoding))
        if self.WSDLUrl is not None:
            showIndent(outfile, level)
            outfile.write('WSDLUrl=%s,\n' % quote_python(self.WSDLUrl).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('isRESTDatasource', node)
        if value is not None and 'isRESTDatasource' not in already_processed:
            already_processed.add('isRESTDatasource')
            if value in ('true', '1'):
                self.isRESTDatasource = True
            elif value in ('false', '0'):
                self.isRESTDatasource = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isWebServiceDatasource', node)
        if value is not None and 'isWebServiceDatasource' not in already_processed:
            already_processed.add('isWebServiceDatasource')
            if value in ('true', '1'):
                self.isWebServiceDatasource = True
            elif value in ('false', '0'):
                self.isWebServiceDatasource = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataUrl':
            DataUrl_ = child_.text
            DataUrl_ = self.gds_validate_string(DataUrl_, node, 'DataUrl')
            self.DataUrl = DataUrl_
        elif nodeName_ == 'WSDLUrl':
            WSDLUrl_ = child_.text
            WSDLUrl_ = self.gds_validate_string(WSDLUrl_, node, 'WSDLUrl')
            self.WSDLUrl = WSDLUrl_
# end class QueryableDatasourceType


class ProvisioningStatusType(GeneratedsSuper):
    """For each provision agreement, dataflow reference, metadataflow
    reference, or data provider reference submitted in a
    provisioning request, a provisioning status will be returned,
    providing a status and any warnings or errors."""
    subclass = None
    superclass = None
    def __init__(self, ProvisionAgreementRef=None, DataProviderRef=None, DataflowRef=None, MetadataflowRef=None, StatusMessage=None):
        self.original_tagname_ = None
        self.ProvisionAgreementRef = ProvisionAgreementRef
        self.DataProviderRef = DataProviderRef
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.StatusMessage = StatusMessage
    def factory(*args_, **kwargs_):
        if ProvisioningStatusType.subclass:
            return ProvisioningStatusType.subclass(*args_, **kwargs_)
        else:
            return ProvisioningStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def hasContent_(self):
        if (
            self.ProvisionAgreementRef is not None or
            self.DataProviderRef is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.StatusMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProvisioningStatusType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProvisioningStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProvisioningStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProvisioningStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProvisioningStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProvisioningStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
# end class ProvisioningStatusType


class RegistrationType(GeneratedsSuper):
    """Registration provides the information needed for data and reference
    metadata set registration. LastUpdated can provide a time stamp;
    ValidFrom and ValidTo allow for effectivity, so that data
    visibility from the registry can be controlled by the
    registrant. A Datasource must be supplied here if not already
    provided in the provision agreement. The data set or metadata
    set must be associated with a provision agreement, a
    metadataflow, or a dataflow definition. If possible, the
    provision agreement should be specified. Only in cases where
    this is not possible should the dataflow or metadataflow be
    used."""
    subclass = None
    superclass = None
    def __init__(self, LastUpdated=None, ValidFrom=None, ValidTo=None, Action=None, Datasource=None, DataflowRef=None, MetadataflowRef=None, ProvisionAgreementRef=None):
        self.original_tagname_ = None
        if isinstance(LastUpdated, basestring):
            initvalue_ = datetime_.datetime.strptime(LastUpdated, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = LastUpdated
        self.LastUpdated = initvalue_
        if isinstance(ValidFrom, basestring):
            initvalue_ = datetime_.datetime.strptime(ValidFrom, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ValidFrom
        self.ValidFrom = initvalue_
        if isinstance(ValidTo, basestring):
            initvalue_ = datetime_.datetime.strptime(ValidTo, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = ValidTo
        self.ValidTo = initvalue_
        self.Action = Action
        self.Datasource = Datasource
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.ProvisionAgreementRef = ProvisionAgreementRef
    def factory(*args_, **kwargs_):
        if RegistrationType.subclass:
            return RegistrationType.subclass(*args_, **kwargs_)
        else:
            return RegistrationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LastUpdated(self): return self.LastUpdated
    def set_LastUpdated(self, LastUpdated): self.LastUpdated = LastUpdated
    def get_ValidFrom(self): return self.ValidFrom
    def set_ValidFrom(self, ValidFrom): self.ValidFrom = ValidFrom
    def get_ValidTo(self): return self.ValidTo
    def set_ValidTo(self, ValidTo): self.ValidTo = ValidTo
    def get_Action(self): return self.Action
    def set_Action(self, Action): self.Action = Action
    def get_Datasource(self): return self.Datasource
    def set_Datasource(self, Datasource): self.Datasource = Datasource
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def validate_ActionType(self, value):
        # Validate type ActionType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.LastUpdated is not None or
            self.ValidFrom is not None or
            self.ValidTo is not None or
            self.Action is not None or
            self.Datasource is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.ProvisionAgreementRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RegistrationType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistrationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RegistrationType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RegistrationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='RegistrationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LastUpdated is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLastUpdated>%s</%sLastUpdated>%s' % (namespace_, self.gds_format_datetime(self.LastUpdated, input_name='LastUpdated'), namespace_, eol_))
        if self.ValidFrom is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidFrom>%s</%sValidFrom>%s' % (namespace_, self.gds_format_datetime(self.ValidFrom, input_name='ValidFrom'), namespace_, eol_))
        if self.ValidTo is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidTo>%s</%sValidTo>%s' % (namespace_, self.gds_format_datetime(self.ValidTo, input_name='ValidTo'), namespace_, eol_))
        if self.Action is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAction>%s</%sAction>%s' % (namespace_, self.gds_format_string(quote_xml(self.Action).encode(ExternalEncoding), input_name='Action'), namespace_, eol_))
        if self.Datasource is not None:
            self.Datasource.export(outfile, level, namespace_, name_='Datasource', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegistrationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LastUpdated is not None:
            showIndent(outfile, level)
            outfile.write('LastUpdated=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.LastUpdated, input_name='LastUpdated'))
        if self.ValidFrom is not None:
            showIndent(outfile, level)
            outfile.write('ValidFrom=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.ValidFrom, input_name='ValidFrom'))
        if self.ValidTo is not None:
            showIndent(outfile, level)
            outfile.write('ValidTo=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.ValidTo, input_name='ValidTo'))
        if self.Action is not None:
            showIndent(outfile, level)
            outfile.write('Action=%s,\n' % quote_python(self.Action).encode(ExternalEncoding))
        if self.Datasource is not None:
            showIndent(outfile, level)
            outfile.write('Datasource=model_.DatasourceType(\n')
            self.Datasource.exportLiteral(outfile, level, name_='Datasource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LastUpdated':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.LastUpdated = dval_
        elif nodeName_ == 'ValidFrom':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ValidFrom = dval_
        elif nodeName_ == 'ValidTo':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.ValidTo = dval_
        elif nodeName_ == 'Action':
            Action_ = child_.text
            Action_ = self.gds_validate_string(Action_, node, 'Action')
            self.Action = Action_
            self.validate_ActionType(self.Action)    # validate type ActionType
        elif nodeName_ == 'Datasource':
            obj_ = DatasourceType.factory()
            obj_.build(child_)
            self.Datasource = obj_
            obj_.original_tagname_ = 'Datasource'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
# end class RegistrationType


class RegistrationStatusType(GeneratedsSuper):
    """Each RegistrationStatus reports the status of a submitted data set
    or metadata set registration, and carries any error messages. If
    successful, the Datasource which has been registered is
    returned, and a reference to the provision agreement, dataflow,
    metadataflow, or data provider is returned."""
    subclass = None
    superclass = None
    def __init__(self, StatusMessage=None, Datasource=None, DataProviderRef=None, DataflowRef=None, MetadaflowRef=None, ProvisionAgreementRef=None):
        self.original_tagname_ = None
        self.StatusMessage = StatusMessage
        self.Datasource = Datasource
        self.DataProviderRef = DataProviderRef
        self.DataflowRef = DataflowRef
        self.MetadaflowRef = MetadaflowRef
        self.ProvisionAgreementRef = ProvisionAgreementRef
    def factory(*args_, **kwargs_):
        if RegistrationStatusType.subclass:
            return RegistrationStatusType.subclass(*args_, **kwargs_)
        else:
            return RegistrationStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def get_Datasource(self): return self.Datasource
    def set_Datasource(self, Datasource): self.Datasource = Datasource
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadaflowRef(self): return self.MetadaflowRef
    def set_MetadaflowRef(self, MetadaflowRef): self.MetadaflowRef = MetadaflowRef
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def hasContent_(self):
        if (
            self.StatusMessage is not None or
            self.Datasource is not None or
            self.DataProviderRef is not None or
            self.DataflowRef is not None or
            self.MetadaflowRef is not None or
            self.ProvisionAgreementRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='RegistrationStatusType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RegistrationStatusType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='RegistrationStatusType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='RegistrationStatusType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='RegistrationStatusType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
        if self.Datasource is not None:
            self.Datasource.export(outfile, level, namespace_, name_='Datasource', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadaflowRef is not None:
            self.MetadaflowRef.export(outfile, level, namespace_, name_='MetadaflowRef', pretty_print=pretty_print)
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RegistrationStatusType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Datasource is not None:
            showIndent(outfile, level)
            outfile.write('Datasource=model_.DatasourceType(\n')
            self.Datasource.exportLiteral(outfile, level, name_='Datasource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadaflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadaflowRef=model_.MetadataflowRefType(\n')
            self.MetadaflowRef.exportLiteral(outfile, level, name_='MetadaflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
        elif nodeName_ == 'Datasource':
            obj_ = DatasourceType.factory()
            obj_.build(child_)
            self.Datasource = obj_
            obj_.original_tagname_ = 'Datasource'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadaflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadaflowRef = obj_
            obj_.original_tagname_ = 'MetadaflowRef'
        elif nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
# end class RegistrationStatusType


class QueryResultType(GeneratedsSuper):
    """QueryResult contains the results of a specific registry query for a
    single datasource. If a successful result is a registered
    dataset, the DataResult element is used. If a successful result
    is a registered metadataset, the MetadataResult is used. If the
    query failed, then StatusMessage is included. The
    timeSeriesMatch attribute is true when the result is an exact
    match with the key found in the registry - that is, when the
    registered datasource provides a matching key. It is set to
    false when the datasource is registered with cube-region
    constraints, or in any other circumstance when it cannot be
    established that the sought-for keys have been exactly matched.
    This is always true when the resulting datasource is the source
    of a metadata set."""
    subclass = None
    superclass = None
    def __init__(self, timeSeriesMatch=None, DataResult=None, MetadataResult=None, StatusMessage=None):
        self.original_tagname_ = None
        self.timeSeriesMatch = _cast(bool, timeSeriesMatch)
        self.DataResult = DataResult
        self.MetadataResult = MetadataResult
        self.StatusMessage = StatusMessage
    def factory(*args_, **kwargs_):
        if QueryResultType.subclass:
            return QueryResultType.subclass(*args_, **kwargs_)
        else:
            return QueryResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataResult(self): return self.DataResult
    def set_DataResult(self, DataResult): self.DataResult = DataResult
    def get_MetadataResult(self): return self.MetadataResult
    def set_MetadataResult(self, MetadataResult): self.MetadataResult = MetadataResult
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def get_timeSeriesMatch(self): return self.timeSeriesMatch
    def set_timeSeriesMatch(self, timeSeriesMatch): self.timeSeriesMatch = timeSeriesMatch
    def hasContent_(self):
        if (
            self.DataResult is not None or
            self.MetadataResult is not None or
            self.StatusMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='QueryResultType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QueryResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='QueryResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='QueryResultType'):
        if self.timeSeriesMatch is not None and 'timeSeriesMatch' not in already_processed:
            already_processed.add('timeSeriesMatch')
            outfile.write(' timeSeriesMatch="%s"' % self.gds_format_boolean(self.timeSeriesMatch, input_name='timeSeriesMatch'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='QueryResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataResult is not None:
            self.DataResult.export(outfile, level, namespace_, name_='DataResult', pretty_print=pretty_print)
        if self.MetadataResult is not None:
            self.MetadataResult.export(outfile, level, namespace_, name_='MetadataResult', pretty_print=pretty_print)
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='QueryResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.timeSeriesMatch is not None and 'timeSeriesMatch' not in already_processed:
            already_processed.add('timeSeriesMatch')
            showIndent(outfile, level)
            outfile.write('timeSeriesMatch=%s,\n' % (self.timeSeriesMatch,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataResult is not None:
            showIndent(outfile, level)
            outfile.write('DataResult=model_.ResultType(\n')
            self.DataResult.exportLiteral(outfile, level, name_='DataResult')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataResult is not None:
            showIndent(outfile, level)
            outfile.write('MetadataResult=model_.ResultType(\n')
            self.MetadataResult.exportLiteral(outfile, level, name_='MetadataResult')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('timeSeriesMatch', node)
        if value is not None and 'timeSeriesMatch' not in already_processed:
            already_processed.add('timeSeriesMatch')
            if value in ('true', '1'):
                self.timeSeriesMatch = True
            elif value in ('false', '0'):
                self.timeSeriesMatch = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataResult':
            obj_ = ResultType.factory()
            obj_.build(child_)
            self.DataResult = obj_
            obj_.original_tagname_ = 'DataResult'
        elif nodeName_ == 'MetadataResult':
            obj_ = ResultType.factory()
            obj_.build(child_)
            self.MetadataResult = obj_
            obj_.original_tagname_ = 'MetadataResult'
        elif nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
# end class QueryResultType


class ResultType(GeneratedsSuper):
    """Result contains the information about either a data or metadata
    source, being returned as part of a QueryResult element. If the"""
    subclass = None
    superclass = None
    def __init__(self, Datasource=None, ProvisionAgreementRef=None, DataflowRef=None, MetadataflowRef=None, DataProviderRef=None):
        self.original_tagname_ = None
        self.Datasource = Datasource
        self.ProvisionAgreementRef = ProvisionAgreementRef
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.DataProviderRef = DataProviderRef
    def factory(*args_, **kwargs_):
        if ResultType.subclass:
            return ResultType.subclass(*args_, **kwargs_)
        else:
            return ResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Datasource(self): return self.Datasource
    def set_Datasource(self, Datasource): self.Datasource = Datasource
    def get_ProvisionAgreementRef(self): return self.ProvisionAgreementRef
    def set_ProvisionAgreementRef(self, ProvisionAgreementRef): self.ProvisionAgreementRef = ProvisionAgreementRef
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_DataProviderRef(self): return self.DataProviderRef
    def set_DataProviderRef(self, DataProviderRef): self.DataProviderRef = DataProviderRef
    def hasContent_(self):
        if (
            self.Datasource is not None or
            self.ProvisionAgreementRef is not None or
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.DataProviderRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ResultType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ResultType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Datasource is not None:
            self.Datasource.export(outfile, level, namespace_, name_='Datasource', pretty_print=pretty_print)
        if self.ProvisionAgreementRef is not None:
            self.ProvisionAgreementRef.export(outfile, level, namespace_, name_='ProvisionAgreementRef', pretty_print=pretty_print)
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.DataProviderRef is not None:
            self.DataProviderRef.export(outfile, level, namespace_, name_='DataProviderRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Datasource is not None:
            showIndent(outfile, level)
            outfile.write('Datasource=model_.DatasourceType(\n')
            self.Datasource.exportLiteral(outfile, level, name_='Datasource')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProvisionAgreementRef is not None:
            showIndent(outfile, level)
            outfile.write('ProvisionAgreementRef=model_.ProvisionAgreementRefType(\n')
            self.ProvisionAgreementRef.exportLiteral(outfile, level, name_='ProvisionAgreementRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.DataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DataProviderRef is not None:
            showIndent(outfile, level)
            outfile.write('DataProviderRef=model_.DataProviderRefType(\n')
            self.DataProviderRef.exportLiteral(outfile, level, name_='DataProviderRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Datasource':
            obj_ = DatasourceType.factory()
            obj_.build(child_)
            self.Datasource = obj_
            obj_.original_tagname_ = 'Datasource'
        elif nodeName_ == 'ProvisionAgreementRef':
            obj_ = ProvisionAgreementRefType.factory()
            obj_.build(child_)
            self.ProvisionAgreementRef = obj_
            obj_.original_tagname_ = 'ProvisionAgreementRef'
        elif nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'DataProviderRef':
            obj_ = DataProviderRefType.factory()
            obj_.build(child_)
            self.DataProviderRef = obj_
            obj_.original_tagname_ = 'DataProviderRef'
# end class ResultType


class SubmittedStructureType(GeneratedsSuper):
    """SubmittedStructure holds a reference to a structural object to be
    stored in the repository. The externalDependencies attribute
    should be set to true if the repository is expected to use URLs
    in the structure Message to retrieve objects on which the stored
    object has dependencies. (Thus, if a key family is being
    submitted to the repository, and the structure message has URLKs
    which point to the locations of the codelists it uses, then the
    externalDependencies attribute should be set to true.) the
    action attribute specifies whether the Structure being submitted
    is intended to be added or deleted from the repository. The
    "modify" action is not applicable to final structures in the
    repository, and will produce an error condition, as these can be
    versioned but not modified.To submit a later version of a
    structure, the structure message should include the incremented
    version number. The externalDependencies and action attributes
    need not be specified in a response document. The isFinal
    attribute indicates whether the structure being submitted to the
    repository is final or not - this can also be specified on the
    structures themselves."""
    subclass = None
    superclass = None
    def __init__(self, action=None, externalDependencies=None, isFinal=None, DataflowRef=None, MetadataflowRef=None, CodelistRef=None, HierarchicalCodelistRef=None, CategorySchemeRef=None, ConceptSchemeRef=None, OrganisationSchemeRef=None, KeyFamilyRef=None, MetadataStructureRef=None, ProcessRef=None, StructureSetRef=None, ReportingTaxonomyRef=None):
        self.original_tagname_ = None
        self.action = _cast(None, action)
        self.externalDependencies = _cast(bool, externalDependencies)
        self.isFinal = _cast(bool, isFinal)
        self.DataflowRef = DataflowRef
        self.MetadataflowRef = MetadataflowRef
        self.CodelistRef = CodelistRef
        self.HierarchicalCodelistRef = HierarchicalCodelistRef
        self.CategorySchemeRef = CategorySchemeRef
        self.ConceptSchemeRef = ConceptSchemeRef
        self.OrganisationSchemeRef = OrganisationSchemeRef
        self.KeyFamilyRef = KeyFamilyRef
        self.MetadataStructureRef = MetadataStructureRef
        self.ProcessRef = ProcessRef
        self.StructureSetRef = StructureSetRef
        self.ReportingTaxonomyRef = ReportingTaxonomyRef
    def factory(*args_, **kwargs_):
        if SubmittedStructureType.subclass:
            return SubmittedStructureType.subclass(*args_, **kwargs_)
        else:
            return SubmittedStructureType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DataflowRef(self): return self.DataflowRef
    def set_DataflowRef(self, DataflowRef): self.DataflowRef = DataflowRef
    def get_MetadataflowRef(self): return self.MetadataflowRef
    def set_MetadataflowRef(self, MetadataflowRef): self.MetadataflowRef = MetadataflowRef
    def get_CodelistRef(self): return self.CodelistRef
    def set_CodelistRef(self, CodelistRef): self.CodelistRef = CodelistRef
    def get_HierarchicalCodelistRef(self): return self.HierarchicalCodelistRef
    def set_HierarchicalCodelistRef(self, HierarchicalCodelistRef): self.HierarchicalCodelistRef = HierarchicalCodelistRef
    def get_CategorySchemeRef(self): return self.CategorySchemeRef
    def set_CategorySchemeRef(self, CategorySchemeRef): self.CategorySchemeRef = CategorySchemeRef
    def get_ConceptSchemeRef(self): return self.ConceptSchemeRef
    def set_ConceptSchemeRef(self, ConceptSchemeRef): self.ConceptSchemeRef = ConceptSchemeRef
    def get_OrganisationSchemeRef(self): return self.OrganisationSchemeRef
    def set_OrganisationSchemeRef(self, OrganisationSchemeRef): self.OrganisationSchemeRef = OrganisationSchemeRef
    def get_KeyFamilyRef(self): return self.KeyFamilyRef
    def set_KeyFamilyRef(self, KeyFamilyRef): self.KeyFamilyRef = KeyFamilyRef
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def get_ProcessRef(self): return self.ProcessRef
    def set_ProcessRef(self, ProcessRef): self.ProcessRef = ProcessRef
    def get_StructureSetRef(self): return self.StructureSetRef
    def set_StructureSetRef(self, StructureSetRef): self.StructureSetRef = StructureSetRef
    def get_ReportingTaxonomyRef(self): return self.ReportingTaxonomyRef
    def set_ReportingTaxonomyRef(self, ReportingTaxonomyRef): self.ReportingTaxonomyRef = ReportingTaxonomyRef
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_externalDependencies(self): return self.externalDependencies
    def set_externalDependencies(self, externalDependencies): self.externalDependencies = externalDependencies
    def get_isFinal(self): return self.isFinal
    def set_isFinal(self, isFinal): self.isFinal = isFinal
    def hasContent_(self):
        if (
            self.DataflowRef is not None or
            self.MetadataflowRef is not None or
            self.CodelistRef is not None or
            self.HierarchicalCodelistRef is not None or
            self.CategorySchemeRef is not None or
            self.ConceptSchemeRef is not None or
            self.OrganisationSchemeRef is not None or
            self.KeyFamilyRef is not None or
            self.MetadataStructureRef is not None or
            self.ProcessRef is not None or
            self.StructureSetRef is not None or
            self.ReportingTaxonomyRef is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmittedStructureType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmittedStructureType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmittedStructureType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmittedStructureType'):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.externalDependencies is not None and 'externalDependencies' not in already_processed:
            already_processed.add('externalDependencies')
            outfile.write(' externalDependencies="%s"' % self.gds_format_boolean(self.externalDependencies, input_name='externalDependencies'))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            outfile.write(' isFinal="%s"' % self.gds_format_boolean(self.isFinal, input_name='isFinal'))
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmittedStructureType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DataflowRef is not None:
            self.DataflowRef.export(outfile, level, namespace_, name_='DataflowRef', pretty_print=pretty_print)
        if self.MetadataflowRef is not None:
            self.MetadataflowRef.export(outfile, level, namespace_, name_='MetadataflowRef', pretty_print=pretty_print)
        if self.CodelistRef is not None:
            self.CodelistRef.export(outfile, level, namespace_, name_='CodelistRef', pretty_print=pretty_print)
        if self.HierarchicalCodelistRef is not None:
            self.HierarchicalCodelistRef.export(outfile, level, namespace_, name_='HierarchicalCodelistRef', pretty_print=pretty_print)
        if self.CategorySchemeRef is not None:
            self.CategorySchemeRef.export(outfile, level, namespace_, name_='CategorySchemeRef', pretty_print=pretty_print)
        if self.ConceptSchemeRef is not None:
            self.ConceptSchemeRef.export(outfile, level, namespace_, name_='ConceptSchemeRef', pretty_print=pretty_print)
        if self.OrganisationSchemeRef is not None:
            self.OrganisationSchemeRef.export(outfile, level, namespace_, name_='OrganisationSchemeRef', pretty_print=pretty_print)
        if self.KeyFamilyRef is not None:
            self.KeyFamilyRef.export(outfile, level, namespace_, name_='KeyFamilyRef', pretty_print=pretty_print)
        if self.MetadataStructureRef is not None:
            self.MetadataStructureRef.export(outfile, level, namespace_, name_='MetadataStructureRef', pretty_print=pretty_print)
        if self.ProcessRef is not None:
            self.ProcessRef.export(outfile, level, namespace_, name_='ProcessRef', pretty_print=pretty_print)
        if self.StructureSetRef is not None:
            self.StructureSetRef.export(outfile, level, namespace_, name_='StructureSetRef', pretty_print=pretty_print)
        if self.ReportingTaxonomyRef is not None:
            self.ReportingTaxonomyRef.export(outfile, level, namespace_, name_='ReportingTaxonomyRef', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmittedStructureType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % (self.action,))
        if self.externalDependencies is not None and 'externalDependencies' not in already_processed:
            already_processed.add('externalDependencies')
            showIndent(outfile, level)
            outfile.write('externalDependencies=%s,\n' % (self.externalDependencies,))
        if self.isFinal is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            showIndent(outfile, level)
            outfile.write('isFinal=%s,\n' % (self.isFinal,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('DataflowRef=model_.DataflowRefType(\n')
            self.DataflowRef.exportLiteral(outfile, level, name_='DataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataflowRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataflowRef=model_.MetadataflowRefType(\n')
            self.MetadataflowRef.exportLiteral(outfile, level, name_='MetadataflowRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('CodelistRef=model_.CodelistRefType(\n')
            self.CodelistRef.exportLiteral(outfile, level, name_='CodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HierarchicalCodelistRef is not None:
            showIndent(outfile, level)
            outfile.write('HierarchicalCodelistRef=model_.HierarchicalCodelistRefType(\n')
            self.HierarchicalCodelistRef.exportLiteral(outfile, level, name_='HierarchicalCodelistRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CategorySchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('CategorySchemeRef=model_.CategorySchemeRefType(\n')
            self.CategorySchemeRef.exportLiteral(outfile, level, name_='CategorySchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ConceptSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('ConceptSchemeRef=model_.ConceptSchemeRefType(\n')
            self.ConceptSchemeRef.exportLiteral(outfile, level, name_='ConceptSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OrganisationSchemeRef is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeRef=model_.OrganisationSchemeRefType(\n')
            self.OrganisationSchemeRef.exportLiteral(outfile, level, name_='OrganisationSchemeRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.KeyFamilyRef is not None:
            showIndent(outfile, level)
            outfile.write('KeyFamilyRef=model_.KeyFamilyRefType(\n')
            self.KeyFamilyRef.exportLiteral(outfile, level, name_='KeyFamilyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.MetadataStructureRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureRef=model_.MetadataStructureRefType(\n')
            self.MetadataStructureRef.exportLiteral(outfile, level, name_='MetadataStructureRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ProcessRef is not None:
            showIndent(outfile, level)
            outfile.write('ProcessRef=model_.ProcessRefType(\n')
            self.ProcessRef.exportLiteral(outfile, level, name_='ProcessRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StructureSetRef is not None:
            showIndent(outfile, level)
            outfile.write('StructureSetRef=model_.StructureSetRefType(\n')
            self.StructureSetRef.exportLiteral(outfile, level, name_='StructureSetRef')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReportingTaxonomyRef is not None:
            showIndent(outfile, level)
            outfile.write('ReportingTaxonomyRef=model_.ReportingTaxonomyRefType(\n')
            self.ReportingTaxonomyRef.exportLiteral(outfile, level, name_='ReportingTaxonomyRef')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('externalDependencies', node)
        if value is not None and 'externalDependencies' not in already_processed:
            already_processed.add('externalDependencies')
            if value in ('true', '1'):
                self.externalDependencies = True
            elif value in ('false', '0'):
                self.externalDependencies = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('isFinal', node)
        if value is not None and 'isFinal' not in already_processed:
            already_processed.add('isFinal')
            if value in ('true', '1'):
                self.isFinal = True
            elif value in ('false', '0'):
                self.isFinal = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DataflowRef':
            obj_ = DataflowRefType.factory()
            obj_.build(child_)
            self.DataflowRef = obj_
            obj_.original_tagname_ = 'DataflowRef'
        elif nodeName_ == 'MetadataflowRef':
            obj_ = MetadataflowRefType.factory()
            obj_.build(child_)
            self.MetadataflowRef = obj_
            obj_.original_tagname_ = 'MetadataflowRef'
        elif nodeName_ == 'CodelistRef':
            obj_ = CodelistRefType.factory()
            obj_.build(child_)
            self.CodelistRef = obj_
            obj_.original_tagname_ = 'CodelistRef'
        elif nodeName_ == 'HierarchicalCodelistRef':
            obj_ = HierarchicalCodelistRefType.factory()
            obj_.build(child_)
            self.HierarchicalCodelistRef = obj_
            obj_.original_tagname_ = 'HierarchicalCodelistRef'
        elif nodeName_ == 'CategorySchemeRef':
            obj_ = CategorySchemeRefType.factory()
            obj_.build(child_)
            self.CategorySchemeRef = obj_
            obj_.original_tagname_ = 'CategorySchemeRef'
        elif nodeName_ == 'ConceptSchemeRef':
            obj_ = ConceptSchemeRefType.factory()
            obj_.build(child_)
            self.ConceptSchemeRef = obj_
            obj_.original_tagname_ = 'ConceptSchemeRef'
        elif nodeName_ == 'OrganisationSchemeRef':
            obj_ = OrganisationSchemeRefType.factory()
            obj_.build(child_)
            self.OrganisationSchemeRef = obj_
            obj_.original_tagname_ = 'OrganisationSchemeRef'
        elif nodeName_ == 'KeyFamilyRef':
            obj_ = KeyFamilyRefType.factory()
            obj_.build(child_)
            self.KeyFamilyRef = obj_
            obj_.original_tagname_ = 'KeyFamilyRef'
        elif nodeName_ == 'MetadataStructureRef':
            obj_ = MetadataStructureRefType.factory()
            obj_.build(child_)
            self.MetadataStructureRef = obj_
            obj_.original_tagname_ = 'MetadataStructureRef'
        elif nodeName_ == 'ProcessRef':
            obj_ = ProcessRefType.factory()
            obj_.build(child_)
            self.ProcessRef = obj_
            obj_.original_tagname_ = 'ProcessRef'
        elif nodeName_ == 'StructureSetRef':
            obj_ = StructureSetRefType.factory()
            obj_.build(child_)
            self.StructureSetRef = obj_
            obj_.original_tagname_ = 'StructureSetRef'
        elif nodeName_ == 'ReportingTaxonomyRef':
            obj_ = ReportingTaxonomyRefType.factory()
            obj_.build(child_)
            self.ReportingTaxonomyRef = obj_
            obj_.original_tagname_ = 'ReportingTaxonomyRef'
# end class SubmittedStructureType


class SubmissionResultType(GeneratedsSuper):
    """For each Structure object submitted to the repository in a
    SubmitStructure, a SubmissionResult will be returned. It will
    identify the object submitted, report back the action requested,
    and convey the status and any error messages which are relevant
    to the submission."""
    subclass = None
    superclass = None
    def __init__(self, SubmittedStructure=None, StatusMessage=None):
        self.original_tagname_ = None
        self.SubmittedStructure = SubmittedStructure
        self.StatusMessage = StatusMessage
    def factory(*args_, **kwargs_):
        if SubmissionResultType.subclass:
            return SubmissionResultType.subclass(*args_, **kwargs_)
        else:
            return SubmissionResultType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SubmittedStructure(self): return self.SubmittedStructure
    def set_SubmittedStructure(self, SubmittedStructure): self.SubmittedStructure = SubmittedStructure
    def get_StatusMessage(self): return self.StatusMessage
    def set_StatusMessage(self, StatusMessage): self.StatusMessage = StatusMessage
    def hasContent_(self):
        if (
            self.SubmittedStructure is not None or
            self.StatusMessage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='SubmissionResultType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubmissionResultType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='SubmissionResultType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='SubmissionResultType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='SubmissionResultType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SubmittedStructure is not None:
            self.SubmittedStructure.export(outfile, level, namespace_, name_='SubmittedStructure', pretty_print=pretty_print)
        if self.StatusMessage is not None:
            self.StatusMessage.export(outfile, level, namespace_, name_='StatusMessage', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SubmissionResultType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SubmittedStructure is not None:
            showIndent(outfile, level)
            outfile.write('SubmittedStructure=model_.SubmittedStructureType(\n')
            self.SubmittedStructure.exportLiteral(outfile, level, name_='SubmittedStructure')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.StatusMessage is not None:
            showIndent(outfile, level)
            outfile.write('StatusMessage=model_.StatusMessageType(\n')
            self.StatusMessage.exportLiteral(outfile, level, name_='StatusMessage')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SubmittedStructure':
            obj_ = SubmittedStructureType.factory()
            obj_.build(child_)
            self.SubmittedStructure = obj_
            obj_.original_tagname_ = 'SubmittedStructure'
        elif nodeName_ == 'StatusMessage':
            obj_ = StatusMessageType.factory()
            obj_.build(child_)
            self.StatusMessage = obj_
            obj_.original_tagname_ = 'StatusMessage'
# end class SubmissionResultType


class AgencyRefType(GeneratedsSuper):
    """The AgencyRef type structures a reference to an Agency. This
    requires that IDs be provided for an organisation scheme, its
    maintenance agency, and the agency as identified in the
    referenced organisation scheme. The Version element may be used
    to specify the version of the indicated agency. If absent, the
    most recent version is assumed. The URN element is used to
    provide the registry-specific urn as an alternate means of
    identification. At a minimum, either the URN element or
    OrgansisationSchemeID, OrganisationSchemeAgencyID, AgencyID, and
    (optionally) Version must be supplied. When used in a response
    document of any type, the URN must always be provided."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, OrganisationSchemeAgencyID=None, OrganisationSchemeID=None, AgencyID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
        self.OrganisationSchemeID = OrganisationSchemeID
        self.AgencyID = AgencyID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if AgencyRefType.subclass:
            return AgencyRefType.subclass(*args_, **kwargs_)
        else:
            return AgencyRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_OrganisationSchemeAgencyID(self): return self.OrganisationSchemeAgencyID
    def set_OrganisationSchemeAgencyID(self, OrganisationSchemeAgencyID): self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID
    def get_OrganisationSchemeID(self): return self.OrganisationSchemeID
    def set_OrganisationSchemeID(self, OrganisationSchemeID): self.OrganisationSchemeID = OrganisationSchemeID
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.OrganisationSchemeAgencyID is not None or
            self.OrganisationSchemeID is not None or
            self.AgencyID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AgencyRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AgencyRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AgencyRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AgencyRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AgencyRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeAgencyID>%s</%sOrganisationSchemeAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeAgencyID).encode(ExternalEncoding), input_name='OrganisationSchemeAgencyID'), namespace_, eol_))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sOrganisationSchemeID>%s</%sOrganisationSchemeID>%s' % (namespace_, self.gds_format_string(quote_xml(self.OrganisationSchemeID).encode(ExternalEncoding), input_name='OrganisationSchemeID'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AgencyRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.OrganisationSchemeAgencyID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeAgencyID=%s,\n' % quote_python(self.OrganisationSchemeAgencyID).encode(ExternalEncoding))
        if self.OrganisationSchemeID is not None:
            showIndent(outfile, level)
            outfile.write('OrganisationSchemeID=%s,\n' % quote_python(self.OrganisationSchemeID).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'OrganisationSchemeAgencyID':
            OrganisationSchemeAgencyID_ = child_.text
            OrganisationSchemeAgencyID_ = self.gds_validate_string(OrganisationSchemeAgencyID_, node, 'OrganisationSchemeAgencyID')
            self.OrganisationSchemeAgencyID = OrganisationSchemeAgencyID_
            self.validate_IDType(self.OrganisationSchemeAgencyID)    # validate type IDType
        elif nodeName_ == 'OrganisationSchemeID':
            OrganisationSchemeID_ = child_.text
            OrganisationSchemeID_ = self.gds_validate_string(OrganisationSchemeID_, node, 'OrganisationSchemeID')
            self.OrganisationSchemeID = OrganisationSchemeID_
            self.validate_IDType(self.OrganisationSchemeID)    # validate type IDType
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class AgencyRefType


class StructureSetRefType(GeneratedsSuper):
    """StructureSetRef allows for references to specific structure sets. At
    a minimum, either the URN - which contains a valid
    Registry/Repository URN - or the rest of the child elements must
    be supplied. When used in a response document of any type, the
    URN must always be provided."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, StructureSetID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.StructureSetID = StructureSetID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if StructureSetRefType.subclass:
            return StructureSetRefType.subclass(*args_, **kwargs_)
        else:
            return StructureSetRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_StructureSetID(self): return self.StructureSetID
    def set_StructureSetID(self, StructureSetID): self.StructureSetID = StructureSetID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.StructureSetID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StructureSetRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StructureSetRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StructureSetRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StructureSetRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='StructureSetRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.StructureSetID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStructureSetID>%s</%sStructureSetID>%s' % (namespace_, self.gds_format_string(quote_xml(self.StructureSetID).encode(ExternalEncoding), input_name='StructureSetID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='StructureSetRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.StructureSetID is not None:
            showIndent(outfile, level)
            outfile.write('StructureSetID=%s,\n' % quote_python(self.StructureSetID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'StructureSetID':
            StructureSetID_ = child_.text
            StructureSetID_ = self.gds_validate_string(StructureSetID_, node, 'StructureSetID')
            self.StructureSetID = StructureSetID_
            self.validate_IDType(self.StructureSetID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class StructureSetRefType


class ProcessRefType(GeneratedsSuper):
    """ProcessRef allows for references to specific processes. At a
    minimum, either the URN - which contains a valid
    Registry/Repository URN - or the rest of the child elements must
    be supplied. When used in a response document of any type, the
    URN must always be provided."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, ProcessID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.ProcessID = ProcessID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ProcessRefType.subclass:
            return ProcessRefType.subclass(*args_, **kwargs_)
        else:
            return ProcessRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ProcessID(self): return self.ProcessID
    def set_ProcessID(self, ProcessID): self.ProcessID = ProcessID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.ProcessID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ProcessRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ProcessRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ProcessRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ProcessRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ProcessID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessID>%s</%sProcessID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ProcessID).encode(ExternalEncoding), input_name='ProcessID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ProcessRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ProcessID is not None:
            showIndent(outfile, level)
            outfile.write('ProcessID=%s,\n' % quote_python(self.ProcessID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'ProcessID':
            ProcessID_ = child_.text
            ProcessID_ = self.gds_validate_string(ProcessID_, node, 'ProcessID')
            self.ProcessID = ProcessID_
            self.validate_IDType(self.ProcessID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ProcessRefType


class ReportingTaxonomyRefType(GeneratedsSuper):
    """ReportingTaxonomyRef allows for references to specific reporting
    taxonomies. At a minimum, either the URN - which contains a
    valid Registry/Repository URN - or the rest of the child
    elements must be supplied. When used in a response document of
    any type, the URN must always be provided."""
    subclass = None
    superclass = None
    def __init__(self, URN=None, AgencyID=None, ReportingTaxonomyID=None, Version=None):
        self.original_tagname_ = None
        self.URN = URN
        self.AgencyID = AgencyID
        self.ReportingTaxonomyID = ReportingTaxonomyID
        self.Version = Version
    def factory(*args_, **kwargs_):
        if ReportingTaxonomyRefType.subclass:
            return ReportingTaxonomyRefType.subclass(*args_, **kwargs_)
        else:
            return ReportingTaxonomyRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URN(self): return self.URN
    def set_URN(self, URN): self.URN = URN
    def get_AgencyID(self): return self.AgencyID
    def set_AgencyID(self, AgencyID): self.AgencyID = AgencyID
    def get_ReportingTaxonomyID(self): return self.ReportingTaxonomyID
    def set_ReportingTaxonomyID(self, ReportingTaxonomyID): self.ReportingTaxonomyID = ReportingTaxonomyID
    def get_Version(self): return self.Version
    def set_Version(self, Version): self.Version = Version
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.URN is not None or
            self.AgencyID is not None or
            self.ReportingTaxonomyID is not None or
            self.Version is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyRefType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportingTaxonomyRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportingTaxonomyRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportingTaxonomyRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportingTaxonomyRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URN is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURN>%s</%sURN>%s' % (namespace_, self.gds_format_string(quote_xml(self.URN).encode(ExternalEncoding), input_name='URN'), namespace_, eol_))
        if self.AgencyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAgencyID>%s</%sAgencyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.AgencyID).encode(ExternalEncoding), input_name='AgencyID'), namespace_, eol_))
        if self.ReportingTaxonomyID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportingTaxonomyID>%s</%sReportingTaxonomyID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReportingTaxonomyID).encode(ExternalEncoding), input_name='ReportingTaxonomyID'), namespace_, eol_))
        if self.Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVersion>%s</%sVersion>%s' % (namespace_, self.gds_format_string(quote_xml(self.Version).encode(ExternalEncoding), input_name='Version'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ReportingTaxonomyRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URN is not None:
            showIndent(outfile, level)
            outfile.write('URN=%s,\n' % quote_python(self.URN).encode(ExternalEncoding))
        if self.AgencyID is not None:
            showIndent(outfile, level)
            outfile.write('AgencyID=%s,\n' % quote_python(self.AgencyID).encode(ExternalEncoding))
        if self.ReportingTaxonomyID is not None:
            showIndent(outfile, level)
            outfile.write('ReportingTaxonomyID=%s,\n' % quote_python(self.ReportingTaxonomyID).encode(ExternalEncoding))
        if self.Version is not None:
            showIndent(outfile, level)
            outfile.write('Version=%s,\n' % quote_python(self.Version).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URN':
            URN_ = child_.text
            URN_ = self.gds_validate_string(URN_, node, 'URN')
            self.URN = URN_
        elif nodeName_ == 'AgencyID':
            AgencyID_ = child_.text
            AgencyID_ = self.gds_validate_string(AgencyID_, node, 'AgencyID')
            self.AgencyID = AgencyID_
            self.validate_IDType(self.AgencyID)    # validate type IDType
        elif nodeName_ == 'ReportingTaxonomyID':
            ReportingTaxonomyID_ = child_.text
            ReportingTaxonomyID_ = self.gds_validate_string(ReportingTaxonomyID_, node, 'ReportingTaxonomyID')
            self.ReportingTaxonomyID = ReportingTaxonomyID_
            self.validate_IDType(self.ReportingTaxonomyID)    # validate type IDType
        elif nodeName_ == 'Version':
            Version_ = child_.text
            Version_ = self.gds_validate_string(Version_, node, 'Version')
            self.Version = Version_
# end class ReportingTaxonomyRefType


class StatusMessageType(GeneratedsSuper):
    """This carries the text of error messages and/or warnings in response
    to queries or requests. The Status attribute carries the staus
    of the query or request."""
    subclass = None
    superclass = None
    def __init__(self, status=None, MessageText=None):
        self.original_tagname_ = None
        self.status = _cast(None, status)
        if MessageText is None:
            self.MessageText = []
        else:
            self.MessageText = MessageText
    def factory(*args_, **kwargs_):
        if StatusMessageType.subclass:
            return StatusMessageType.subclass(*args_, **kwargs_)
        else:
            return StatusMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_MessageText(self): return self.MessageText
    def set_MessageText(self, MessageText): self.MessageText = MessageText
    def add_MessageText(self, value): self.MessageText.append(value)
    def insert_MessageText_at(self, index, value): self.MessageText.insert(index, value)
    def replace_MessageText_at(self, index, value): self.MessageText[index] = value
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def validate_StatusType(self, value):
        # Validate type StatusType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.MessageText
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='StatusMessageType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatusMessageType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='StatusMessageType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='StatusMessageType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='StatusMessageType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for MessageText_ in self.MessageText:
            MessageText_.export(outfile, level, namespace_, name_='MessageText', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='StatusMessageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('MessageText=[\n')
        level += 1
        for MessageText_ in self.MessageText:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            MessageText_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_StatusType(self.status)    # validate type StatusType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'MessageText':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.MessageText.append(obj_)
            obj_.original_tagname_ = 'MessageText'
# end class StatusMessageType


class MetadataSetType(GeneratedsSuper):
    """The Metadata Set is a set of reported metadata against a set of
    values for a given full or partial target identifier, as
    described in a metadata structure definition. Child elements
    include identification of the relevant metadata structure
    definition using the MetadataStructureRef and
    MetadataStructureAgencyRef elements. The ReportRef element
    includes the ID of the report structure as described in the
    metadata structure definition. AttributeValueSet is a repeatable
    child element which allows target identifier keys and their
    associated metadata attribute values to be reported (this
    functions like a series element does for data sets). An optional
    name and annotations may also be supplied. The
    metadataStructureURI allows for a URI to be provided, pointing
    to the SDMX-ML Structure Message representation of the
    referenced metadata structure definition. Attributes are
    provided for describing the contents of a data or metadata set,
    which are particularly important for interactions with the SDMX
    Registry: datasetID, dataProviderSchemeAgencyID,
    dataProviderSchemeID, dataflowAgencyID, and dataflowID all take
    the IDs specified by the attribute names. The action attribute
    indicates whether the file is appending, replacing, or deleting.
    Attributes reportingBeginDate, reportingEndDate, validFromDate,
    and validToDate are inclusive. publicationYear holds the ISO
    8601 four-digit year, and publicationPeriod specifies the period
    of publication of the data in terms of whatever provisioning
    agreements might be in force (ie, "Q1 2005" if that is the time
    of publication for a data set published on a quarterly basis)."""
    subclass = None
    superclass = None
    def __init__(self, dataProviderSchemeId=None, publicationYear=None, reportingBeginDate=None, publicationPeriod=None, validToDate=None, metadataStructureURI=None, dataProviderID=None, dataflowAgencyID=None, action=None, dataProviderSchemeAgencyId=None, validFromDate=None, reportingEndDate=None, datasetID=None, dataflowID=None, Name=None, MetadataStructureRef=None, MetadataStructureAgencyRef=None, ReportRef=None, AttributeValueSet=None, Annotations=None):
        self.original_tagname_ = None
        self.dataProviderSchemeId = _cast(None, dataProviderSchemeId)
        self.publicationYear = _cast(None, publicationYear)
        self.reportingBeginDate = _cast(None, reportingBeginDate)
        self.publicationPeriod = _cast(None, publicationPeriod)
        self.validToDate = _cast(None, validToDate)
        self.metadataStructureURI = _cast(None, metadataStructureURI)
        self.dataProviderID = _cast(None, dataProviderID)
        self.dataflowAgencyID = _cast(None, dataflowAgencyID)
        self.action = _cast(None, action)
        self.dataProviderSchemeAgencyId = _cast(None, dataProviderSchemeAgencyId)
        self.validFromDate = _cast(None, validFromDate)
        self.reportingEndDate = _cast(None, reportingEndDate)
        self.datasetID = _cast(None, datasetID)
        self.dataflowID = _cast(None, dataflowID)
        if Name is None:
            self.Name = []
        else:
            self.Name = Name
        self.MetadataStructureRef = MetadataStructureRef
        self.MetadataStructureAgencyRef = MetadataStructureAgencyRef
        self.ReportRef = ReportRef
        if AttributeValueSet is None:
            self.AttributeValueSet = []
        else:
            self.AttributeValueSet = AttributeValueSet
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if MetadataSetType.subclass:
            return MetadataSetType.subclass(*args_, **kwargs_)
        else:
            return MetadataSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Name(self): return self.Name
    def set_Name(self, Name): self.Name = Name
    def add_Name(self, value): self.Name.append(value)
    def insert_Name_at(self, index, value): self.Name.insert(index, value)
    def replace_Name_at(self, index, value): self.Name[index] = value
    def get_MetadataStructureRef(self): return self.MetadataStructureRef
    def set_MetadataStructureRef(self, MetadataStructureRef): self.MetadataStructureRef = MetadataStructureRef
    def get_MetadataStructureAgencyRef(self): return self.MetadataStructureAgencyRef
    def set_MetadataStructureAgencyRef(self, MetadataStructureAgencyRef): self.MetadataStructureAgencyRef = MetadataStructureAgencyRef
    def get_ReportRef(self): return self.ReportRef
    def set_ReportRef(self, ReportRef): self.ReportRef = ReportRef
    def get_AttributeValueSet(self): return self.AttributeValueSet
    def set_AttributeValueSet(self, AttributeValueSet): self.AttributeValueSet = AttributeValueSet
    def add_AttributeValueSet(self, value): self.AttributeValueSet.append(value)
    def insert_AttributeValueSet_at(self, index, value): self.AttributeValueSet.insert(index, value)
    def replace_AttributeValueSet_at(self, index, value): self.AttributeValueSet[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_dataProviderSchemeId(self): return self.dataProviderSchemeId
    def set_dataProviderSchemeId(self, dataProviderSchemeId): self.dataProviderSchemeId = dataProviderSchemeId
    def get_publicationYear(self): return self.publicationYear
    def set_publicationYear(self, publicationYear): self.publicationYear = publicationYear
    def get_reportingBeginDate(self): return self.reportingBeginDate
    def set_reportingBeginDate(self, reportingBeginDate): self.reportingBeginDate = reportingBeginDate
    def get_publicationPeriod(self): return self.publicationPeriod
    def set_publicationPeriod(self, publicationPeriod): self.publicationPeriod = publicationPeriod
    def get_validToDate(self): return self.validToDate
    def set_validToDate(self, validToDate): self.validToDate = validToDate
    def get_metadataStructureURI(self): return self.metadataStructureURI
    def set_metadataStructureURI(self, metadataStructureURI): self.metadataStructureURI = metadataStructureURI
    def get_dataProviderID(self): return self.dataProviderID
    def set_dataProviderID(self, dataProviderID): self.dataProviderID = dataProviderID
    def get_dataflowAgencyID(self): return self.dataflowAgencyID
    def set_dataflowAgencyID(self, dataflowAgencyID): self.dataflowAgencyID = dataflowAgencyID
    def get_action(self): return self.action
    def set_action(self, action): self.action = action
    def get_dataProviderSchemeAgencyId(self): return self.dataProviderSchemeAgencyId
    def set_dataProviderSchemeAgencyId(self, dataProviderSchemeAgencyId): self.dataProviderSchemeAgencyId = dataProviderSchemeAgencyId
    def get_validFromDate(self): return self.validFromDate
    def set_validFromDate(self, validFromDate): self.validFromDate = validFromDate
    def get_reportingEndDate(self): return self.reportingEndDate
    def set_reportingEndDate(self, reportingEndDate): self.reportingEndDate = reportingEndDate
    def get_datasetID(self): return self.datasetID
    def set_datasetID(self, datasetID): self.datasetID = datasetID
    def get_dataflowID(self): return self.dataflowID
    def set_dataflowID(self, dataflowID): self.dataflowID = dataflowID
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Name or
            self.MetadataStructureRef is not None or
            self.MetadataStructureAgencyRef is not None or
            self.ReportRef is not None or
            self.AttributeValueSet or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='MetadataSetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MetadataSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='MetadataSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='MetadataSetType'):
        if self.dataProviderSchemeId is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            outfile.write(' dataProviderSchemeId=%s' % (quote_attrib(self.dataProviderSchemeId), ))
        if self.publicationYear is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            outfile.write(' publicationYear=%s' % (self.gds_format_string(quote_attrib(self.publicationYear).encode(ExternalEncoding), input_name='publicationYear'), ))
        if self.reportingBeginDate is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            outfile.write(' reportingBeginDate=%s' % (quote_attrib(self.reportingBeginDate), ))
        if self.publicationPeriod is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            outfile.write(' publicationPeriod=%s' % (quote_attrib(self.publicationPeriod), ))
        if self.validToDate is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            outfile.write(' validToDate=%s' % (quote_attrib(self.validToDate), ))
        if self.metadataStructureURI is not None and 'metadataStructureURI' not in already_processed:
            already_processed.add('metadataStructureURI')
            outfile.write(' metadataStructureURI=%s' % (self.gds_format_string(quote_attrib(self.metadataStructureURI).encode(ExternalEncoding), input_name='metadataStructureURI'), ))
        if self.dataProviderID is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            outfile.write(' dataProviderID=%s' % (quote_attrib(self.dataProviderID), ))
        if self.dataflowAgencyID is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            outfile.write(' dataflowAgencyID=%s' % (quote_attrib(self.dataflowAgencyID), ))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            outfile.write(' action=%s' % (quote_attrib(self.action), ))
        if self.dataProviderSchemeAgencyId is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            outfile.write(' dataProviderSchemeAgencyId=%s' % (quote_attrib(self.dataProviderSchemeAgencyId), ))
        if self.validFromDate is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            outfile.write(' validFromDate=%s' % (quote_attrib(self.validFromDate), ))
        if self.reportingEndDate is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            outfile.write(' reportingEndDate=%s' % (quote_attrib(self.reportingEndDate), ))
        if self.datasetID is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            outfile.write(' datasetID=%s' % (quote_attrib(self.datasetID), ))
        if self.dataflowID is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            outfile.write(' dataflowID=%s' % (quote_attrib(self.dataflowID), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='MetadataSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Name_ in self.Name:
            Name_.export(outfile, level, namespace_, name_='Name', pretty_print=pretty_print)
        if self.MetadataStructureRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructureRef>%s</%sMetadataStructureRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructureRef).encode(ExternalEncoding), input_name='MetadataStructureRef'), namespace_, eol_))
        if self.MetadataStructureAgencyRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMetadataStructureAgencyRef>%s</%sMetadataStructureAgencyRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.MetadataStructureAgencyRef).encode(ExternalEncoding), input_name='MetadataStructureAgencyRef'), namespace_, eol_))
        if self.ReportRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sReportRef>%s</%sReportRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.ReportRef).encode(ExternalEncoding), input_name='ReportRef'), namespace_, eol_))
        for AttributeValueSet_ in self.AttributeValueSet:
            AttributeValueSet_.export(outfile, level, namespace_, name_='AttributeValueSet', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='MetadataSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dataProviderSchemeId is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            showIndent(outfile, level)
            outfile.write('dataProviderSchemeId=%s,\n' % (self.dataProviderSchemeId,))
        if self.publicationYear is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            showIndent(outfile, level)
            outfile.write('publicationYear=%s,\n' % (self.publicationYear,))
        if self.reportingBeginDate is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            showIndent(outfile, level)
            outfile.write('reportingBeginDate=%s,\n' % (self.reportingBeginDate,))
        if self.publicationPeriod is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            showIndent(outfile, level)
            outfile.write('publicationPeriod=%s,\n' % (self.publicationPeriod,))
        if self.validToDate is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            showIndent(outfile, level)
            outfile.write('validToDate=%s,\n' % (self.validToDate,))
        if self.metadataStructureURI is not None and 'metadataStructureURI' not in already_processed:
            already_processed.add('metadataStructureURI')
            showIndent(outfile, level)
            outfile.write('metadataStructureURI="%s",\n' % (self.metadataStructureURI,))
        if self.dataProviderID is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            showIndent(outfile, level)
            outfile.write('dataProviderID=%s,\n' % (self.dataProviderID,))
        if self.dataflowAgencyID is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            showIndent(outfile, level)
            outfile.write('dataflowAgencyID=%s,\n' % (self.dataflowAgencyID,))
        if self.action is not None and 'action' not in already_processed:
            already_processed.add('action')
            showIndent(outfile, level)
            outfile.write('action=%s,\n' % (self.action,))
        if self.dataProviderSchemeAgencyId is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            showIndent(outfile, level)
            outfile.write('dataProviderSchemeAgencyId=%s,\n' % (self.dataProviderSchemeAgencyId,))
        if self.validFromDate is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            showIndent(outfile, level)
            outfile.write('validFromDate=%s,\n' % (self.validFromDate,))
        if self.reportingEndDate is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            showIndent(outfile, level)
            outfile.write('reportingEndDate=%s,\n' % (self.reportingEndDate,))
        if self.datasetID is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            showIndent(outfile, level)
            outfile.write('datasetID=%s,\n' % (self.datasetID,))
        if self.dataflowID is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            showIndent(outfile, level)
            outfile.write('dataflowID=%s,\n' % (self.dataflowID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Name=[\n')
        level += 1
        for Name_ in self.Name:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Name_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.MetadataStructureRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureRef=%s,\n' % quote_python(self.MetadataStructureRef).encode(ExternalEncoding))
        if self.MetadataStructureAgencyRef is not None:
            showIndent(outfile, level)
            outfile.write('MetadataStructureAgencyRef=%s,\n' % quote_python(self.MetadataStructureAgencyRef).encode(ExternalEncoding))
        if self.ReportRef is not None:
            showIndent(outfile, level)
            outfile.write('ReportRef=%s,\n' % quote_python(self.ReportRef).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('AttributeValueSet=[\n')
        level += 1
        for AttributeValueSet_ in self.AttributeValueSet:
            showIndent(outfile, level)
            outfile.write('model_.AttributeValueSetType(\n')
            AttributeValueSet_.exportLiteral(outfile, level, name_='AttributeValueSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dataProviderSchemeId', node)
        if value is not None and 'dataProviderSchemeId' not in already_processed:
            already_processed.add('dataProviderSchemeId')
            self.dataProviderSchemeId = value
        value = find_attr_value_('publicationYear', node)
        if value is not None and 'publicationYear' not in already_processed:
            already_processed.add('publicationYear')
            self.publicationYear = value
        value = find_attr_value_('reportingBeginDate', node)
        if value is not None and 'reportingBeginDate' not in already_processed:
            already_processed.add('reportingBeginDate')
            self.reportingBeginDate = value
        value = find_attr_value_('publicationPeriod', node)
        if value is not None and 'publicationPeriod' not in already_processed:
            already_processed.add('publicationPeriod')
            self.publicationPeriod = value
        value = find_attr_value_('validToDate', node)
        if value is not None and 'validToDate' not in already_processed:
            already_processed.add('validToDate')
            self.validToDate = value
        value = find_attr_value_('metadataStructureURI', node)
        if value is not None and 'metadataStructureURI' not in already_processed:
            already_processed.add('metadataStructureURI')
            self.metadataStructureURI = value
        value = find_attr_value_('dataProviderID', node)
        if value is not None and 'dataProviderID' not in already_processed:
            already_processed.add('dataProviderID')
            self.dataProviderID = value
        value = find_attr_value_('dataflowAgencyID', node)
        if value is not None and 'dataflowAgencyID' not in already_processed:
            already_processed.add('dataflowAgencyID')
            self.dataflowAgencyID = value
        value = find_attr_value_('action', node)
        if value is not None and 'action' not in already_processed:
            already_processed.add('action')
            self.action = value
        value = find_attr_value_('dataProviderSchemeAgencyId', node)
        if value is not None and 'dataProviderSchemeAgencyId' not in already_processed:
            already_processed.add('dataProviderSchemeAgencyId')
            self.dataProviderSchemeAgencyId = value
        value = find_attr_value_('validFromDate', node)
        if value is not None and 'validFromDate' not in already_processed:
            already_processed.add('validFromDate')
            self.validFromDate = value
        value = find_attr_value_('reportingEndDate', node)
        if value is not None and 'reportingEndDate' not in already_processed:
            already_processed.add('reportingEndDate')
            self.reportingEndDate = value
        value = find_attr_value_('datasetID', node)
        if value is not None and 'datasetID' not in already_processed:
            already_processed.add('datasetID')
            self.datasetID = value
        value = find_attr_value_('dataflowID', node)
        if value is not None and 'dataflowID' not in already_processed:
            already_processed.add('dataflowID')
            self.dataflowID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Name':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Name.append(obj_)
            obj_.original_tagname_ = 'Name'
        elif nodeName_ == 'MetadataStructureRef':
            MetadataStructureRef_ = child_.text
            MetadataStructureRef_ = self.gds_validate_string(MetadataStructureRef_, node, 'MetadataStructureRef')
            self.MetadataStructureRef = MetadataStructureRef_
            self.validate_IDType(self.MetadataStructureRef)    # validate type IDType
        elif nodeName_ == 'MetadataStructureAgencyRef':
            MetadataStructureAgencyRef_ = child_.text
            MetadataStructureAgencyRef_ = self.gds_validate_string(MetadataStructureAgencyRef_, node, 'MetadataStructureAgencyRef')
            self.MetadataStructureAgencyRef = MetadataStructureAgencyRef_
            self.validate_IDType(self.MetadataStructureAgencyRef)    # validate type IDType
        elif nodeName_ == 'ReportRef':
            ReportRef_ = child_.text
            ReportRef_ = self.gds_validate_string(ReportRef_, node, 'ReportRef')
            self.ReportRef = ReportRef_
            self.validate_IDType(self.ReportRef)    # validate type IDType
        elif nodeName_ == 'AttributeValueSet':
            obj_ = AttributeValueSetType.factory()
            obj_.build(child_)
            self.AttributeValueSet.append(obj_)
            obj_.original_tagname_ = 'AttributeValueSet'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class MetadataSetType


class AttributeValueSetType(GeneratedsSuper):
    """The attribute value set provides the values for a set of metadata
    attributes reported against a target identifier key. The
    TargetRef element contains the value of the metadata attribute's
    target attribute in the metadata structure definition (that is,
    the ID of the full or partial target identifier which is the
    target of the metadata report). TargetValues is an element
    substructure which provides the specific full or partial target
    identifier component values, and the ReportedAttribute sub-
    element allows for values to be reported against the metadata
    attributes as described in the referenced metadata structure
    definition for the referenced full or partial targets."""
    subclass = None
    superclass = None
    def __init__(self, TargetRef=None, TargetValues=None, ReportedAttribute=None):
        self.original_tagname_ = None
        self.TargetRef = TargetRef
        self.TargetValues = TargetValues
        if ReportedAttribute is None:
            self.ReportedAttribute = []
        else:
            self.ReportedAttribute = ReportedAttribute
    def factory(*args_, **kwargs_):
        if AttributeValueSetType.subclass:
            return AttributeValueSetType.subclass(*args_, **kwargs_)
        else:
            return AttributeValueSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TargetRef(self): return self.TargetRef
    def set_TargetRef(self, TargetRef): self.TargetRef = TargetRef
    def get_TargetValues(self): return self.TargetValues
    def set_TargetValues(self, TargetValues): self.TargetValues = TargetValues
    def get_ReportedAttribute(self): return self.ReportedAttribute
    def set_ReportedAttribute(self, ReportedAttribute): self.ReportedAttribute = ReportedAttribute
    def add_ReportedAttribute(self, value): self.ReportedAttribute.append(value)
    def insert_ReportedAttribute_at(self, index, value): self.ReportedAttribute.insert(index, value)
    def replace_ReportedAttribute_at(self, index, value): self.ReportedAttribute[index] = value
    def validate_IDType(self, value):
        # Validate type IDType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.TargetRef is not None or
            self.TargetValues is not None or
            self.ReportedAttribute
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='AttributeValueSetType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeValueSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='AttributeValueSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='AttributeValueSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='AttributeValueSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TargetRef is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTargetRef>%s</%sTargetRef>%s' % (namespace_, self.gds_format_string(quote_xml(self.TargetRef).encode(ExternalEncoding), input_name='TargetRef'), namespace_, eol_))
        if self.TargetValues is not None:
            self.TargetValues.export(outfile, level, namespace_, name_='TargetValues', pretty_print=pretty_print)
        for ReportedAttribute_ in self.ReportedAttribute:
            ReportedAttribute_.export(outfile, level, namespace_, name_='ReportedAttribute', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='AttributeValueSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TargetRef is not None:
            showIndent(outfile, level)
            outfile.write('TargetRef=%s,\n' % quote_python(self.TargetRef).encode(ExternalEncoding))
        if self.TargetValues is not None:
            showIndent(outfile, level)
            outfile.write('TargetValues=model_.TargetValuesType(\n')
            self.TargetValues.exportLiteral(outfile, level, name_='TargetValues')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ReportedAttribute=[\n')
        level += 1
        for ReportedAttribute_ in self.ReportedAttribute:
            showIndent(outfile, level)
            outfile.write('model_.ReportedAttributeType(\n')
            ReportedAttribute_.exportLiteral(outfile, level, name_='ReportedAttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TargetRef':
            TargetRef_ = child_.text
            TargetRef_ = self.gds_validate_string(TargetRef_, node, 'TargetRef')
            self.TargetRef = TargetRef_
            self.validate_IDType(self.TargetRef)    # validate type IDType
        elif nodeName_ == 'TargetValues':
            obj_ = TargetValuesType.factory()
            obj_.build(child_)
            self.TargetValues = obj_
            obj_.original_tagname_ = 'TargetValues'
        elif nodeName_ == 'ReportedAttribute':
            obj_ = ReportedAttributeType.factory()
            obj_.build(child_)
            self.ReportedAttribute.append(obj_)
            obj_.original_tagname_ = 'ReportedAttribute'
# end class AttributeValueSetType


class TargetValuesType(GeneratedsSuper):
    """Target values contains the specific values for each concept in the
    full or partial target identifier as described in a metadata
    structure definition. These values typically come from codelists
    or other item schemes. Each such value should be presented in
    the order given in the metadata structure definition, and must
    use a valid representation for that concept. Concepts are those
    referenced by the identifier components of the target
    identifiers."""
    subclass = None
    superclass = None
    def __init__(self, ComponentValue=None):
        self.original_tagname_ = None
        if ComponentValue is None:
            self.ComponentValue = []
        else:
            self.ComponentValue = ComponentValue
    def factory(*args_, **kwargs_):
        if TargetValuesType.subclass:
            return TargetValuesType.subclass(*args_, **kwargs_)
        else:
            return TargetValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ComponentValue(self): return self.ComponentValue
    def set_ComponentValue(self, ComponentValue): self.ComponentValue = ComponentValue
    def add_ComponentValue(self, value): self.ComponentValue.append(value)
    def insert_ComponentValue_at(self, index, value): self.ComponentValue.insert(index, value)
    def replace_ComponentValue_at(self, index, value): self.ComponentValue[index] = value
    def hasContent_(self):
        if (
            self.ComponentValue
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='TargetValuesType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TargetValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='TargetValuesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='TargetValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='message:', name_='TargetValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for ComponentValue_ in self.ComponentValue:
            ComponentValue_.export(outfile, level, namespace_, name_='ComponentValue', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TargetValuesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ComponentValue=[\n')
        level += 1
        for ComponentValue_ in self.ComponentValue:
            showIndent(outfile, level)
            outfile.write('model_.ComponentValueType(\n')
            ComponentValue_.exportLiteral(outfile, level, name_='ComponentValueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ComponentValue':
            obj_ = ComponentValueType.factory()
            obj_.build(child_)
            self.ComponentValue.append(obj_)
            obj_.original_tagname_ = 'ComponentValue'
# end class TargetValuesType


class ComponentValueType(GeneratedsSuper):
    """Component values have an object attribute with an object type value
    as provided in the metadata structure definition, a component
    attribute which takes the ID of the identifier component in the
    metadata structure definition's full target identifier, and a
    value, which must be a valid value for that concept's
    representation as described in the metadata structure
    definition."""
    subclass = None
    superclass = None
    def __init__(self, object=None, component=None, valueOf_=None):
        self.original_tagname_ = None
        self.object = _cast(None, object)
        self.component = _cast(None, component)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if ComponentValueType.subclass:
            return ComponentValueType.subclass(*args_, **kwargs_)
        else:
            return ComponentValueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_object(self): return self.object
    def set_object(self, object): self.object = object
    def get_component(self): return self.component
    def set_component(self, component): self.component = component
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def validate_ObjectIDType(self, value):
        # Validate type ObjectIDType, a restriction on xs:NMTOKEN.
        pass
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ComponentValueType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ComponentValueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ComponentValueType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ComponentValueType'):
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            outfile.write(' object=%s' % (quote_attrib(self.object), ))
        if self.component is not None and 'component' not in already_processed:
            already_processed.add('component')
            outfile.write(' component=%s' % (quote_attrib(self.component), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ComponentValueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ComponentValueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.object is not None and 'object' not in already_processed:
            already_processed.add('object')
            showIndent(outfile, level)
            outfile.write('object="%s",\n' % (self.object,))
        if self.component is not None and 'component' not in already_processed:
            already_processed.add('component')
            showIndent(outfile, level)
            outfile.write('component=%s,\n' % (self.component,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('object', node)
        if value is not None and 'object' not in already_processed:
            already_processed.add('object')
            self.object = value
            self.validate_ObjectIDType(self.object)    # validate type ObjectIDType
        value = find_attr_value_('component', node)
        if value is not None and 'component' not in already_processed:
            already_processed.add('component')
            self.component = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ComponentValueType


class ReportedAttributeType(GeneratedsSuper):
    """Reported attributes hold the values which are to be reported against
    the target specified in the metadata structure definition, and
    according to the metadata attributes specified for the target
    referenced in the TargetRef element. Each reported attribute may
    have Value sub-elements (one per language) if it takes a text or
    numeric value. The StartTime element is only used if the
    attribute being represented is of the Timespan type (as
    described in the corresponding TextFormat element in the
    metadata structure definition). In this case, the Value takes a
    duration. Only one such value is allowed in the
    ReportedAttribute in this case. The types of these values must
    conform to the limitations described in the metadata structure
    definition. Also - if permitted by the metadata structure
    definition - there may be one or more child ReportedAttribute
    elements. These must be arranged in the nesting hierarchy given
    in the metadat structure definition. The conceptID attribute
    provides the id of the concept given in the metadata structure
    definition to which the reported attribute corresponds."""
    subclass = None
    superclass = None
    def __init__(self, conceptID=None, Value=None, StartTime=None, ReportedAttribute=None, Annotations=None):
        self.original_tagname_ = None
        self.conceptID = _cast(None, conceptID)
        if Value is None:
            self.Value = []
        else:
            self.Value = Value
        if isinstance(StartTime, basestring):
            initvalue_ = datetime_.datetime.strptime(StartTime, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = StartTime
        self.StartTime = initvalue_
        if ReportedAttribute is None:
            self.ReportedAttribute = []
        else:
            self.ReportedAttribute = ReportedAttribute
        self.Annotations = Annotations
    def factory(*args_, **kwargs_):
        if ReportedAttributeType.subclass:
            return ReportedAttributeType.subclass(*args_, **kwargs_)
        else:
            return ReportedAttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Value(self): return self.Value
    def set_Value(self, Value): self.Value = Value
    def add_Value(self, value): self.Value.append(value)
    def insert_Value_at(self, index, value): self.Value.insert(index, value)
    def replace_Value_at(self, index, value): self.Value[index] = value
    def get_StartTime(self): return self.StartTime
    def set_StartTime(self, StartTime): self.StartTime = StartTime
    def get_ReportedAttribute(self): return self.ReportedAttribute
    def set_ReportedAttribute(self, ReportedAttribute): self.ReportedAttribute = ReportedAttribute
    def add_ReportedAttribute(self, value): self.ReportedAttribute.append(value)
    def insert_ReportedAttribute_at(self, index, value): self.ReportedAttribute.insert(index, value)
    def replace_ReportedAttribute_at(self, index, value): self.ReportedAttribute[index] = value
    def get_Annotations(self): return self.Annotations
    def set_Annotations(self, Annotations): self.Annotations = Annotations
    def get_conceptID(self): return self.conceptID
    def set_conceptID(self, conceptID): self.conceptID = conceptID
    def hasContent_(self):
        if (
            self.Value or
            self.StartTime is not None or
            self.ReportedAttribute or
            self.Annotations is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='message:', name_='ReportedAttributeType', namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message" xmlns:common="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportedAttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='message:', name_='ReportedAttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='message:', name_='ReportedAttributeType'):
        if self.conceptID is not None and 'conceptID' not in already_processed:
            already_processed.add('conceptID')
            outfile.write(' conceptID=%s' % (quote_attrib(self.conceptID), ))
    def exportChildren(self, outfile, level, namespace_='message:', name_='ReportedAttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Value_ in self.Value:
            Value_.export(outfile, level, namespace_, name_='Value', pretty_print=pretty_print)
        if self.StartTime is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStartTime>%s</%sStartTime>%s' % (namespace_, self.gds_format_datetime(self.StartTime, input_name='StartTime'), namespace_, eol_))
        for ReportedAttribute_ in self.ReportedAttribute:
            ReportedAttribute_.export(outfile, level, namespace_, name_='ReportedAttribute', pretty_print=pretty_print)
        if self.Annotations is not None:
            self.Annotations.export(outfile, level, namespace_, name_='Annotations', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReportedAttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.conceptID is not None and 'conceptID' not in already_processed:
            already_processed.add('conceptID')
            showIndent(outfile, level)
            outfile.write('conceptID=%s,\n' % (self.conceptID,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Value=[\n')
        level += 1
        for Value_ in self.Value:
            showIndent(outfile, level)
            outfile.write('model_.TextType(\n')
            Value_.exportLiteral(outfile, level, name_='TextType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.StartTime is not None:
            showIndent(outfile, level)
            outfile.write('StartTime=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.StartTime, input_name='StartTime'))
        showIndent(outfile, level)
        outfile.write('ReportedAttribute=[\n')
        level += 1
        for ReportedAttribute_ in self.ReportedAttribute:
            showIndent(outfile, level)
            outfile.write('model_.ReportedAttributeType(\n')
            ReportedAttribute_.exportLiteral(outfile, level, name_='ReportedAttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.Annotations is not None:
            showIndent(outfile, level)
            outfile.write('Annotations=model_.AnnotationsType(\n')
            self.Annotations.exportLiteral(outfile, level, name_='Annotations')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('conceptID', node)
        if value is not None and 'conceptID' not in already_processed:
            already_processed.add('conceptID')
            self.conceptID = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Value':
            obj_ = TextType.factory()
            obj_.build(child_)
            self.Value.append(obj_)
            obj_.original_tagname_ = 'Value'
        elif nodeName_ == 'StartTime':
            sval_ = child_.text
            dval_ = self.gds_parse_datetime(sval_)
            self.StartTime = dval_
        elif nodeName_ == 'ReportedAttribute':
            obj_ = ReportedAttributeType.factory()
            obj_.build(child_)
            self.ReportedAttribute.append(obj_)
            obj_.original_tagname_ = 'ReportedAttribute'
        elif nodeName_ == 'Annotations':
            obj_ = AnnotationsType.factory()
            obj_.build(child_)
            self.Annotations = obj_
            obj_.original_tagname_ = 'Annotations'
# end class ReportedAttributeType


GDSClassesMapping = {
    'ComponentValue': ComponentValueType,
    'MetadataWhere': MetadataWhereType,
    'ValidityPeriod': ValidityPeriodType,
    'MetadataSet': MetadataSetType,
    'SubmitProvisioningRequest': SubmitProvisioningRequestType,
    'TargetCategoryID': CategoryIDType,
    'CodeRef': CodeRefType,
    'RelatedStructures': RelatedStructuresType,
    'Role': TextType,
    'Department': TextType,
    'CodelistRef': CodelistRefType,
    'DataProviders': DataProvidersType,
    'Annotations': AnnotationsType,
    'NotifyRegistryEvent': NotifyRegistryEventType,
    'KeyFamily': KeyFamilyType,
    'RepresentationMapRef': RepresentationMapRefType,
    'CompactData': CompactDataType,
    'Agencies': AgenciesType,
    'ToTextFormat': TextFormatType,
    'TargetIdentifiers': TargetIdentifiersType,
    'ReleaseCalendar': ReleaseCalendarType,
    'StatusMessage': StatusMessageType,
    'QueryProvisioningRequest': QueryProvisioningRequestType,
    'MetadataReport': MetadataReportType,
    'ProvisioningEvent': ProvisioningEventType,
    'DataProvider': OrganisationType,
    'Annotation': AnnotationType,
    'TargetCategorySchemeRef': CategorySchemeRefType,
    'StructuralEvent': StructuralEventType,
    'Agency': OrganisationType,
    'ProcessRef': ProcessRefType,
    'Sender': PartyType,
    'Level': LevelType,
    'OrganisationMap': OrganisationMapType,
    'Value': TextType,
    'SubmissionResult': SubmissionResultType,
    'PartialTargetIdentifier': PartialTargetIdentifierType,
    'CodeList': CodeListType,
    'DataflowRef': DataflowRefType,
    'SubmitStructureResponse': SubmitStructureResponseType,
    'Components': ComponentsType,
    'Receiver': PartyType,
    'Attributes': ValuesType,
    'SubmitRegistrationResponse': SubmitRegistrationResponseType,
    'Or': OrType,
    'QueryRegistrationRequest': QueryRegistrationRequestType,
    'QueryStructureResponse': QueryStructureResponseType,
    'Member': MemberType,
    'CubeRegion': CubeRegionType,
    'DataProviderRef': DataProviderRefType,
    'CodeMap': CodeMapType,
    'Process': ProcessType,
    'AnnotationText': TextType,
    'ComponentMap': ComponentMapType,
    'MetadatataflowRef': MetadataflowRefType,
    'IdentifierComponent': IdentifierComponentType,
    'ReportedAttribute': ReportedAttributeType,
    'ConceptSchemeWhere': ConceptSchemeWhereType,
    'CategoryID': CategoryIDType,
    'ReportingTaxonomyWhere': ReportingTaxonomyWhereType,
    'GenericMetadata': GenericMetadataType,
    'DataConsumers': DataConsumersType,
    'SubscriptionStatus': StatusMessageType,
    'ProcessWhere': ProcessWhereType,
    'TargetConceptSchemeRef': ConceptSchemeRefType,
    'Source': TextType,
    'Codelist': CodelistType,
    'DataProviderWhere': DataProviderWhereType,
    'TextFormat': TextFormatType,
    'Metadataflow': MetadataflowType,
    'OrganisationSchemes': OrganisationSchemesType,
    'OtherContact': ContactType,
    'OrganisationSchemeWhere': OrganisationSchemeWhereType,
    'MetadataAttribute': MetadataAttributeType,
    'ReportingTaxonomy': ReportingTaxonomyType,
    'KeySet': KeySetType,
    'ConceptSchemeRef': ConceptSchemeRefType,
    'StructureSets': StructureSetsType,
    'SubmitStructureRequest': SubmitStructureRequestType,
    'HierarchicalCodelistRef': HierarchicalCodelistRefType,
    'Key': KeyType,
    'OrganisationScheme': OrganisationSchemeType,
    'Subscription': SubscriptionType,
    'AgencyRef': AgencyRefType,
    'CategoryScheme': CategorySchemeType,
    'SubmitProvisioningResponse': SubmitProvisioningResponseType,
    'QueryProvisioningResponse': QueryProvisioningResponseType,
    'MetadataflowWhere': MetadataflowWhereType,
    'HierarchicalCodelists': HierarchicalCodelistsType,
    'Contact': ContactType,
    'RegistrationEvent': RegistrationEventType,
    'KeyFamilyRef': KeyFamilyRefType,
    'Registration': RegistrationType,
    'Dimension': DimensionType,
    'MetadataStructureDefinition': MetadataStructureDefinitionType,
    'Concept': ConceptType,
    'DisseminatorContact': ContactType,
    'Hierarchy': HierarchyType,
    'SubmitSubscriptionRequest': SubmitSubscriptionRequestType,
    'ProvisionAgreement': ProvisionAgreementType,
    'CategorySchemes': CategorySchemesType,
    'KeyFamilyWhere': KeyFamilyWhereType,
    'Computation': TextType,
    'Query': QueryType,
    'StructureSetWhere': StructureSetWhereType,
    'Category': CategoryType,
    'StructureComponent': StructureComponentType,
    'Group': GroupType,
    'MetadataflowRef': MetadataflowRefType,
    'StructureSetRef': StructureSetRefType,
    'DataSet': DataSetType,
    'ReportingTaxonomies': ReportingTaxonomiesType,
    'EventSelector': EventSelectorType,
    'DataWhere': DataWhereType,
    'QueryResult': QueryResultType,
    'CategoryRef': CategoryRefType,
    'QueryMessage': QueryMessageType,
    'ProvisioningStatus': ProvisioningStatusType,
    'SubmitSubscriptionResponse': SubmitSubscriptionResponseType,
    'OrganisationSchemeRef': OrganisationSchemeRefType,
    'HierarchicalCodelist': HierarchicalCodelistType,
    'MetadataStructureWhere': MetadataStructureWhereType,
    'Obs': ObsType,
    'CategoryMap': CategoryMapType,
    'TargetValues': TargetValuesType,
    'MaintenanceContact': ContactType,
    'Dataflows': DataflowsType,
    'CategorySchemeMap': CategorySchemeMapType,
    'Section': SectionType,
    'Condition': TextType,
    'CategorySchemeWhere': CategorySchemeWhereType,
    'Processes': ProcessesType,
    'ProcessStep': ProcessStepType,
    'Constraint': ConstraintType,
    'Transition': TransitionType,
    'KeyFamilies': KeyFamiliesType,
    'ProvisionAgreementRef': ProvisionAgreementRefType,
    'CrossSectionalData': CrossSectionalDataType,
    'ReporterContact': ContactType,
    'Time': TimeType,
    'TimeDimension': TimeDimensionType,
    'CrossSectionalMeasure': CrossSectionalMeasureType,
    'And': AndType,
    'Code': CodeType,
    'DataResult': ResultType,
    'PrimaryMeasure': PrimaryMeasureType,
    'Attribute': AttributeType,
    'StructureSet': StructureSetType,
    'Header': HeaderType,
    'ConceptScheme': ConceptSchemeType,
    'StructureMap': StructureMapType,
    'UtilityData': UtilityDataType,
    'ConceptMap': ConceptMapType,
    'CodingType': TextFormatType,
    'ConceptWhere': ConceptWhereType,
    'MessageText': TextType,
    'GenericData': GenericDataType,
    'MetadataStructureRef': MetadataStructureRefType,
    'QueryStructureRequest': QueryStructureRequestType,
    'AgencyWhere': AgencyWhereType,
    'DataflowWhere': DataflowWhereType,
    'SeriesKey': SeriesKeyType,
    'TargetHierarchicalCodelistRef': HierarchicalCodelistRefType,
    'MetadataConceptSet': MetadataConceptSetType,
    'AttributeValueSet': AttributeValueSetType,
    'ReportStructure': ReportStructureType,
    'SubmittedStructure': SubmittedStructureType,
    'Description': TextType,
    'TargetCodelistRef': CodelistRefType,
    'TargetMetadataStructureRef': MetadataStructureRefType,
    'MetadataRegistrationEvents': MetadataRegistrationEventsType,
    'FullTargetIdentifier': FullTargetIdentifierType,
    'RegistryInterface': RegistryInterfaceType,
    'SubmitRegistrationRequest': SubmitRegistrationRequestType,
    'MetadaflowRef': MetadataflowRefType,
    'ReferencePeriod': ReferencePeriodType,
    'Structure': StructureType,
    'QueryRegistrationResponse': QueryRegistrationResponseType,
    'Name': TextType,
    'GroupKey': ValuesType,
    'Dataflow': DataflowType,
    'CodeLists': CodeListsType,
    'MetadataResult': ResultType,
    'RegistrationStatus': RegistrationStatusType,
    'CodelistMap': CodelistMapType,
    'QueryableDatasource': QueryableDatasourceType,
    'Concepts': ConceptsType,
    'StructuralRepositoryEvents': StructuralRepositoryEventsType,
    'ConceptSchemeMap': ConceptSchemeMapType,
    'MetadataStructureDefinitions': MetadataStructureDefinitionsType,
    'CategorySchemeRef': CategorySchemeRefType,
    'MemberValue': MemberValueType,
    'CollectorContact': ContactType,
    'DataRegistrationEvents': DataRegistrationEventsType,
    'Series': SeriesType,
    'OrganisationSchemeMap': OrganisationSchemeMapType,
    'ProvisioningRepositoryEvents': ProvisioningRepositoryEventsType,
    'RepresentationScheme': RepresentationSchemeType,
    'DataConsumer': OrganisationType,
    'ReportingTaxonomyRef': ReportingTaxonomyRefType,
    'CodelistWhere': CodelistWhereType,
    'MessageGroup': MessageGroupType,
    'TargetOrganisationSchemeRef': OrganisationSchemeRefType,
    'ObsValue': ObsValueType,
    'Metadataflows': MetadataflowsType,
    'HierarchicalCodelistWhere': HierarchicalCodelistWhereType,
    'TargetKeyFamilyRef': KeyFamilyRefType,
    'Datasource': DatasourceType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StructureType'
        rootClass = StructureType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StructureType'
        rootClass = StructureType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StructureType'
        rootClass = StructureType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='xmlns:message="http://www.SDMX.org/resources/SDMXML/schemas/v2_0/message"')
    return rootObj


def parseLiteral(inFileName, silence=False):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'StructureType'
        rootClass = StructureType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from sdmxMessage import *\n\n')
        sys.stdout.write('import sdmxMessage as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AgenciesType",
    "AgencyRefType",
    "AgencyWhereType",
    "AndType",
    "AnnotationType",
    "AnnotationsType",
    "AttachmentConstraintRefType",
    "AttributeType",
    "AttributeValueSetType",
    "CategoryIDType",
    "CategoryMapType",
    "CategoryRefType",
    "CategorySchemeMapType",
    "CategorySchemeRefType",
    "CategorySchemeType",
    "CategorySchemeWhereType",
    "CategorySchemesType",
    "CategoryType",
    "CodeListType",
    "CodeListsType",
    "CodeMapType",
    "CodeRefType",
    "CodeType",
    "CodelistMapType",
    "CodelistRefType",
    "CodelistType",
    "CodelistWhereType",
    "CompactDataType",
    "ComponentMapType",
    "ComponentValueType",
    "ComponentsType",
    "ConceptMapType",
    "ConceptSchemeMapType",
    "ConceptSchemeRefType",
    "ConceptSchemeType",
    "ConceptSchemeWhereType",
    "ConceptType",
    "ConceptWhereType",
    "ConceptsType",
    "ConstraintType",
    "ContactType",
    "CrossSectionalDataType",
    "CrossSectionalMeasureType",
    "CubeRegionType",
    "DataConsumersType",
    "DataProviderRefType",
    "DataProviderWhereType",
    "DataProvidersType",
    "DataRegistrationEventsType",
    "DataSetType",
    "DataWhereType",
    "DataflowRefType",
    "DataflowType",
    "DataflowWhereType",
    "DataflowsType",
    "DatasourceType",
    "DimensionType",
    "EventSelectorType",
    "FullTargetIdentifierType",
    "GenericDataType",
    "GenericMetadataType",
    "GroupType",
    "HeaderType",
    "HierarchicalCodelistRefType",
    "HierarchicalCodelistType",
    "HierarchicalCodelistWhereType",
    "HierarchicalCodelistsType",
    "HierarchyType",
    "IdentifierComponentType",
    "KeyFamiliesType",
    "KeyFamilyRefType",
    "KeyFamilyType",
    "KeyFamilyWhereType",
    "KeySetType",
    "KeyType",
    "LevelType",
    "MemberType",
    "MemberValueType",
    "MessageGroupType",
    "MessageType",
    "MetadataAttributeType",
    "MetadataConceptSetType",
    "MetadataRegistrationEventsType",
    "MetadataReportType",
    "MetadataSetType",
    "MetadataStructureDefinitionType",
    "MetadataStructureDefinitionsType",
    "MetadataStructureRefType",
    "MetadataStructureWhereType",
    "MetadataWhereType",
    "MetadataflowRefType",
    "MetadataflowType",
    "MetadataflowWhereType",
    "MetadataflowsType",
    "NotifyRegistryEventType",
    "ObsType",
    "ObsValueType",
    "OrType",
    "OrganisationMapType",
    "OrganisationSchemeMapType",
    "OrganisationSchemeRefType",
    "OrganisationSchemeType",
    "OrganisationSchemeWhereType",
    "OrganisationSchemesType",
    "OrganisationType",
    "PartialTargetIdentifierType",
    "PartyType",
    "PrimaryMeasureType",
    "ProcessRefType",
    "ProcessStepType",
    "ProcessType",
    "ProcessWhereType",
    "ProcessesType",
    "ProvisionAgreementRefType",
    "ProvisionAgreementType",
    "ProvisioningEventType",
    "ProvisioningRepositoryEventsType",
    "ProvisioningStatusType",
    "QueryMessageType",
    "QueryProvisioningRequestType",
    "QueryProvisioningResponseType",
    "QueryRegistrationRequestType",
    "QueryRegistrationResponseType",
    "QueryResultType",
    "QueryStructureRequestType",
    "QueryStructureResponseType",
    "QueryType",
    "QueryableDatasourceType",
    "ReferencePeriodType",
    "RegistrationEventType",
    "RegistrationStatusType",
    "RegistrationType",
    "RegistryInterfaceType",
    "RelatedStructuresType",
    "ReleaseCalendarType",
    "ReportStructureType",
    "ReportedAttributeType",
    "ReportingTaxonomiesType",
    "ReportingTaxonomyRefType",
    "ReportingTaxonomyType",
    "ReportingTaxonomyWhereType",
    "RepresentationMapRefType",
    "RepresentationSchemeType",
    "ResultType",
    "SectionType",
    "SeriesKeyType",
    "SeriesType",
    "StatusMessageType",
    "StructuralEventType",
    "StructuralRepositoryEventsType",
    "StructureComponentType",
    "StructureMapType",
    "StructureSetRefType",
    "StructureSetType",
    "StructureSetWhereType",
    "StructureSetsType",
    "StructureType",
    "SubmissionResultType",
    "SubmitProvisioningRequestType",
    "SubmitProvisioningResponseType",
    "SubmitRegistrationRequestType",
    "SubmitRegistrationResponseType",
    "SubmitStructureRequestType",
    "SubmitStructureResponseType",
    "SubmitSubscriptionRequestType",
    "SubmitSubscriptionResponseType",
    "SubmittedStructureType",
    "SubscriptionType",
    "TargetIdentifiersType",
    "TargetValuesType",
    "TextFormatType",
    "TextType",
    "TimeDimensionType",
    "TimeType",
    "TransitionType",
    "UtilityDataType",
    "ValidityPeriodType",
    "ValueType",
    "ValuesType"
]
